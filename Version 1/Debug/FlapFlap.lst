
FlapFlap.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000200c  10001000  10001000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .VENEER_Code  00000110  2000000c  1000300c  0000800c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 Stack         00000404  2000011c  00000000  0000011c  2**0
                  ALLOC
  3 .data         0000008c  20000520  1000311c  00008520  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000001a4  200005ac  00000490  000085ac  2**2
                  ALLOC
  5 .no_init      00000004  20003ffc  00003ee0  0000011c  2**2
                  ALLOC
  6 .debug_aranges 00000778  00000000  00000000  000085b0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000af24  00000000  00000000  00008d28  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002506  00000000  00000000  00013c4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00003d76  00000000  00000000  00016152  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001210  00000000  00000000  00019ec8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00005396  00000000  00000000  0001b0d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000053e9  00000000  00000000  0002046e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000610  00000000  00000000  00025858  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .build_attributes 000004eb  00000000  00000000  00025e68  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

10001000 <__Vectors>:
10001000:	20 05 00 20 19 10 00 10 00 00 00 00 99 10 00 10      .. ............
10001010:	00 04 01 00 00 00 00 80                             ........

10001018 <Reset_Handler>:
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001018:	4911      	ldr	r1, [pc, #68]	; (10001060 <__copy_data+0xe>)
	ldr	r2, =VeneerStart
1000101a:	4a12      	ldr	r2, [pc, #72]	; (10001064 <__copy_data+0x12>)
	ldr	r3, =VeneerEnd
1000101c:	4b12      	ldr	r3, [pc, #72]	; (10001068 <__copy_data+0x16>)
	bl  __copy_data
1000101e:	f000 f818 	bl	10001052 <__copy_data>

    ldr  r0, =SystemInit
10001022:	4812      	ldr	r0, [pc, #72]	; (1000106c <__copy_data+0x1a>)
    blx  r0
10001024:	4780      	blx	r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001026:	4912      	ldr	r1, [pc, #72]	; (10001070 <__copy_data+0x1e>)
	ldr	r2, =__data_start
10001028:	4a12      	ldr	r2, [pc, #72]	; (10001074 <__copy_data+0x22>)
	ldr	r3, =__data_end
1000102a:	4b13      	ldr	r3, [pc, #76]	; (10001078 <__copy_data+0x26>)
	bl  __copy_data
1000102c:	f000 f811 	bl	10001052 <__copy_data>

/* RAM code */
	ldr	r1, =__ram_code_load
10001030:	4912      	ldr	r1, [pc, #72]	; (1000107c <__copy_data+0x2a>)
	ldr	r2, =__ram_code_start
10001032:	4a13      	ldr	r2, [pc, #76]	; (10001080 <__copy_data+0x2e>)
	ldr	r3, =__ram_code_end
10001034:	4b13      	ldr	r3, [pc, #76]	; (10001084 <__copy_data+0x32>)
	bl  __copy_data
10001036:	f000 f80c 	bl	10001052 <__copy_data>
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
1000103a:	4913      	ldr	r1, [pc, #76]	; (10001088 <__copy_data+0x36>)
	ldr	r2, =__bss_end
1000103c:	4a13      	ldr	r2, [pc, #76]	; (1000108c <__copy_data+0x3a>)

	movs	r0, 0
1000103e:	2000      	movs	r0, #0

	subs	r2, r1
10001040:	1a52      	subs	r2, r2, r1
	ble	.L_loop3_done
10001042:	dd02      	ble.n	1000104a <Reset_Handler+0x32>

.L_loop3:
	subs	r2, #4
10001044:	3a04      	subs	r2, #4
	str	r0, [r1, r2]
10001046:	5088      	str	r0, [r1, r2]
	bgt	.L_loop3
10001048:	dcfc      	bgt.n	10001044 <Reset_Handler+0x2c>
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
1000104a:	4811      	ldr	r0, [pc, #68]	; (10001090 <__copy_data+0x3e>)
    blx  r0
1000104c:	4780      	blx	r0
#endif

    ldr  r0, =main
1000104e:	4811      	ldr	r0, [pc, #68]	; (10001094 <__copy_data+0x42>)
    blx  r0
10001050:	4780      	blx	r0

10001052 <__copy_data>:
 *    r3: end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 *  Uses r0
 */
	subs	r3, r2
10001052:	1a9b      	subs	r3, r3, r2
	ble	.L_loop_done
10001054:	dd03      	ble.n	1000105e <__copy_data+0xc>

.L_loop:
	subs	r3, #4
10001056:	3b04      	subs	r3, #4
	ldr	r0, [r1,r3]
10001058:	58c8      	ldr	r0, [r1, r3]
	str	r0, [r2,r3]
1000105a:	50d0      	str	r0, [r2, r3]
	bgt	.L_loop
1000105c:	dcfb      	bgt.n	10001056 <__copy_data+0x4>

.L_loop_done:
	bx  lr
1000105e:	4770      	bx	lr
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001060:	1000300c 	.word	0x1000300c
	ldr	r2, =VeneerStart
10001064:	2000000c 	.word	0x2000000c
	ldr	r3, =VeneerEnd
10001068:	2000011c 	.word	0x2000011c
	bl  __copy_data

    ldr  r0, =SystemInit
1000106c:	1000209d 	.word	0x1000209d
    blx  r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001070:	1000311c 	.word	0x1000311c
	ldr	r2, =__data_start
10001074:	20000520 	.word	0x20000520
	ldr	r3, =__data_end
10001078:	200005ac 	.word	0x200005ac
	bl  __copy_data

/* RAM code */
	ldr	r1, =__ram_code_load
1000107c:	100031a8 	.word	0x100031a8
	ldr	r2, =__ram_code_start
10001080:	200005ac 	.word	0x200005ac
	ldr	r3, =__ram_code_end
10001084:	200005ac 	.word	0x200005ac
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
10001088:	200005ac 	.word	0x200005ac
	ldr	r2, =__bss_end
1000108c:	2000074c 	.word	0x2000074c
	bgt	.L_loop3
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
10001090:	10002d31 	.word	0x10002d31
    blx  r0
#endif

    ldr  r0, =main
10001094:	100026b9 	.word	0x100026b9

10001098 <CCU40_1_IRQHandler>:
    
    .thumb_func
    .weak Default_handler
    .type Default_handler, %function
Default_handler:
    b  .
10001098:	e7fe      	b.n	10001098 <CCU40_1_IRQHandler>
	...

1000109c <xMBPortEventInit>:
* API IMPLEMENTATION
***************************************************************/
BOOL
xMBPortEventInit( void )
{
    xEventInQueue = false;
1000109c:	2200      	movs	r2, #0
1000109e:	4b02      	ldr	r3, [pc, #8]	; (100010a8 <xMBPortEventInit+0xc>)
100010a0:	701a      	strb	r2, [r3, #0]
    return true;
}
100010a2:	2001      	movs	r0, #1
100010a4:	4770      	bx	lr
100010a6:	46c0      	nop			; (mov r8, r8)
100010a8:	200005ac 	.word	0x200005ac

100010ac <xMBPortEventPost>:

BOOL
xMBPortEventPost( eMBEventType eEvent )
{
    xEventInQueue = true;
100010ac:	2201      	movs	r2, #1
100010ae:	4b03      	ldr	r3, [pc, #12]	; (100010bc <xMBPortEventPost+0x10>)
100010b0:	701a      	strb	r2, [r3, #0]
    eQueuedEvent = eEvent;
100010b2:	4b03      	ldr	r3, [pc, #12]	; (100010c0 <xMBPortEventPost+0x14>)
100010b4:	7018      	strb	r0, [r3, #0]
    return true;
}
100010b6:	2001      	movs	r0, #1
100010b8:	4770      	bx	lr
100010ba:	46c0      	nop			; (mov r8, r8)
100010bc:	200005ac 	.word	0x200005ac
100010c0:	200005ad 	.word	0x200005ad

100010c4 <xMBPortEventGet>:
BOOL
xMBPortEventGet( eMBEventType * eEvent )
{
    BOOL            xEventHappened = false;

    if( xEventInQueue )
100010c4:	4b06      	ldr	r3, [pc, #24]	; (100010e0 <xMBPortEventGet+0x1c>)
100010c6:	781b      	ldrb	r3, [r3, #0]
100010c8:	2b00      	cmp	r3, #0
100010ca:	d007      	beq.n	100010dc <xMBPortEventGet+0x18>
    {
        *eEvent = eQueuedEvent;
100010cc:	4b05      	ldr	r3, [pc, #20]	; (100010e4 <xMBPortEventGet+0x20>)
100010ce:	781b      	ldrb	r3, [r3, #0]
100010d0:	7003      	strb	r3, [r0, #0]
        xEventInQueue = false;
100010d2:	2200      	movs	r2, #0
100010d4:	4b02      	ldr	r3, [pc, #8]	; (100010e0 <xMBPortEventGet+0x1c>)
100010d6:	701a      	strb	r2, [r3, #0]
        xEventHappened = true;
100010d8:	2001      	movs	r0, #1
100010da:	e000      	b.n	100010de <xMBPortEventGet+0x1a>
}

BOOL
xMBPortEventGet( eMBEventType * eEvent )
{
    BOOL            xEventHappened = false;
100010dc:	2000      	movs	r0, #0
        *eEvent = eQueuedEvent;
        xEventInQueue = false;
        xEventHappened = true;
    }
    return xEventHappened;
}
100010de:	4770      	bx	lr
100010e0:	200005ac 	.word	0x200005ac
100010e4:	200005ad 	.word	0x200005ad

100010e8 <MB_register_UART>:
/****************************************************************
* API IMPLEMENTATION
***************************************************************/
void MB_register_UART(XMC_USIC_CH_t *uart)
{
	ptr_uart = uart;
100010e8:	4b01      	ldr	r3, [pc, #4]	; (100010f0 <MB_register_UART+0x8>)
100010ea:	6018      	str	r0, [r3, #0]
}
100010ec:	4770      	bx	lr
100010ee:	46c0      	nop			; (mov r8, r8)
100010f0:	200005b0 	.word	0x200005b0

100010f4 <vMBPortSerialEnable>:

void  vMBPortSerialEnable( BOOL xRxEnable, BOOL xTxEnable )
{
100010f4:	b508      	push	{r3, lr}
	/* We check if only TX or RX is active else we have a problem */
	if( ( TRUE == xRxEnable ) && ( TRUE == xTxEnable ) ){ /* COVERS TX=TRUE and RX=TRUE */
100010f6:	2801      	cmp	r0, #1
100010f8:	d101      	bne.n	100010fe <vMBPortSerialEnable+0xa>
100010fa:	2901      	cmp	r1, #1
100010fc:	d01c      	beq.n	10001138 <vMBPortSerialEnable+0x44>
		/* This is an unsupported configuration */
		/* We fall back to RX only and if supported report an error */
	} else if(TRUE==xTxEnable ){ /* Covers TX = TRUE and RX =FALSE */
100010fe:	2901      	cmp	r1, #1
10001100:	d109      	bne.n	10001116 <vMBPortSerialEnable+0x22>

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
10001102:	4b0e      	ldr	r3, [pc, #56]	; (1000113c <vMBPortSerialEnable+0x48>)
10001104:	2208      	movs	r2, #8
10001106:	605a      	str	r2, [r3, #4]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
10001108:	2280      	movs	r2, #128	; 0x80
1000110a:	0352      	lsls	r2, r2, #13
1000110c:	605a      	str	r2, [r3, #4]
		XMC_GPIO_SetOutputHigh(P0_3);
		XMC_GPIO_SetOutputLow(P0_4);



		(void)pxMBFrameCBTransmitterEmpty();
1000110e:	4b0c      	ldr	r3, [pc, #48]	; (10001140 <vMBPortSerialEnable+0x4c>)
10001110:	681b      	ldr	r3, [r3, #0]
10001112:	4798      	blx	r3
10001114:	e010      	b.n	10001138 <vMBPortSerialEnable+0x44>
	} else if(TRUE==xRxEnable){ /* COVERS TX = FALSE and RX = TRUE */
10001116:	2801      	cmp	r0, #1
10001118:	d106      	bne.n	10001128 <vMBPortSerialEnable+0x34>
1000111a:	4b08      	ldr	r3, [pc, #32]	; (1000113c <vMBPortSerialEnable+0x48>)
1000111c:	2280      	movs	r2, #128	; 0x80
1000111e:	0312      	lsls	r2, r2, #12
10001120:	605a      	str	r2, [r3, #4]

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
10001122:	2210      	movs	r2, #16
10001124:	605a      	str	r2, [r3, #4]
10001126:	e007      	b.n	10001138 <vMBPortSerialEnable+0x44>
		XMC_GPIO_SetOutputLow(P0_3);
		XMC_GPIO_SetOutputHigh(P0_4);


	} else if( ( FALSE == xRxEnable ) && ( FALSE == xTxEnable ) ){ /* COVERS TX = FALSE and RX = FALSE */
10001128:	4301      	orrs	r1, r0
1000112a:	d105      	bne.n	10001138 <vMBPortSerialEnable+0x44>

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
1000112c:	4b03      	ldr	r3, [pc, #12]	; (1000113c <vMBPortSerialEnable+0x48>)
1000112e:	2280      	movs	r2, #128	; 0x80
10001130:	0312      	lsls	r2, r2, #12
10001132:	605a      	str	r2, [r3, #4]

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
10001134:	2210      	movs	r2, #16
10001136:	605a      	str	r2, [r3, #4]


	} else {
	  /* Shall not happen */
	}
}
10001138:	bd08      	pop	{r3, pc}
1000113a:	46c0      	nop			; (mov r8, r8)
1000113c:	40040000 	.word	0x40040000
10001140:	20000738 	.word	0x20000738

10001144 <xMBPortSerialInit>:
{
}

BOOL
xMBPortSerialInit( UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits, eMBParity eParity )
{
10001144:	b530      	push	{r4, r5, lr}
10001146:	b089      	sub	sp, #36	; 0x24
  BOOL return_value=false;

  if (ptr_uart == XMC_UART0_CH0)
10001148:	4829      	ldr	r0, [pc, #164]	; (100011f0 <xMBPortSerialInit+0xac>)
1000114a:	6804      	ldr	r4, [r0, #0]
1000114c:	2090      	movs	r0, #144	; 0x90
1000114e:	05c0      	lsls	r0, r0, #23
10001150:	4284      	cmp	r4, r0
10001152:	d14a      	bne.n	100011ea <xMBPortSerialInit+0xa6>
  {

	  XMC_UART_CH_CONFIG_t uart_config;
	  uart_config.data_bits = ucDataBits;
10001154:	a805      	add	r0, sp, #20
10001156:	7102      	strb	r2, [r0, #4]
	  uart_config.frame_length=0;
10001158:	2200      	movs	r2, #0
1000115a:	7142      	strb	r2, [r0, #5]
	  uart_config.stop_bits = 1U; /* As we don't use ASCII 7Bit stopbits will be one */
1000115c:	3201      	adds	r2, #1
1000115e:	7182      	strb	r2, [r0, #6]
	  /* eParity */
	  switch(eParity){
10001160:	2b01      	cmp	r3, #1
10001162:	d00d      	beq.n	10001180 <xMBPortSerialInit+0x3c>
10001164:	2b00      	cmp	r3, #0
10001166:	d002      	beq.n	1000116e <xMBPortSerialInit+0x2a>
10001168:	2b02      	cmp	r3, #2
1000116a:	d004      	beq.n	10001176 <xMBPortSerialInit+0x32>
1000116c:	e00d      	b.n	1000118a <xMBPortSerialInit+0x46>

		  case MB_PAR_NONE:{
			  uart_config.parity_mode = XMC_USIC_CH_PARITY_MODE_NONE;
1000116e:	2200      	movs	r2, #0
10001170:	ab05      	add	r3, sp, #20
10001172:	811a      	strh	r2, [r3, #8]
		  } break;
10001174:	e00c      	b.n	10001190 <xMBPortSerialInit+0x4c>

		  case MB_PAR_EVEN:{
			  uart_config.parity_mode = XMC_USIC_CH_PARITY_MODE_EVEN;
10001176:	2280      	movs	r2, #128	; 0x80
10001178:	0092      	lsls	r2, r2, #2
1000117a:	ab05      	add	r3, sp, #20
1000117c:	811a      	strh	r2, [r3, #8]
		  } break;
1000117e:	e007      	b.n	10001190 <xMBPortSerialInit+0x4c>

		  case MB_PAR_ODD:{
			  uart_config.parity_mode = XMC_USIC_CH_PARITY_MODE_ODD;
10001180:	22c0      	movs	r2, #192	; 0xc0
10001182:	0092      	lsls	r2, r2, #2
10001184:	ab05      	add	r3, sp, #20
10001186:	811a      	strh	r2, [r3, #8]
		  } break;
10001188:	e002      	b.n	10001190 <xMBPortSerialInit+0x4c>

		  default:{
			  uart_config.parity_mode = XMC_USIC_CH_PARITY_MODE_NONE;
1000118a:	2200      	movs	r2, #0
1000118c:	ab05      	add	r3, sp, #20
1000118e:	811a      	strh	r2, [r3, #8]
		  } break;

	  }

	  uart_config.baudrate = ulBaudRate;
10001190:	9105      	str	r1, [sp, #20]
	  /* Configure UART channel */
	  XMC_UART_CH_Init(XMC_UART0_CH0, &uart_config);
10001192:	2490      	movs	r4, #144	; 0x90
10001194:	05e4      	lsls	r4, r4, #23
10001196:	1c20      	adds	r0, r4, #0
10001198:	a905      	add	r1, sp, #20
1000119a:	f001 f8d9 	bl	10002350 <XMC_UART_CH_Init>


	  /* Configure RX pin */
	  XMC_GPIO_CONFIG_t rx_pin_config;
	  rx_pin_config.mode = XMC_GPIO_MODE_INPUT_TRISTATE;
1000119e:	aa01      	add	r2, sp, #4
100011a0:	2300      	movs	r3, #0
100011a2:	7013      	strb	r3, [r2, #0]
	  XMC_GPIO_Init(XMC_GPIO_PORT2,1, &rx_pin_config);
100011a4:	4d13      	ldr	r5, [pc, #76]	; (100011f4 <xMBPortSerialInit+0xb0>)
100011a6:	1c28      	adds	r0, r5, #0
100011a8:	2101      	movs	r1, #1
100011aa:	f000 ff7d 	bl	100020a8 <XMC_GPIO_Init>
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_EnableInputInversion() \n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_UART_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)(channel->DXCR[input] & (~(USIC_CH_DX0CR_INSW_Msk|USIC_CH_DX0CR_DSEN_Msk)));
100011ae:	69e3      	ldr	r3, [r4, #28]
100011b0:	2250      	movs	r2, #80	; 0x50
100011b2:	4393      	bics	r3, r2
100011b4:	61e3      	str	r3, [r4, #28]
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
100011b6:	69e3      	ldr	r3, [r4, #28]
100011b8:	3a49      	subs	r2, #73	; 0x49
100011ba:	4393      	bics	r3, r2
100011bc:	3a02      	subs	r2, #2
100011be:	4313      	orrs	r3, r2
100011c0:	61e3      	str	r3, [r4, #28]
	  XMC_UART_CH_SetInputSource(XMC_UART0_CH0,XMC_UART_CH_INPUT_RXD,USIC0_C0_DX0_P2_1);
	  /* Configure TX pin */
	  XMC_GPIO_CONFIG_t tx_pin_config;
	  tx_pin_config.mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT6;
100011c2:	aa03      	add	r2, sp, #12
100011c4:	23b0      	movs	r3, #176	; 0xb0
100011c6:	7013      	strb	r3, [r2, #0]
	  XMC_GPIO_Init(XMC_GPIO_PORT2,0, &tx_pin_config);
100011c8:	1c28      	adds	r0, r5, #0
100011ca:	2100      	movs	r1, #0
100011cc:	f000 ff6c 	bl	100020a8 <XMC_GPIO_Init>
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_Stop(), XMC_UART_CH_Transmit()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_Start(XMC_USIC_CH_t *const channel)
{
  channel->CCR = (uint32_t)(((channel->CCR) & (~USIC_CH_CCR_MODE_Msk)) | (uint32_t)XMC_USIC_CH_OPERATING_MODE_UART);
100011d0:	6c23      	ldr	r3, [r4, #64]	; 0x40
100011d2:	220f      	movs	r2, #15
100011d4:	4393      	bics	r3, r2
100011d6:	3a0d      	subs	r2, #13
100011d8:	4313      	orrs	r3, r2
100011da:	6423      	str	r3, [r4, #64]	; 0x40
	  /* Start UART channel */
	  XMC_UART_CH_Start(XMC_UART0_CH0);

	  XMC_UART_CH_EnableEvent(XMC_UART0_CH0,(XMC_UART_CH_EVENT_STANDARD_RECEIVE | XMC_UART_CH_EVENT_ALTERNATIVE_RECEIVE | XMC_UART_CH_EVENT_TRANSMIT_SHIFT | XMC_UART_CH_EVENT_TRANSMIT_BUFFER | XMC_UART_CH_STATUS_FLAG_TRANSMITTER_FRAME_FINISHED));
100011dc:	1c20      	adds	r0, r4, #0
100011de:	21f1      	movs	r1, #241	; 0xf1
100011e0:	0209      	lsls	r1, r1, #8
100011e2:	f001 f913 	bl	1000240c <XMC_UART_CH_EnableEvent>

	  return_value=true;
100011e6:	2001      	movs	r0, #1
100011e8:	e000      	b.n	100011ec <xMBPortSerialInit+0xa8>
}

BOOL
xMBPortSerialInit( UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits, eMBParity eParity )
{
  BOOL return_value=false;
100011ea:	2000      	movs	r0, #0

	  return_value=true;
  }

  return return_value;
}
100011ec:	b009      	add	sp, #36	; 0x24
100011ee:	bd30      	pop	{r4, r5, pc}
100011f0:	200005b0 	.word	0x200005b0
100011f4:	40040200 	.word	0x40040200

100011f8 <xMBPortSerialPutByte>:

BOOL
xMBPortSerialPutByte( CHAR ucByte )
{
100011f8:	b508      	push	{r3, lr}
100011fa:	1c01      	adds	r1, r0, #0
  BOOL return_value=false;

  if (ptr_uart != 0)
100011fc:	4b05      	ldr	r3, [pc, #20]	; (10001214 <xMBPortSerialPutByte+0x1c>)
100011fe:	6818      	ldr	r0, [r3, #0]
10001200:	2800      	cmp	r0, #0
10001202:	d004      	beq.n	1000120e <xMBPortSerialPutByte+0x16>
  {
	  XMC_UART_CH_Transmit(ptr_uart,(uint8_t)ucByte);
10001204:	b2c9      	uxtb	r1, r1
10001206:	f001 f8dd 	bl	100023c4 <XMC_UART_CH_Transmit>
	  //UART_TransmitWord(ptr_uart,(uint8_t)ucByte);
    return_value=true;
1000120a:	2001      	movs	r0, #1
1000120c:	e000      	b.n	10001210 <xMBPortSerialPutByte+0x18>
}

BOOL
xMBPortSerialPutByte( CHAR ucByte )
{
  BOOL return_value=false;
1000120e:	2000      	movs	r0, #0
	  //UART_TransmitWord(ptr_uart,(uint8_t)ucByte);
    return_value=true;
  }

  return return_value;
}
10001210:	bd08      	pop	{r3, pc}
10001212:	46c0      	nop			; (mov r8, r8)
10001214:	200005b0 	.word	0x200005b0

10001218 <xMBPortSerialGetByte>:
BOOL
xMBPortSerialGetByte( CHAR * pucByte )
{
10001218:	b510      	push	{r4, lr}
  BOOL return_value=false;

  if (ptr_uart != 0)
1000121a:	4b08      	ldr	r3, [pc, #32]	; (1000123c <xMBPortSerialGetByte+0x24>)
1000121c:	681b      	ldr	r3, [r3, #0]
1000121e:	2b00      	cmp	r3, #0
10001220:	d00a      	beq.n	10001238 <xMBPortSerialGetByte+0x20>
10001222:	1c04      	adds	r4, r0, #0
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_DisableEvent(),  XMC_UART_CH_GetStatusFlag()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, const uint32_t flag)
{
  channel->PSCR = flag;
10001224:	2090      	movs	r0, #144	; 0x90
10001226:	05c0      	lsls	r0, r0, #23
10001228:	23c0      	movs	r3, #192	; 0xc0
1000122a:	021b      	lsls	r3, r3, #8
1000122c:	64c3      	str	r3, [r0, #76]	; 0x4c
  {
	  XMC_UART_CH_ClearStatusFlag(XMC_UART0_CH0, (XMC_UART_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION |
	                                     XMC_UART_CH_STATUS_FLAG_RECEIVE_INDICATION));
	  *pucByte=(int8_t)XMC_UART_CH_GetReceivedData(XMC_UART0_CH0);
1000122e:	f001 f8dd 	bl	100023ec <XMC_UART_CH_GetReceivedData>
10001232:	7020      	strb	r0, [r4, #0]
      return_value=true;
10001234:	2001      	movs	r0, #1
10001236:	e000      	b.n	1000123a <xMBPortSerialGetByte+0x22>
  return return_value;
}
BOOL
xMBPortSerialGetByte( CHAR * pucByte )
{
  BOOL return_value=false;
10001238:	2000      	movs	r0, #0
	  *pucByte=(int8_t)XMC_UART_CH_GetReceivedData(XMC_UART0_CH0);
      return_value=true;
  }

  return return_value;
}
1000123a:	bd10      	pop	{r4, pc}
1000123c:	200005b0 	.word	0x200005b0

10001240 <MB_RxHandler>:

void MB_RxHandler(void)
{
10001240:	b508      	push	{r3, lr}
  (void)pxMBFrameCBByteReceived();
10001242:	4b02      	ldr	r3, [pc, #8]	; (1000124c <MB_RxHandler+0xc>)
10001244:	681b      	ldr	r3, [r3, #0]
10001246:	4798      	blx	r3
}
10001248:	bd08      	pop	{r3, pc}
1000124a:	46c0      	nop			; (mov r8, r8)
1000124c:	20000740 	.word	0x20000740

10001250 <MB_TxHandler>:
void MB_TxHandler(void)
{
10001250:	b508      	push	{r3, lr}
  (void)pxMBFrameCBTransmitterEmpty();
10001252:	4b02      	ldr	r3, [pc, #8]	; (1000125c <MB_TxHandler+0xc>)
10001254:	681b      	ldr	r3, [r3, #0]
10001256:	4798      	blx	r3
}
10001258:	bd08      	pop	{r3, pc}
1000125a:	46c0      	nop			; (mov r8, r8)
1000125c:	20000738 	.word	0x20000738

10001260 <CCU40_0_IRQHandler>:
/****************************************************************
* API IMPLEMENTATION
***************************************************************/

void CCU40_0_IRQHandler(void)
{
10001260:	b508      	push	{r3, lr}

  pxMBPortCBTimerExpired();
10001262:	4b02      	ldr	r3, [pc, #8]	; (1000126c <CCU40_0_IRQHandler+0xc>)
10001264:	681b      	ldr	r3, [r3, #0]
10001266:	4798      	blx	r3

}
10001268:	bd08      	pop	{r3, pc}
1000126a:	46c0      	nop			; (mov r8, r8)
1000126c:	2000073c 	.word	0x2000073c

10001270 <xMBPortTimersInit>:
{
#if MB_TCP_ENABLED > 0
  timeout = usTim1Timerout50us;
#endif
  return true;
}
10001270:	2001      	movs	r0, #1
10001272:	4770      	bx	lr

10001274 <vMBPortTimersEnable>:
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StopClearTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StopClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = CCU4_CC4_TCCLR_TRBC_Msk | CCU4_CC4_TCCLR_TCC_Msk;
10001274:	4b06      	ldr	r3, [pc, #24]	; (10001290 <vMBPortTimersEnable+0x1c>)
10001276:	2203      	movs	r2, #3
10001278:	611a      	str	r2, [r3, #16]
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
1000127a:	4a06      	ldr	r2, [pc, #24]	; (10001294 <vMBPortTimersEnable+0x20>)
1000127c:	2180      	movs	r1, #128	; 0x80
1000127e:	0389      	lsls	r1, r1, #14
10001280:	20c0      	movs	r0, #192	; 0xc0
10001282:	0040      	lsls	r0, r0, #1
10001284:	5011      	str	r1, [r2, r0]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
10001286:	6011      	str	r1, [r2, #0]
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
10001288:	2201      	movs	r2, #1
1000128a:	60da      	str	r2, [r3, #12]
  NVIC_EnableIRQ(CCU40_0_IRQn);
  XMC_CCU4_SLICE_StartTimer(SLICE_PTR);


#endif
}
1000128c:	4770      	bx	lr
1000128e:	46c0      	nop			; (mov r8, r8)
10001290:	48040100 	.word	0x48040100
10001294:	e000e100 	.word	0xe000e100

10001298 <vMBPortTimersDisable>:
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
10001298:	2180      	movs	r1, #128	; 0x80
1000129a:	0389      	lsls	r1, r1, #14
1000129c:	2380      	movs	r3, #128	; 0x80
1000129e:	4a05      	ldr	r2, [pc, #20]	; (100012b4 <vMBPortTimersDisable+0x1c>)
100012a0:	50d1      	str	r1, [r2, r3]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
100012a2:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
100012a6:	f3bf 8f6f 	isb	sy
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StopClearTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StopClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = CCU4_CC4_TCCLR_TRBC_Msk | CCU4_CC4_TCCLR_TCC_Msk;
100012aa:	2203      	movs	r2, #3
100012ac:	4b02      	ldr	r3, [pc, #8]	; (100012b8 <vMBPortTimersDisable+0x20>)
100012ae:	611a      	str	r2, [r3, #16]
  XMC_CCU4_SLICE_StopClearTimer(SLICE_PTR);



#endif
}
100012b0:	4770      	bx	lr
100012b2:	46c0      	nop			; (mov r8, r8)
100012b4:	e000e100 	.word	0xe000e100
100012b8:	48040100 	.word	0x48040100

100012bc <usMBCRC16>:
    0x41, 0x81, 0x80, 0x40
};

USHORT
usMBCRC16( UCHAR * pucFrame, USHORT usLen )
{
100012bc:	b530      	push	{r4, r5, lr}
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
100012be:	22ff      	movs	r2, #255	; 0xff
};

USHORT
usMBCRC16( UCHAR * pucFrame, USHORT usLen )
{
    UCHAR           ucCRCHi = 0xFF;
100012c0:	25ff      	movs	r5, #255	; 0xff
    UCHAR           ucCRCLo = 0xFF;
    int             iIndex;

    while( usLen-- )
100012c2:	e008      	b.n	100012d6 <usMBCRC16+0x1a>
    {
        iIndex = ucCRCLo ^ *( pucFrame++ );
100012c4:	7803      	ldrb	r3, [r0, #0]
100012c6:	4053      	eors	r3, r2
        ucCRCLo = ( UCHAR )( ucCRCHi ^ aucCRCHi[iIndex] );
100012c8:	4a06      	ldr	r2, [pc, #24]	; (100012e4 <usMBCRC16+0x28>)
100012ca:	5cd2      	ldrb	r2, [r2, r3]
100012cc:	406a      	eors	r2, r5
        ucCRCHi = aucCRCLo[iIndex];
100012ce:	4906      	ldr	r1, [pc, #24]	; (100012e8 <usMBCRC16+0x2c>)
100012d0:	5ccd      	ldrb	r5, [r1, r3]
{
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
    int             iIndex;

    while( usLen-- )
100012d2:	1c21      	adds	r1, r4, #0
    {
        iIndex = ucCRCLo ^ *( pucFrame++ );
100012d4:	3001      	adds	r0, #1
{
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
    int             iIndex;

    while( usLen-- )
100012d6:	1e4b      	subs	r3, r1, #1
100012d8:	b29c      	uxth	r4, r3
100012da:	2900      	cmp	r1, #0
100012dc:	d1f2      	bne.n	100012c4 <usMBCRC16+0x8>
    {
        iIndex = ucCRCLo ^ *( pucFrame++ );
        ucCRCLo = ( UCHAR )( ucCRCHi ^ aucCRCHi[iIndex] );
        ucCRCHi = aucCRCLo[iIndex];
    }
    return ( USHORT )( ucCRCHi << 8 | ucCRCLo );
100012de:	0228      	lsls	r0, r5, #8
100012e0:	4310      	orrs	r0, r2
}
100012e2:	bd30      	pop	{r4, r5, pc}
100012e4:	10002e90 	.word	0x10002e90
100012e8:	10002d90 	.word	0x10002d90

100012ec <eMBRTUInit>:
static volatile USHORT usRcvBufferPos;

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
100012ec:	b510      	push	{r4, lr}
100012ee:	1c14      	adds	r4, r2, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
100012f0:	b672      	cpsid	i

    ( void )ucSlaveAddress;
    ENTER_CRITICAL_SECTION(  );

    /* Modbus RTU uses 8 Databits. */
    if( xMBPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
100012f2:	1c08      	adds	r0, r1, #0
100012f4:	1c11      	adds	r1, r2, #0
100012f6:	2208      	movs	r2, #8
100012f8:	f7ff ff24 	bl	10001144 <xMBPortSerialInit>
100012fc:	2801      	cmp	r0, #1
100012fe:	d110      	bne.n	10001322 <eMBRTUInit+0x36>
    else
    {
        /* If baudrate > 19200 then we should use the fixed timer values
         * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
         */
        if( ulBaudRate > 19200 )
10001300:	2396      	movs	r3, #150	; 0x96
10001302:	01db      	lsls	r3, r3, #7
10001304:	429c      	cmp	r4, r3
10001306:	d804      	bhi.n	10001312 <eMBRTUInit+0x26>
             *             = 11 * Ticks_per_1s / Baudrate
             *             = 220000 / Baudrate
             * The reload for t3.5 is 1.5 times this value and similary
             * for t3.5.
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
10001308:	0061      	lsls	r1, r4, #1
1000130a:	4808      	ldr	r0, [pc, #32]	; (1000132c <eMBRTUInit+0x40>)
1000130c:	f001 fc7e 	bl	10002c0c <__aeabi_uidiv>
10001310:	e000      	b.n	10001314 <eMBRTUInit+0x28>
        /* If baudrate > 19200 then we should use the fixed timer values
         * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
         */
        if( ulBaudRate > 19200 )
        {
            usTimerT35_50us = 35;       /* 1800us. */
10001312:	2023      	movs	r0, #35	; 0x23
             * The reload for t3.5 is 1.5 times this value and similary
             * for t3.5.
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
        }
        if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
10001314:	b280      	uxth	r0, r0
10001316:	f7ff ffab 	bl	10001270 <xMBPortTimersInit>
1000131a:	2801      	cmp	r0, #1
1000131c:	d103      	bne.n	10001326 <eMBRTUInit+0x3a>

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
    eMBErrorCode    eStatus = MB_ENOERR;
1000131e:	2000      	movs	r0, #0
10001320:	e002      	b.n	10001328 <eMBRTUInit+0x3c>
    ENTER_CRITICAL_SECTION(  );

    /* Modbus RTU uses 8 Databits. */
    if( xMBPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
    {
        eStatus = MB_EPORTERR;
10001322:	2003      	movs	r0, #3
10001324:	e000      	b.n	10001328 <eMBRTUInit+0x3c>
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
        }
        if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
        {
            eStatus = MB_EPORTERR;
10001326:	2003      	movs	r0, #3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
10001328:	b662      	cpsie	i
        }
    }
    EXIT_CRITICAL_SECTION(  );

    return eStatus;
}
1000132a:	bd10      	pop	{r4, pc}
1000132c:	00177fa0 	.word	0x00177fa0

10001330 <eMBRTUStart>:

void
eMBRTUStart( void )
{
10001330:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001332:	b672      	cpsid	i
    /* Initially the receiver is in the state STATE_RX_INIT. we start
     * the timer and if no character is received within t3.5 we change
     * to STATE_RX_IDLE. This makes sure that we delay startup of the
     * modbus protocol stack until the bus is free.
     */
    eRcvState = STATE_RX_INIT;
10001334:	2200      	movs	r2, #0
10001336:	4b05      	ldr	r3, [pc, #20]	; (1000134c <eMBRTUStart+0x1c>)
10001338:	701a      	strb	r2, [r3, #0]
    vMBPortSerialEnable( TRUE, FALSE );
1000133a:	2001      	movs	r0, #1
1000133c:	2100      	movs	r1, #0
1000133e:	f7ff fed9 	bl	100010f4 <vMBPortSerialEnable>
    vMBPortTimersEnable(  );
10001342:	f7ff ff97 	bl	10001274 <vMBPortTimersEnable>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
10001346:	b662      	cpsie	i

    EXIT_CRITICAL_SECTION(  );
}
10001348:	bd08      	pop	{r3, pc}
1000134a:	46c0      	nop			; (mov r8, r8)
1000134c:	200005bd 	.word	0x200005bd

10001350 <eMBRTUStop>:

void
eMBRTUStop( void )
{
10001350:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001352:	b672      	cpsid	i
    ENTER_CRITICAL_SECTION(  );
    vMBPortSerialEnable( FALSE, FALSE );
10001354:	2000      	movs	r0, #0
10001356:	2100      	movs	r1, #0
10001358:	f7ff fecc 	bl	100010f4 <vMBPortSerialEnable>
    vMBPortTimersDisable(  );
1000135c:	f7ff ff9c 	bl	10001298 <vMBPortTimersDisable>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
10001360:	b662      	cpsie	i
    EXIT_CRITICAL_SECTION(  );
}
10001362:	bd08      	pop	{r3, pc}

10001364 <eMBRTUReceive>:

eMBErrorCode
eMBRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
{
10001364:	b570      	push	{r4, r5, r6, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001366:	b672      	cpsid	i

    ENTER_CRITICAL_SECTION(  );
    assert( usRcvBufferPos < MB_SER_PDU_SIZE_MAX );

    /* Length and CRC check */
    if( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
10001368:	4b0f      	ldr	r3, [pc, #60]	; (100013a8 <eMBRTUReceive+0x44>)
1000136a:	881b      	ldrh	r3, [r3, #0]
1000136c:	b29b      	uxth	r3, r3
1000136e:	2b03      	cmp	r3, #3
10001370:	d914      	bls.n	1000139c <eMBRTUReceive+0x38>
10001372:	1c15      	adds	r5, r2, #0
10001374:	1c0c      	adds	r4, r1, #0
10001376:	1c06      	adds	r6, r0, #0
        && ( usMBCRC16( ( UCHAR * ) ucRTUBuf, usRcvBufferPos ) == 0 ) )
10001378:	4b0b      	ldr	r3, [pc, #44]	; (100013a8 <eMBRTUReceive+0x44>)
1000137a:	8819      	ldrh	r1, [r3, #0]
1000137c:	b289      	uxth	r1, r1
1000137e:	480b      	ldr	r0, [pc, #44]	; (100013ac <eMBRTUReceive+0x48>)
10001380:	f7ff ff9c 	bl	100012bc <usMBCRC16>
10001384:	2800      	cmp	r0, #0
10001386:	d10b      	bne.n	100013a0 <eMBRTUReceive+0x3c>
    {
        /* Save the address field. All frames are passed to the upper layed
         * and the decision if a frame is used is done there.
         */
        *pucRcvAddress = ucRTUBuf[MB_SER_PDU_ADDR_OFF];
10001388:	4b08      	ldr	r3, [pc, #32]	; (100013ac <eMBRTUReceive+0x48>)
1000138a:	781a      	ldrb	r2, [r3, #0]
1000138c:	7032      	strb	r2, [r6, #0]

        /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
         * size of address field and CRC checksum.
         */
        *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );
1000138e:	4a06      	ldr	r2, [pc, #24]	; (100013a8 <eMBRTUReceive+0x44>)
10001390:	8812      	ldrh	r2, [r2, #0]
10001392:	3a03      	subs	r2, #3
10001394:	802a      	strh	r2, [r5, #0]

        /* Return the start of the Modbus PDU to the caller. */
        *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
10001396:	3301      	adds	r3, #1
10001398:	6023      	str	r3, [r4, #0]
        xFrameReceived = TRUE;
1000139a:	e002      	b.n	100013a2 <eMBRTUReceive+0x3e>
    }
    else
    {
        eStatus = MB_EIO;
1000139c:	2005      	movs	r0, #5
1000139e:	e000      	b.n	100013a2 <eMBRTUReceive+0x3e>
100013a0:	2005      	movs	r0, #5
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
100013a2:	b662      	cpsie	i
    }

    EXIT_CRITICAL_SECTION(  );
    return eStatus;
}
100013a4:	bd70      	pop	{r4, r5, r6, pc}
100013a6:	46c0      	nop			; (mov r8, r8)
100013a8:	200005ba 	.word	0x200005ba
100013ac:	20000638 	.word	0x20000638

100013b0 <eMBRTUSend>:

eMBErrorCode
eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
100013b0:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
100013b2:	b672      	cpsid	i

    /* Check if the receiver is still in idle state. If not we where to
     * slow with processing the received frame and the master sent another
     * frame on the network. We have to abort sending the frame.
     */
    if( eRcvState == STATE_RX_IDLE )
100013b4:	4b17      	ldr	r3, [pc, #92]	; (10001414 <eMBRTUSend+0x64>)
100013b6:	781b      	ldrb	r3, [r3, #0]
100013b8:	2b01      	cmp	r3, #1
100013ba:	d128      	bne.n	1000140e <eMBRTUSend+0x5e>
    {
        /* First byte before the Modbus-PDU is the slave address. */
        pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
100013bc:	1e4b      	subs	r3, r1, #1
100013be:	4916      	ldr	r1, [pc, #88]	; (10001418 <eMBRTUSend+0x68>)
100013c0:	600b      	str	r3, [r1, #0]
        usSndBufferCount = 1;
100013c2:	4c16      	ldr	r4, [pc, #88]	; (1000141c <eMBRTUSend+0x6c>)
100013c4:	2101      	movs	r1, #1
100013c6:	8021      	strh	r1, [r4, #0]

        /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
        pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
100013c8:	7018      	strb	r0, [r3, #0]
        usSndBufferCount += usLength;
100013ca:	8821      	ldrh	r1, [r4, #0]
100013cc:	188a      	adds	r2, r1, r2
100013ce:	b292      	uxth	r2, r2
100013d0:	8022      	strh	r2, [r4, #0]

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
100013d2:	8821      	ldrh	r1, [r4, #0]
100013d4:	b289      	uxth	r1, r1
100013d6:	1c18      	adds	r0, r3, #0
100013d8:	f7ff ff70 	bl	100012bc <usMBCRC16>
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
100013dc:	8823      	ldrh	r3, [r4, #0]
100013de:	b29b      	uxth	r3, r3
100013e0:	1c5a      	adds	r2, r3, #1
100013e2:	b292      	uxth	r2, r2
100013e4:	8022      	strh	r2, [r4, #0]
100013e6:	b2c2      	uxtb	r2, r0
100013e8:	490d      	ldr	r1, [pc, #52]	; (10001420 <eMBRTUSend+0x70>)
100013ea:	54ca      	strb	r2, [r1, r3]
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );
100013ec:	8823      	ldrh	r3, [r4, #0]
100013ee:	b29b      	uxth	r3, r3
100013f0:	1c5a      	adds	r2, r3, #1
100013f2:	b292      	uxth	r2, r2
100013f4:	8022      	strh	r2, [r4, #0]
100013f6:	0a00      	lsrs	r0, r0, #8
100013f8:	b2c0      	uxtb	r0, r0
100013fa:	54c8      	strb	r0, [r1, r3]

        /* Activate the transmitter. */
        eSndState = STATE_TX_XMIT;
100013fc:	4b09      	ldr	r3, [pc, #36]	; (10001424 <eMBRTUSend+0x74>)
100013fe:	2201      	movs	r2, #1
10001400:	701a      	strb	r2, [r3, #0]
        vMBPortSerialEnable( FALSE, TRUE );
10001402:	2000      	movs	r0, #0
10001404:	2101      	movs	r1, #1
10001406:	f7ff fe75 	bl	100010f4 <vMBPortSerialEnable>
}

eMBErrorCode
eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;
1000140a:	2000      	movs	r0, #0
1000140c:	e000      	b.n	10001410 <eMBRTUSend+0x60>
        eSndState = STATE_TX_XMIT;
        vMBPortSerialEnable( FALSE, TRUE );
    }
    else
    {
        eStatus = MB_EIO;
1000140e:	2005      	movs	r0, #5
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
10001410:	b662      	cpsie	i
    }
    EXIT_CRITICAL_SECTION(  );
    return eStatus;
}
10001412:	bd10      	pop	{r4, pc}
10001414:	200005bd 	.word	0x200005bd
10001418:	200005b4 	.word	0x200005b4
1000141c:	200005b8 	.word	0x200005b8
10001420:	20000638 	.word	0x20000638
10001424:	200005bc 	.word	0x200005bc

10001428 <xMBRTUReceiveFSM>:

BOOL
xMBRTUReceiveFSM( void )
{
10001428:	b500      	push	{lr}
1000142a:	b083      	sub	sp, #12
    UCHAR           ucByte;

    assert( eSndState == STATE_TX_IDLE );

    /* Always read the character. */
    ( void )xMBPortSerialGetByte( ( CHAR * ) & ucByte );
1000142c:	466b      	mov	r3, sp
1000142e:	1dd8      	adds	r0, r3, #7
10001430:	f7ff fef2 	bl	10001218 <xMBPortSerialGetByte>

    switch ( eRcvState )
10001434:	4b1d      	ldr	r3, [pc, #116]	; (100014ac <xMBRTUReceiveFSM+0x84>)
10001436:	781b      	ldrb	r3, [r3, #0]
10001438:	b2db      	uxtb	r3, r3
1000143a:	2b01      	cmp	r3, #1
1000143c:	d00c      	beq.n	10001458 <xMBRTUReceiveFSM+0x30>
1000143e:	2b00      	cmp	r3, #0
10001440:	d004      	beq.n	1000144c <xMBRTUReceiveFSM+0x24>
10001442:	2b02      	cmp	r3, #2
10001444:	d01a      	beq.n	1000147c <xMBRTUReceiveFSM+0x54>
10001446:	2b03      	cmp	r3, #3
10001448:	d003      	beq.n	10001452 <xMBRTUReceiveFSM+0x2a>
1000144a:	e02c      	b.n	100014a6 <xMBRTUReceiveFSM+0x7e>
    {
        /* If we have received a character in the init state we have to
         * wait until the frame is finished.
         */
    case STATE_RX_INIT:
        vMBPortTimersEnable(  );
1000144c:	f7ff ff12 	bl	10001274 <vMBPortTimersEnable>
        break;
10001450:	e029      	b.n	100014a6 <xMBRTUReceiveFSM+0x7e>

        /* In the error state we wait until all characters in the
         * damaged frame are transmitted.
         */
    case STATE_RX_ERROR:
        vMBPortTimersEnable(  );
10001452:	f7ff ff0f 	bl	10001274 <vMBPortTimersEnable>
        break;
10001456:	e026      	b.n	100014a6 <xMBRTUReceiveFSM+0x7e>
        /* In the idle state we wait for a new character. If a character
         * is received the t1.5 and t3.5 timers are started and the
         * receiver is in the state STATE_RX_RECEIVCE.
         */
    case STATE_RX_IDLE:
        usRcvBufferPos = 0;
10001458:	4a15      	ldr	r2, [pc, #84]	; (100014b0 <xMBRTUReceiveFSM+0x88>)
1000145a:	2300      	movs	r3, #0
1000145c:	8013      	strh	r3, [r2, #0]
        ucRTUBuf[usRcvBufferPos++] = ucByte;
1000145e:	8813      	ldrh	r3, [r2, #0]
10001460:	b29b      	uxth	r3, r3
10001462:	1c59      	adds	r1, r3, #1
10001464:	b289      	uxth	r1, r1
10001466:	8011      	strh	r1, [r2, #0]
10001468:	466a      	mov	r2, sp
1000146a:	79d1      	ldrb	r1, [r2, #7]
1000146c:	4a11      	ldr	r2, [pc, #68]	; (100014b4 <xMBRTUReceiveFSM+0x8c>)
1000146e:	54d1      	strb	r1, [r2, r3]
        eRcvState = STATE_RX_RCV;
10001470:	2202      	movs	r2, #2
10001472:	4b0e      	ldr	r3, [pc, #56]	; (100014ac <xMBRTUReceiveFSM+0x84>)
10001474:	701a      	strb	r2, [r3, #0]

        /* Enable t3.5 timers. */
        vMBPortTimersEnable(  );
10001476:	f7ff fefd 	bl	10001274 <vMBPortTimersEnable>
        break;
1000147a:	e014      	b.n	100014a6 <xMBRTUReceiveFSM+0x7e>
         * every character received. If more than the maximum possible
         * number of bytes in a modbus frame is received the frame is
         * ignored.
         */
    case STATE_RX_RCV:
        if( usRcvBufferPos < MB_SER_PDU_SIZE_MAX )
1000147c:	4b0c      	ldr	r3, [pc, #48]	; (100014b0 <xMBRTUReceiveFSM+0x88>)
1000147e:	881b      	ldrh	r3, [r3, #0]
10001480:	b29b      	uxth	r3, r3
10001482:	2bff      	cmp	r3, #255	; 0xff
10001484:	d80a      	bhi.n	1000149c <xMBRTUReceiveFSM+0x74>
        {
            ucRTUBuf[usRcvBufferPos++] = ucByte;
10001486:	490a      	ldr	r1, [pc, #40]	; (100014b0 <xMBRTUReceiveFSM+0x88>)
10001488:	880b      	ldrh	r3, [r1, #0]
1000148a:	b29b      	uxth	r3, r3
1000148c:	1c5a      	adds	r2, r3, #1
1000148e:	b292      	uxth	r2, r2
10001490:	800a      	strh	r2, [r1, #0]
10001492:	466a      	mov	r2, sp
10001494:	79d1      	ldrb	r1, [r2, #7]
10001496:	4a07      	ldr	r2, [pc, #28]	; (100014b4 <xMBRTUReceiveFSM+0x8c>)
10001498:	54d1      	strb	r1, [r2, r3]
1000149a:	e002      	b.n	100014a2 <xMBRTUReceiveFSM+0x7a>
        }
        else
        {
            eRcvState = STATE_RX_ERROR;
1000149c:	2203      	movs	r2, #3
1000149e:	4b03      	ldr	r3, [pc, #12]	; (100014ac <xMBRTUReceiveFSM+0x84>)
100014a0:	701a      	strb	r2, [r3, #0]
        }
        vMBPortTimersEnable(  );
100014a2:	f7ff fee7 	bl	10001274 <vMBPortTimersEnable>
        break;
    }
    return xTaskNeedSwitch;
}
100014a6:	2000      	movs	r0, #0
100014a8:	b003      	add	sp, #12
100014aa:	bd00      	pop	{pc}
100014ac:	200005bd 	.word	0x200005bd
100014b0:	200005ba 	.word	0x200005ba
100014b4:	20000638 	.word	0x20000638

100014b8 <xMBRTUTransmitFSM>:

BOOL
xMBRTUTransmitFSM( void )
{
100014b8:	b510      	push	{r4, lr}
    BOOL            xNeedPoll = FALSE;

    assert( eRcvState == STATE_RX_IDLE );

    switch ( eSndState )
100014ba:	4b19      	ldr	r3, [pc, #100]	; (10001520 <xMBRTUTransmitFSM+0x68>)
100014bc:	781b      	ldrb	r3, [r3, #0]
100014be:	b2db      	uxtb	r3, r3
100014c0:	2b00      	cmp	r3, #0
100014c2:	d002      	beq.n	100014ca <xMBRTUTransmitFSM+0x12>
100014c4:	2b01      	cmp	r3, #1
100014c6:	d006      	beq.n	100014d6 <xMBRTUTransmitFSM+0x1e>
100014c8:	e026      	b.n	10001518 <xMBRTUTransmitFSM+0x60>
    {
        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBPortSerialEnable( TRUE, FALSE );
100014ca:	2001      	movs	r0, #1
100014cc:	2100      	movs	r1, #0
100014ce:	f7ff fe11 	bl	100010f4 <vMBPortSerialEnable>
}

BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
100014d2:	2400      	movs	r4, #0
        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBPortSerialEnable( TRUE, FALSE );
        break;
100014d4:	e021      	b.n	1000151a <xMBRTUTransmitFSM+0x62>

    case STATE_TX_XMIT:
        /* check if we are finished. */
        if( usSndBufferCount != 0 )
100014d6:	4b13      	ldr	r3, [pc, #76]	; (10001524 <xMBRTUTransmitFSM+0x6c>)
100014d8:	881b      	ldrh	r3, [r3, #0]
100014da:	b29b      	uxth	r3, r3
100014dc:	2b00      	cmp	r3, #0
100014de:	d00f      	beq.n	10001500 <xMBRTUTransmitFSM+0x48>
        {
            xMBPortSerialPutByte( ( CHAR )*pucSndBufferCur );
100014e0:	4c11      	ldr	r4, [pc, #68]	; (10001528 <xMBRTUTransmitFSM+0x70>)
100014e2:	6823      	ldr	r3, [r4, #0]
100014e4:	7818      	ldrb	r0, [r3, #0]
100014e6:	b240      	sxtb	r0, r0
100014e8:	f7ff fe86 	bl	100011f8 <xMBPortSerialPutByte>
            pucSndBufferCur++;  /* next byte in sendbuffer. */
100014ec:	6823      	ldr	r3, [r4, #0]
100014ee:	3301      	adds	r3, #1
100014f0:	6023      	str	r3, [r4, #0]
            usSndBufferCount--;
100014f2:	4a0c      	ldr	r2, [pc, #48]	; (10001524 <xMBRTUTransmitFSM+0x6c>)
100014f4:	8813      	ldrh	r3, [r2, #0]
100014f6:	3b01      	subs	r3, #1
100014f8:	b29b      	uxth	r3, r3
100014fa:	8013      	strh	r3, [r2, #0]
}

BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
100014fc:	2400      	movs	r4, #0
100014fe:	e00c      	b.n	1000151a <xMBRTUTransmitFSM+0x62>
            pucSndBufferCur++;  /* next byte in sendbuffer. */
            usSndBufferCount--;
        }
        else
        {
            xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
10001500:	2003      	movs	r0, #3
10001502:	f7ff fdd3 	bl	100010ac <xMBPortEventPost>
10001506:	1c04      	adds	r4, r0, #0
            /* Disable transmitter. This prevents another transmit buffer
             * empty interrupt. */
            vMBPortSerialEnable( TRUE, FALSE );
10001508:	2001      	movs	r0, #1
1000150a:	2100      	movs	r1, #0
1000150c:	f7ff fdf2 	bl	100010f4 <vMBPortSerialEnable>
            eSndState = STATE_TX_IDLE;
10001510:	2200      	movs	r2, #0
10001512:	4b03      	ldr	r3, [pc, #12]	; (10001520 <xMBRTUTransmitFSM+0x68>)
10001514:	701a      	strb	r2, [r3, #0]
10001516:	e000      	b.n	1000151a <xMBRTUTransmitFSM+0x62>
}

BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001518:	2400      	movs	r4, #0
        }
        break;
    }

    return xNeedPoll;
}
1000151a:	1c20      	adds	r0, r4, #0
1000151c:	bd10      	pop	{r4, pc}
1000151e:	46c0      	nop			; (mov r8, r8)
10001520:	200005bc 	.word	0x200005bc
10001524:	200005b8 	.word	0x200005b8
10001528:	200005b4 	.word	0x200005b4

1000152c <xMBRTUTimerT35Expired>:

BOOL
xMBRTUTimerT35Expired( void )
{
1000152c:	b510      	push	{r4, lr}
    BOOL            xNeedPoll = FALSE;

    switch ( eRcvState )
1000152e:	4b0d      	ldr	r3, [pc, #52]	; (10001564 <xMBRTUTimerT35Expired+0x38>)
10001530:	781b      	ldrb	r3, [r3, #0]
10001532:	b2db      	uxtb	r3, r3
10001534:	2b00      	cmp	r3, #0
10001536:	d002      	beq.n	1000153e <xMBRTUTimerT35Expired+0x12>
10001538:	2b02      	cmp	r3, #2
1000153a:	d005      	beq.n	10001548 <xMBRTUTimerT35Expired+0x1c>
1000153c:	e009      	b.n	10001552 <xMBRTUTimerT35Expired+0x26>
    {
        /* Timer t35 expired. Startup phase is finished. */
    case STATE_RX_INIT:
        xNeedPoll = xMBPortEventPost( EV_READY );
1000153e:	2000      	movs	r0, #0
10001540:	f7ff fdb4 	bl	100010ac <xMBPortEventPost>
10001544:	1c04      	adds	r4, r0, #0
        break;
10001546:	e005      	b.n	10001554 <xMBRTUTimerT35Expired+0x28>

        /* A frame was received and t35 expired. Notify the listener that
         * a new frame was received. */
    case STATE_RX_RCV:
        xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
10001548:	2001      	movs	r0, #1
1000154a:	f7ff fdaf 	bl	100010ac <xMBPortEventPost>
1000154e:	1c04      	adds	r4, r0, #0
        break;
10001550:	e000      	b.n	10001554 <xMBRTUTimerT35Expired+0x28>
}

BOOL
xMBRTUTimerT35Expired( void )
{
    BOOL            xNeedPoll = FALSE;
10001552:	2400      	movs	r4, #0
    default:
        assert( ( eRcvState == STATE_RX_INIT ) ||
                ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_ERROR ) );
    }

    vMBPortTimersDisable(  );
10001554:	f7ff fea0 	bl	10001298 <vMBPortTimersDisable>
    eRcvState = STATE_RX_IDLE;
10001558:	2201      	movs	r2, #1
1000155a:	4b02      	ldr	r3, [pc, #8]	; (10001564 <xMBRTUTimerT35Expired+0x38>)
1000155c:	701a      	strb	r2, [r3, #0]

    return xNeedPoll;
}
1000155e:	1c20      	adds	r0, r4, #0
10001560:	bd10      	pop	{r4, pc}
10001562:	46c0      	nop			; (mov r8, r8)
10001564:	200005bd 	.word	0x200005bd

10001568 <eMBFuncReadCoils>:

#if MB_FUNC_READ_COILS_ENABLED > 0

eMBException
eMBFuncReadCoils( UCHAR * pucFrame, USHORT * usLen )
{
10001568:	b570      	push	{r4, r5, r6, lr}
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
1000156a:	880b      	ldrh	r3, [r1, #0]
1000156c:	2b05      	cmp	r3, #5
1000156e:	d132      	bne.n	100015d6 <eMBFuncReadCoils+0x6e>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
10001570:	7843      	ldrb	r3, [r0, #1]
10001572:	021b      	lsls	r3, r3, #8
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
10001574:	7882      	ldrb	r2, [r0, #2]
10001576:	4313      	orrs	r3, r2
        usRegAddress++;
10001578:	3301      	adds	r3, #1
1000157a:	b29c      	uxth	r4, r3

        usCoilCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF] << 8 );
1000157c:	78c2      	ldrb	r2, [r0, #3]
1000157e:	0212      	lsls	r2, r2, #8
        usCoilCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF + 1] );
10001580:	7903      	ldrb	r3, [r0, #4]
10001582:	431a      	orrs	r2, r3

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usCoilCount >= 1 ) &&
10001584:	1e53      	subs	r3, r2, #1
10001586:	b29b      	uxth	r3, r3
10001588:	4d15      	ldr	r5, [pc, #84]	; (100015e0 <eMBFuncReadCoils+0x78>)
1000158a:	42ab      	cmp	r3, r5
1000158c:	d825      	bhi.n	100015da <eMBFuncReadCoils+0x72>
            ( usCoilCount < MB_PDU_FUNC_READ_COILCNT_MAX ) )
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
1000158e:	2300      	movs	r3, #0
10001590:	800b      	strh	r3, [r1, #0]

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_COILS;
10001592:	3301      	adds	r3, #1
10001594:	7003      	strb	r3, [r0, #0]
            *usLen += 1;
10001596:	880b      	ldrh	r3, [r1, #0]
10001598:	3301      	adds	r3, #1
1000159a:	800b      	strh	r3, [r1, #0]

            /* Test if the quantity of coils is a multiple of 8. If not last
             * byte is only partially field with unused coils set to zero. */
            if( ( usCoilCount & 0x0007 ) != 0 )
1000159c:	0753      	lsls	r3, r2, #29
1000159e:	d003      	beq.n	100015a8 <eMBFuncReadCoils+0x40>
            {
                ucNBytes = ( UCHAR )( usCoilCount / 8 + 1 );
100015a0:	08d5      	lsrs	r5, r2, #3
100015a2:	3501      	adds	r5, #1
100015a4:	b2ed      	uxtb	r5, r5
100015a6:	e001      	b.n	100015ac <eMBFuncReadCoils+0x44>
            }
            else
            {
                ucNBytes = ( UCHAR )( usCoilCount / 8 );
100015a8:	08d5      	lsrs	r5, r2, #3
100015aa:	b2ed      	uxtb	r5, r5
100015ac:	1c0e      	adds	r6, r1, #0
100015ae:	1c03      	adds	r3, r0, #0
            }
            *pucFrameCur++ = ucNBytes;
100015b0:	3002      	adds	r0, #2
100015b2:	705d      	strb	r5, [r3, #1]
            *usLen += 1;
100015b4:	880b      	ldrh	r3, [r1, #0]
100015b6:	3301      	adds	r3, #1
100015b8:	800b      	strh	r3, [r1, #0]

            eRegStatus =
100015ba:	1c21      	adds	r1, r4, #0
100015bc:	2300      	movs	r3, #0
100015be:	f001 f9a7 	bl	10002910 <eMBRegCoilsCB>
                eMBRegCoilsCB( pucFrameCur, usRegAddress, usCoilCount,
                               MB_REG_READ );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
100015c2:	2800      	cmp	r0, #0
100015c4:	d002      	beq.n	100015cc <eMBFuncReadCoils+0x64>
            {
                eStatus = prveMBError2Exception( eRegStatus );
100015c6:	f000 f9f5 	bl	100019b4 <prveMBError2Exception>
100015ca:	e007      	b.n	100015dc <eMBFuncReadCoils+0x74>
            else
            {
                /* The response contains the function code, the starting address
                 * and the quantity of registers. We reuse the old values in the 
                 * buffer because they are still valid. */
                *usLen += ucNBytes;;
100015cc:	8833      	ldrh	r3, [r6, #0]
100015ce:	195d      	adds	r5, r3, r5
100015d0:	8035      	strh	r5, [r6, #0]
    USHORT          usRegAddress;
    USHORT          usCoilCount;
    UCHAR           ucNBytes;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
100015d2:	2000      	movs	r0, #0
100015d4:	e002      	b.n	100015dc <eMBFuncReadCoils+0x74>
    }
    else
    {
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
100015d6:	2003      	movs	r0, #3
100015d8:	e000      	b.n	100015dc <eMBFuncReadCoils+0x74>
                *usLen += ucNBytes;;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
100015da:	2003      	movs	r0, #3
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
100015dc:	bd70      	pop	{r4, r5, r6, pc}
100015de:	46c0      	nop			; (mov r8, r8)
100015e0:	000007ce 	.word	0x000007ce

100015e4 <eMBFuncWriteCoil>:

#if MB_FUNC_WRITE_COIL_ENABLED > 0
eMBException
eMBFuncWriteCoil( UCHAR * pucFrame, USHORT * usLen )
{
100015e4:	b500      	push	{lr}
100015e6:	b083      	sub	sp, #12
    UCHAR           ucBuf[2];

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
100015e8:	880b      	ldrh	r3, [r1, #0]
100015ea:	2b05      	cmp	r3, #5
100015ec:	d122      	bne.n	10001634 <eMBFuncWriteCoil+0x50>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
100015ee:	7841      	ldrb	r1, [r0, #1]
100015f0:	0209      	lsls	r1, r1, #8
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
100015f2:	7883      	ldrb	r3, [r0, #2]
100015f4:	4319      	orrs	r1, r3
        usRegAddress++;
100015f6:	3101      	adds	r1, #1
100015f8:	b289      	uxth	r1, r1

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
100015fa:	7903      	ldrb	r3, [r0, #4]
100015fc:	2b00      	cmp	r3, #0
100015fe:	d11b      	bne.n	10001638 <eMBFuncWriteCoil+0x54>
            ( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF ) ||
10001600:	78c2      	ldrb	r2, [r0, #3]
10001602:	1e53      	subs	r3, r2, #1
10001604:	b2db      	uxtb	r3, r3
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
        usRegAddress++;

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
10001606:	2bfd      	cmp	r3, #253	; 0xfd
10001608:	d918      	bls.n	1000163c <eMBFuncWriteCoil+0x58>
            ( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF ) ||
              ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0x00 ) ) )
        {
            ucBuf[1] = 0;
1000160a:	2000      	movs	r0, #0
1000160c:	ab01      	add	r3, sp, #4
1000160e:	7058      	strb	r0, [r3, #1]
            if( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF )
10001610:	2aff      	cmp	r2, #255	; 0xff
10001612:	d102      	bne.n	1000161a <eMBFuncWriteCoil+0x36>
            {
                ucBuf[0] = 1;
10001614:	3afe      	subs	r2, #254	; 0xfe
10001616:	701a      	strb	r2, [r3, #0]
10001618:	e002      	b.n	10001620 <eMBFuncWriteCoil+0x3c>
            }
            else
            {
                ucBuf[0] = 0;
1000161a:	2200      	movs	r2, #0
1000161c:	ab01      	add	r3, sp, #4
1000161e:	701a      	strb	r2, [r3, #0]
            }
            eRegStatus =
10001620:	a801      	add	r0, sp, #4
10001622:	2201      	movs	r2, #1
10001624:	2301      	movs	r3, #1
10001626:	f001 f973 	bl	10002910 <eMBRegCoilsCB>
                eMBRegCoilsCB( &ucBuf[0], usRegAddress, 1, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
1000162a:	2800      	cmp	r0, #0
1000162c:	d008      	beq.n	10001640 <eMBFuncWriteCoil+0x5c>
            {
                eStatus = prveMBError2Exception( eRegStatus );
1000162e:	f000 f9c1 	bl	100019b4 <prveMBError2Exception>
10001632:	e006      	b.n	10001642 <eMBFuncWriteCoil+0x5e>
    }
    else
    {
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
10001634:	2003      	movs	r0, #3
10001636:	e004      	b.n	10001642 <eMBFuncWriteCoil+0x5e>
                eStatus = prveMBError2Exception( eRegStatus );
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
10001638:	2003      	movs	r0, #3
1000163a:	e002      	b.n	10001642 <eMBFuncWriteCoil+0x5e>
1000163c:	2003      	movs	r0, #3
1000163e:	e000      	b.n	10001642 <eMBFuncWriteCoil+0x5e>
eMBFuncWriteCoil( UCHAR * pucFrame, USHORT * usLen )
{
    USHORT          usRegAddress;
    UCHAR           ucBuf[2];

    eMBException    eStatus = MB_EX_NONE;
10001640:	2000      	movs	r0, #0
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
10001642:	b003      	add	sp, #12
10001644:	bd00      	pop	{pc}
10001646:	46c0      	nop			; (mov r8, r8)

10001648 <eMBFuncWriteMultipleCoils>:
#endif

#if MB_FUNC_WRITE_MULTIPLE_COILS_ENABLED > 0
eMBException
eMBFuncWriteMultipleCoils( UCHAR * pucFrame, USHORT * usLen )
{
10001648:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    UCHAR           ucByteCountVerify;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen > ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
1000164a:	880b      	ldrh	r3, [r1, #0]
1000164c:	2b05      	cmp	r3, #5
1000164e:	d928      	bls.n	100016a2 <eMBFuncWriteMultipleCoils+0x5a>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
10001650:	7843      	ldrb	r3, [r0, #1]
10001652:	021b      	lsls	r3, r3, #8
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
10001654:	7882      	ldrb	r2, [r0, #2]
10001656:	4313      	orrs	r3, r2
        usRegAddress++;
10001658:	3301      	adds	r3, #1
1000165a:	b29b      	uxth	r3, r3

        usCoilCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF] << 8 );
1000165c:	78c2      	ldrb	r2, [r0, #3]
1000165e:	0212      	lsls	r2, r2, #8
        usCoilCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF + 1] );
10001660:	7904      	ldrb	r4, [r0, #4]
10001662:	4322      	orrs	r2, r4

        ucByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];
10001664:	7947      	ldrb	r7, [r0, #5]

        /* Compute the number of expected bytes in the request. */
        if( ( usCoilCnt & 0x0007 ) != 0 )
10001666:	0754      	lsls	r4, r2, #29
10001668:	d003      	beq.n	10001672 <eMBFuncWriteMultipleCoils+0x2a>
        {
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 + 1 );
1000166a:	08d4      	lsrs	r4, r2, #3
1000166c:	3401      	adds	r4, #1
1000166e:	b2e4      	uxtb	r4, r4
10001670:	e001      	b.n	10001676 <eMBFuncWriteMultipleCoils+0x2e>
        }
        else
        {
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 );
10001672:	08d4      	lsrs	r4, r2, #3
10001674:	b2e4      	uxtb	r4, r4
        }

        if( ( usCoilCnt >= 1 ) &&
10001676:	1e55      	subs	r5, r2, #1
10001678:	b2ad      	uxth	r5, r5
1000167a:	4e0d      	ldr	r6, [pc, #52]	; (100016b0 <eMBFuncWriteMultipleCoils+0x68>)
1000167c:	42b5      	cmp	r5, r6
1000167e:	d812      	bhi.n	100016a6 <eMBFuncWriteMultipleCoils+0x5e>
            ( usCoilCnt <= MB_PDU_FUNC_WRITE_MUL_COILCNT_MAX ) &&
10001680:	42bc      	cmp	r4, r7
10001682:	d112      	bne.n	100016aa <eMBFuncWriteMultipleCoils+0x62>
10001684:	1c0c      	adds	r4, r1, #0
            ( ucByteCountVerify == ucByteCount ) )
        {
            eRegStatus =
                eMBRegCoilsCB( &pucFrame[MB_PDU_FUNC_WRITE_MUL_VALUES_OFF],
10001686:	3006      	adds	r0, #6

        if( ( usCoilCnt >= 1 ) &&
            ( usCoilCnt <= MB_PDU_FUNC_WRITE_MUL_COILCNT_MAX ) &&
            ( ucByteCountVerify == ucByteCount ) )
        {
            eRegStatus =
10001688:	1c19      	adds	r1, r3, #0
1000168a:	2301      	movs	r3, #1
1000168c:	f001 f940 	bl	10002910 <eMBRegCoilsCB>
                eMBRegCoilsCB( &pucFrame[MB_PDU_FUNC_WRITE_MUL_VALUES_OFF],
                               usRegAddress, usCoilCnt, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
10001690:	2800      	cmp	r0, #0
10001692:	d002      	beq.n	1000169a <eMBFuncWriteMultipleCoils+0x52>
            {
                eStatus = prveMBError2Exception( eRegStatus );
10001694:	f000 f98e 	bl	100019b4 <prveMBError2Exception>
10001698:	e008      	b.n	100016ac <eMBFuncWriteMultipleCoils+0x64>
            else
            {
                /* The response contains the function code, the starting address
                 * and the quantity of registers. We reuse the old values in the 
                 * buffer because they are still valid. */
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
1000169a:	2305      	movs	r3, #5
1000169c:	8023      	strh	r3, [r4, #0]
    USHORT          usRegAddress;
    USHORT          usCoilCnt;
    UCHAR           ucByteCount;
    UCHAR           ucByteCountVerify;

    eMBException    eStatus = MB_EX_NONE;
1000169e:	2000      	movs	r0, #0
100016a0:	e004      	b.n	100016ac <eMBFuncWriteMultipleCoils+0x64>
    }
    else
    {
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
100016a2:	2003      	movs	r0, #3
100016a4:	e002      	b.n	100016ac <eMBFuncWriteMultipleCoils+0x64>
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
100016a6:	2003      	movs	r0, #3
100016a8:	e000      	b.n	100016ac <eMBFuncWriteMultipleCoils+0x64>
100016aa:	2003      	movs	r0, #3
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
100016ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
100016ae:	46c0      	nop			; (mov r8, r8)
100016b0:	000007af 	.word	0x000007af

100016b4 <eMBFuncReadDiscreteInputs>:

#if MB_FUNC_READ_COILS_ENABLED > 0

eMBException
eMBFuncReadDiscreteInputs( UCHAR * pucFrame, USHORT * usLen )
{
100016b4:	b570      	push	{r4, r5, r6, lr}
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
100016b6:	880b      	ldrh	r3, [r1, #0]
100016b8:	2b05      	cmp	r3, #5
100016ba:	d131      	bne.n	10001720 <eMBFuncReadDiscreteInputs+0x6c>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
100016bc:	7843      	ldrb	r3, [r0, #1]
100016be:	021b      	lsls	r3, r3, #8
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
100016c0:	7882      	ldrb	r2, [r0, #2]
100016c2:	4313      	orrs	r3, r2
        usRegAddress++;
100016c4:	3301      	adds	r3, #1
100016c6:	b29c      	uxth	r4, r3

        usDiscreteCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF] << 8 );
100016c8:	78c2      	ldrb	r2, [r0, #3]
100016ca:	0212      	lsls	r2, r2, #8
        usDiscreteCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF + 1] );
100016cc:	7903      	ldrb	r3, [r0, #4]
100016ce:	431a      	orrs	r2, r3

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usDiscreteCnt >= 1 ) &&
100016d0:	1e53      	subs	r3, r2, #1
100016d2:	b29b      	uxth	r3, r3
100016d4:	4d14      	ldr	r5, [pc, #80]	; (10001728 <eMBFuncReadDiscreteInputs+0x74>)
100016d6:	42ab      	cmp	r3, r5
100016d8:	d824      	bhi.n	10001724 <eMBFuncReadDiscreteInputs+0x70>
            ( usDiscreteCnt < MB_PDU_FUNC_READ_DISCCNT_MAX ) )
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
100016da:	2300      	movs	r3, #0
100016dc:	800b      	strh	r3, [r1, #0]

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_DISCRETE_INPUTS;
100016de:	3302      	adds	r3, #2
100016e0:	7003      	strb	r3, [r0, #0]
            *usLen += 1;
100016e2:	880b      	ldrh	r3, [r1, #0]
100016e4:	3301      	adds	r3, #1
100016e6:	800b      	strh	r3, [r1, #0]

            /* Test if the quantity of coils is a multiple of 8. If not last
             * byte is only partially field with unused coils set to zero. */
            if( ( usDiscreteCnt & 0x0007 ) != 0 )
100016e8:	0753      	lsls	r3, r2, #29
100016ea:	d003      	beq.n	100016f4 <eMBFuncReadDiscreteInputs+0x40>
            {
                ucNBytes = ( UCHAR ) ( usDiscreteCnt / 8 + 1 );
100016ec:	08d5      	lsrs	r5, r2, #3
100016ee:	3501      	adds	r5, #1
100016f0:	b2ed      	uxtb	r5, r5
100016f2:	e001      	b.n	100016f8 <eMBFuncReadDiscreteInputs+0x44>
            }
            else
            {
                ucNBytes = ( UCHAR ) ( usDiscreteCnt / 8 );
100016f4:	08d5      	lsrs	r5, r2, #3
100016f6:	b2ed      	uxtb	r5, r5
100016f8:	1c0e      	adds	r6, r1, #0
100016fa:	1c03      	adds	r3, r0, #0
            }
            *pucFrameCur++ = ucNBytes;
100016fc:	3002      	adds	r0, #2
100016fe:	705d      	strb	r5, [r3, #1]
            *usLen += 1;
10001700:	880b      	ldrh	r3, [r1, #0]
10001702:	3301      	adds	r3, #1
10001704:	800b      	strh	r3, [r1, #0]

            eRegStatus =
10001706:	1c21      	adds	r1, r4, #0
10001708:	f001 f956 	bl	100029b8 <eMBRegDiscreteCB>
                eMBRegDiscreteCB( pucFrameCur, usRegAddress, usDiscreteCnt );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
1000170c:	2800      	cmp	r0, #0
1000170e:	d002      	beq.n	10001716 <eMBFuncReadDiscreteInputs+0x62>
            {
                eStatus = prveMBError2Exception( eRegStatus );
10001710:	f000 f950 	bl	100019b4 <prveMBError2Exception>
10001714:	e007      	b.n	10001726 <eMBFuncReadDiscreteInputs+0x72>
            else
            {
                /* The response contains the function code, the starting address
                 * and the quantity of registers. We reuse the old values in the 
                 * buffer because they are still valid. */
                *usLen += ucNBytes;;
10001716:	8833      	ldrh	r3, [r6, #0]
10001718:	195d      	adds	r5, r3, r5
1000171a:	8035      	strh	r5, [r6, #0]
    USHORT          usRegAddress;
    USHORT          usDiscreteCnt;
    UCHAR           ucNBytes;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
1000171c:	2000      	movs	r0, #0
1000171e:	e002      	b.n	10001726 <eMBFuncReadDiscreteInputs+0x72>
    }
    else
    {
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
10001720:	2003      	movs	r0, #3
10001722:	e000      	b.n	10001726 <eMBFuncReadDiscreteInputs+0x72>
                *usLen += ucNBytes;;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
10001724:	2003      	movs	r0, #3
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
10001726:	bd70      	pop	{r4, r5, r6, pc}
10001728:	000007ce 	.word	0x000007ce

1000172c <eMBFuncWriteHoldingRegister>:

#if MB_FUNC_WRITE_HOLDING_ENABLED > 0

eMBException
eMBFuncWriteHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
1000172c:	b508      	push	{r3, lr}
    USHORT          usRegAddress;
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
1000172e:	880b      	ldrh	r3, [r1, #0]
10001730:	2b05      	cmp	r3, #5
10001732:	d10f      	bne.n	10001754 <eMBFuncWriteHoldingRegister+0x28>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
10001734:	7841      	ldrb	r1, [r0, #1]
10001736:	0209      	lsls	r1, r1, #8
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
10001738:	7883      	ldrb	r3, [r0, #2]
1000173a:	4319      	orrs	r1, r3
        usRegAddress++;
1000173c:	3101      	adds	r1, #1
1000173e:	b289      	uxth	r1, r1

        /* Make callback to update the value. */
        eRegStatus = eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF],
10001740:	3003      	adds	r0, #3
10001742:	2201      	movs	r2, #1
10001744:	2301      	movs	r3, #1
10001746:	f001 f8a7 	bl	10002898 <eMBRegHoldingCB>
                                      usRegAddress, 1, MB_REG_WRITE );

        /* If an error occured convert it into a Modbus exception. */
        if( eRegStatus != MB_ENOERR )
1000174a:	2800      	cmp	r0, #0
1000174c:	d004      	beq.n	10001758 <eMBFuncWriteHoldingRegister+0x2c>
        {
            eStatus = prveMBError2Exception( eRegStatus );
1000174e:	f000 f931 	bl	100019b4 <prveMBError2Exception>
10001752:	e002      	b.n	1000175a <eMBFuncWriteHoldingRegister+0x2e>
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
10001754:	2003      	movs	r0, #3
10001756:	e000      	b.n	1000175a <eMBFuncWriteHoldingRegister+0x2e>

eMBException
eMBFuncWriteHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
    USHORT          usRegAddress;
    eMBException    eStatus = MB_EX_NONE;
10001758:	2000      	movs	r0, #0
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
1000175a:	bd08      	pop	{r3, pc}

1000175c <eMBFuncWriteMultipleHoldingRegister>:
#endif

#if MB_FUNC_WRITE_MULTIPLE_HOLDING_ENABLED > 0
eMBException
eMBFuncWriteMultipleHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
1000175c:	b538      	push	{r3, r4, r5, lr}
    UCHAR           ucRegByteCount;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_WRITE_MUL_SIZE_MIN + MB_PDU_SIZE_MIN ) )
1000175e:	880b      	ldrh	r3, [r1, #0]
10001760:	2b05      	cmp	r3, #5
10001762:	d921      	bls.n	100017a8 <eMBFuncWriteMultipleHoldingRegister+0x4c>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
10001764:	7843      	ldrb	r3, [r0, #1]
10001766:	021b      	lsls	r3, r3, #8
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
10001768:	7882      	ldrb	r2, [r0, #2]
1000176a:	4313      	orrs	r3, r2
        usRegAddress++;
1000176c:	3301      	adds	r3, #1
1000176e:	b29b      	uxth	r3, r3

        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_REGCNT_OFF] << 8 );
10001770:	78c2      	ldrb	r2, [r0, #3]
10001772:	0212      	lsls	r2, r2, #8
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_REGCNT_OFF + 1] );
10001774:	7904      	ldrb	r4, [r0, #4]
10001776:	4322      	orrs	r2, r4

        ucRegByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];
10001778:	7945      	ldrb	r5, [r0, #5]

        if( ( usRegCount >= 1 ) &&
1000177a:	1e54      	subs	r4, r2, #1
1000177c:	b2a4      	uxth	r4, r4
1000177e:	2c77      	cmp	r4, #119	; 0x77
10001780:	d814      	bhi.n	100017ac <eMBFuncWriteMultipleHoldingRegister+0x50>
            ( usRegCount <= MB_PDU_FUNC_WRITE_MUL_REGCNT_MAX ) &&
            ( ucRegByteCount == ( UCHAR ) ( 2 * usRegCount ) ) )
10001782:	0054      	lsls	r4, r2, #1
10001784:	b2e4      	uxtb	r4, r4
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_REGCNT_OFF + 1] );

        ucRegByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];

        if( ( usRegCount >= 1 ) &&
            ( usRegCount <= MB_PDU_FUNC_WRITE_MUL_REGCNT_MAX ) &&
10001786:	42ac      	cmp	r4, r5
10001788:	d112      	bne.n	100017b0 <eMBFuncWriteMultipleHoldingRegister+0x54>
1000178a:	1c0c      	adds	r4, r1, #0
            ( ucRegByteCount == ( UCHAR ) ( 2 * usRegCount ) ) )
        {
            /* Make callback to update the register values. */
            eRegStatus =
                eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_WRITE_MUL_VALUES_OFF],
1000178c:	3006      	adds	r0, #6
        if( ( usRegCount >= 1 ) &&
            ( usRegCount <= MB_PDU_FUNC_WRITE_MUL_REGCNT_MAX ) &&
            ( ucRegByteCount == ( UCHAR ) ( 2 * usRegCount ) ) )
        {
            /* Make callback to update the register values. */
            eRegStatus =
1000178e:	1c19      	adds	r1, r3, #0
10001790:	2301      	movs	r3, #1
10001792:	f001 f881 	bl	10002898 <eMBRegHoldingCB>
                eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_WRITE_MUL_VALUES_OFF],
                                 usRegAddress, usRegCount, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
10001796:	2800      	cmp	r0, #0
10001798:	d002      	beq.n	100017a0 <eMBFuncWriteMultipleHoldingRegister+0x44>
            {
                eStatus = prveMBError2Exception( eRegStatus );
1000179a:	f000 f90b 	bl	100019b4 <prveMBError2Exception>
1000179e:	e008      	b.n	100017b2 <eMBFuncWriteMultipleHoldingRegister+0x56>
            {
                /* The response contains the function code, the starting
                 * address and the quantity of registers. We reuse the
                 * old values in the buffer because they are still valid.
                 */
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
100017a0:	2305      	movs	r3, #5
100017a2:	8023      	strh	r3, [r4, #0]
{
    USHORT          usRegAddress;
    USHORT          usRegCount;
    UCHAR           ucRegByteCount;

    eMBException    eStatus = MB_EX_NONE;
100017a4:	2000      	movs	r0, #0
100017a6:	e004      	b.n	100017b2 <eMBFuncWriteMultipleHoldingRegister+0x56>
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
100017a8:	2003      	movs	r0, #3
100017aa:	e002      	b.n	100017b2 <eMBFuncWriteMultipleHoldingRegister+0x56>
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
100017ac:	2003      	movs	r0, #3
100017ae:	e000      	b.n	100017b2 <eMBFuncWriteMultipleHoldingRegister+0x56>
100017b0:	2003      	movs	r0, #3
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
100017b2:	bd38      	pop	{r3, r4, r5, pc}

100017b4 <eMBFuncReadHoldingRegister>:

#if MB_FUNC_READ_HOLDING_ENABLED > 0

eMBException
eMBFuncReadHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
100017b4:	b570      	push	{r4, r5, r6, lr}
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
100017b6:	880b      	ldrh	r3, [r1, #0]
100017b8:	2b05      	cmp	r3, #5
100017ba:	d12a      	bne.n	10001812 <eMBFuncReadHoldingRegister+0x5e>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
100017bc:	7843      	ldrb	r3, [r0, #1]
100017be:	021b      	lsls	r3, r3, #8
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
100017c0:	7882      	ldrb	r2, [r0, #2]
100017c2:	4313      	orrs	r3, r2
        usRegAddress++;
100017c4:	3301      	adds	r3, #1
100017c6:	b29a      	uxth	r2, r3

        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF] << 8 );
        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF + 1] );
100017c8:	7906      	ldrb	r6, [r0, #4]
100017ca:	b2b5      	uxth	r5, r6

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usRegCount >= 1 ) && ( usRegCount <= MB_PDU_FUNC_READ_REGCNT_MAX ) )
100017cc:	1e6b      	subs	r3, r5, #1
100017ce:	b29b      	uxth	r3, r3
100017d0:	2b7c      	cmp	r3, #124	; 0x7c
100017d2:	d820      	bhi.n	10001816 <eMBFuncReadHoldingRegister+0x62>
100017d4:	1c0c      	adds	r4, r1, #0
100017d6:	1c03      	adds	r3, r0, #0
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
100017d8:	2100      	movs	r1, #0
100017da:	8021      	strh	r1, [r4, #0]

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_HOLDING_REGISTER;
100017dc:	3103      	adds	r1, #3
100017de:	7001      	strb	r1, [r0, #0]
            *usLen += 1;
100017e0:	8821      	ldrh	r1, [r4, #0]
100017e2:	3101      	adds	r1, #1
100017e4:	8021      	strh	r1, [r4, #0]

            /* Second byte in the response contain the number of bytes. */
            *pucFrameCur++ = ( UCHAR ) ( usRegCount * 2 );
100017e6:	3002      	adds	r0, #2
100017e8:	0076      	lsls	r6, r6, #1
100017ea:	705e      	strb	r6, [r3, #1]
            *usLen += 1;
100017ec:	8823      	ldrh	r3, [r4, #0]
100017ee:	3301      	adds	r3, #1
100017f0:	8023      	strh	r3, [r4, #0]

            /* Make callback to fill the buffer. */
            eRegStatus = eMBRegHoldingCB( pucFrameCur, usRegAddress, usRegCount, MB_REG_READ );
100017f2:	1c11      	adds	r1, r2, #0
100017f4:	1c2a      	adds	r2, r5, #0
100017f6:	2300      	movs	r3, #0
100017f8:	f001 f84e 	bl	10002898 <eMBRegHoldingCB>
            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
100017fc:	2800      	cmp	r0, #0
100017fe:	d002      	beq.n	10001806 <eMBFuncReadHoldingRegister+0x52>
            {
                eStatus = prveMBError2Exception( eRegStatus );
10001800:	f000 f8d8 	bl	100019b4 <prveMBError2Exception>
10001804:	e008      	b.n	10001818 <eMBFuncReadHoldingRegister+0x64>
            }
            else
            {
                *usLen += usRegCount * 2;
10001806:	006d      	lsls	r5, r5, #1
10001808:	8823      	ldrh	r3, [r4, #0]
1000180a:	195d      	adds	r5, r3, r5
1000180c:	8025      	strh	r5, [r4, #0]
{
    USHORT          usRegAddress;
    USHORT          usRegCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
1000180e:	2000      	movs	r0, #0
10001810:	e002      	b.n	10001818 <eMBFuncReadHoldingRegister+0x64>
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
10001812:	2003      	movs	r0, #3
10001814:	e000      	b.n	10001818 <eMBFuncReadHoldingRegister+0x64>
                *usLen += usRegCount * 2;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
10001816:	2003      	movs	r0, #3
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
10001818:	bd70      	pop	{r4, r5, r6, pc}
1000181a:	46c0      	nop			; (mov r8, r8)

1000181c <eMBFuncReadWriteMultipleHoldingRegister>:

#if MB_FUNC_READWRITE_HOLDING_ENABLED > 0

eMBException
eMBFuncReadWriteMultipleHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
1000181c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_READWRITE_SIZE_MIN + MB_PDU_SIZE_MIN ) )
1000181e:	880b      	ldrh	r3, [r1, #0]
10001820:	2b09      	cmp	r3, #9
10001822:	d944      	bls.n	100018ae <eMBFuncReadWriteMultipleHoldingRegister+0x92>
    {
        usRegReadAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF] << 8U );
10001824:	7843      	ldrb	r3, [r0, #1]
10001826:	021b      	lsls	r3, r3, #8
        usRegReadAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF + 1] );
10001828:	7882      	ldrb	r2, [r0, #2]
1000182a:	4313      	orrs	r3, r2
        usRegReadAddress++;
1000182c:	3301      	adds	r3, #1
1000182e:	b29c      	uxth	r4, r3

        usRegReadCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF] << 8U );
10001830:	78c5      	ldrb	r5, [r0, #3]
10001832:	022d      	lsls	r5, r5, #8
        usRegReadCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF + 1] );
10001834:	7903      	ldrb	r3, [r0, #4]
10001836:	431d      	orrs	r5, r3

        usRegWriteAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF] << 8U );
10001838:	7943      	ldrb	r3, [r0, #5]
1000183a:	021b      	lsls	r3, r3, #8
        usRegWriteAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF + 1] );
1000183c:	7982      	ldrb	r2, [r0, #6]
1000183e:	4313      	orrs	r3, r2
        usRegWriteAddress++;
10001840:	3301      	adds	r3, #1
10001842:	b29b      	uxth	r3, r3

        usRegWriteCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF] << 8U );
10001844:	79c2      	ldrb	r2, [r0, #7]
10001846:	0212      	lsls	r2, r2, #8
        usRegWriteCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF + 1] );
10001848:	7a06      	ldrb	r6, [r0, #8]
1000184a:	4332      	orrs	r2, r6

        ucRegWriteByteCount = pucFrame[MB_PDU_FUNC_READWRITE_BYTECNT_OFF];
1000184c:	7a47      	ldrb	r7, [r0, #9]

        if( ( usRegReadCount >= 1 ) && ( usRegReadCount <= 0x7D ) &&
1000184e:	1e6e      	subs	r6, r5, #1
10001850:	b2b6      	uxth	r6, r6
10001852:	2e7c      	cmp	r6, #124	; 0x7c
10001854:	d82d      	bhi.n	100018b2 <eMBFuncReadWriteMultipleHoldingRegister+0x96>
10001856:	2a00      	cmp	r2, #0
10001858:	d02d      	beq.n	100018b6 <eMBFuncReadWriteMultipleHoldingRegister+0x9a>
            ( usRegWriteCount >= 1 ) && ( usRegWriteCount <= 0x79 ) &&
1000185a:	2a79      	cmp	r2, #121	; 0x79
1000185c:	d82d      	bhi.n	100018ba <eMBFuncReadWriteMultipleHoldingRegister+0x9e>
            ( ( 2 * usRegWriteCount ) == ucRegWriteByteCount ) )
1000185e:	0056      	lsls	r6, r2, #1
        usRegWriteCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF + 1] );

        ucRegWriteByteCount = pucFrame[MB_PDU_FUNC_READWRITE_BYTECNT_OFF];

        if( ( usRegReadCount >= 1 ) && ( usRegReadCount <= 0x7D ) &&
            ( usRegWriteCount >= 1 ) && ( usRegWriteCount <= 0x79 ) &&
10001860:	42be      	cmp	r6, r7
10001862:	d12c      	bne.n	100018be <eMBFuncReadWriteMultipleHoldingRegister+0xa2>
10001864:	1c0e      	adds	r6, r1, #0
10001866:	1c07      	adds	r7, r0, #0
            ( ( 2 * usRegWriteCount ) == ucRegWriteByteCount ) )
        {
            /* Make callback to update the register values. */
            eRegStatus = eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_READWRITE_WRITE_VALUES_OFF],
10001868:	300a      	adds	r0, #10
1000186a:	1c19      	adds	r1, r3, #0
1000186c:	2301      	movs	r3, #1
1000186e:	f001 f813 	bl	10002898 <eMBRegHoldingCB>
                                          usRegWriteAddress, usRegWriteCount, MB_REG_WRITE );

            if( eRegStatus == MB_ENOERR )
10001872:	2800      	cmp	r0, #0
10001874:	d116      	bne.n	100018a4 <eMBFuncReadWriteMultipleHoldingRegister+0x88>
            {
                /* Set the current PDU data pointer to the beginning. */
                pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
                *usLen = MB_PDU_FUNC_OFF;
10001876:	2300      	movs	r3, #0
10001878:	8033      	strh	r3, [r6, #0]

                /* First byte contains the function code. */
                *pucFrameCur++ = MB_FUNC_READWRITE_MULTIPLE_REGISTERS;
1000187a:	2217      	movs	r2, #23
1000187c:	703a      	strb	r2, [r7, #0]
                *usLen += 1;
1000187e:	8832      	ldrh	r2, [r6, #0]
10001880:	3201      	adds	r2, #1
10001882:	8032      	strh	r2, [r6, #0]

                /* Second byte in the response contain the number of bytes. */
                *pucFrameCur++ = ( UCHAR ) ( usRegReadCount * 2 );
10001884:	1cb8      	adds	r0, r7, #2
10001886:	006a      	lsls	r2, r5, #1
10001888:	707a      	strb	r2, [r7, #1]
                *usLen += 1;
1000188a:	8832      	ldrh	r2, [r6, #0]
1000188c:	3201      	adds	r2, #1
1000188e:	8032      	strh	r2, [r6, #0]

                /* Make the read callback. */
                eRegStatus =
10001890:	1c21      	adds	r1, r4, #0
10001892:	1c2a      	adds	r2, r5, #0
10001894:	f001 f800 	bl	10002898 <eMBRegHoldingCB>
                    eMBRegHoldingCB( pucFrameCur, usRegReadAddress, usRegReadCount, MB_REG_READ );
                if( eRegStatus == MB_ENOERR )
10001898:	2800      	cmp	r0, #0
1000189a:	d103      	bne.n	100018a4 <eMBFuncReadWriteMultipleHoldingRegister+0x88>
                {
                    *usLen += 2 * usRegReadCount;
1000189c:	006d      	lsls	r5, r5, #1
1000189e:	8833      	ldrh	r3, [r6, #0]
100018a0:	195d      	adds	r5, r3, r5
100018a2:	8035      	strh	r5, [r6, #0]
                }
            }
            if( eRegStatus != MB_ENOERR )
100018a4:	2800      	cmp	r0, #0
100018a6:	d00c      	beq.n	100018c2 <eMBFuncReadWriteMultipleHoldingRegister+0xa6>
            {
                eStatus = prveMBError2Exception( eRegStatus );
100018a8:	f000 f884 	bl	100019b4 <prveMBError2Exception>
100018ac:	e00a      	b.n	100018c4 <eMBFuncReadWriteMultipleHoldingRegister+0xa8>
    USHORT          usRegWriteAddress;
    USHORT          usRegWriteCount;
    UCHAR           ucRegWriteByteCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
100018ae:	2000      	movs	r0, #0
100018b0:	e008      	b.n	100018c4 <eMBFuncReadWriteMultipleHoldingRegister+0xa8>
                eStatus = prveMBError2Exception( eRegStatus );
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
100018b2:	2003      	movs	r0, #3
100018b4:	e006      	b.n	100018c4 <eMBFuncReadWriteMultipleHoldingRegister+0xa8>
100018b6:	2003      	movs	r0, #3
100018b8:	e004      	b.n	100018c4 <eMBFuncReadWriteMultipleHoldingRegister+0xa8>
100018ba:	2003      	movs	r0, #3
100018bc:	e002      	b.n	100018c4 <eMBFuncReadWriteMultipleHoldingRegister+0xa8>
100018be:	2003      	movs	r0, #3
100018c0:	e000      	b.n	100018c4 <eMBFuncReadWriteMultipleHoldingRegister+0xa8>
    USHORT          usRegWriteAddress;
    USHORT          usRegWriteCount;
    UCHAR           ucRegWriteByteCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
100018c2:	2000      	movs	r0, #0
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
        }
    }
    return eStatus;
}
100018c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
100018c6:	46c0      	nop			; (mov r8, r8)

100018c8 <eMBFuncReadInputRegister>:
/* ----------------------- Start implementation -----------------------------*/
#if MB_FUNC_READ_INPUT_ENABLED > 0

eMBException
eMBFuncReadInputRegister( UCHAR * pucFrame, USHORT * usLen )
{
100018c8:	b570      	push	{r4, r5, r6, lr}
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
100018ca:	880b      	ldrh	r3, [r1, #0]
100018cc:	2b05      	cmp	r3, #5
100018ce:	d12b      	bne.n	10001928 <eMBFuncReadInputRegister+0x60>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
100018d0:	7843      	ldrb	r3, [r0, #1]
100018d2:	021b      	lsls	r3, r3, #8
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
100018d4:	7882      	ldrb	r2, [r0, #2]
100018d6:	4313      	orrs	r3, r2
        usRegAddress++;
100018d8:	3301      	adds	r3, #1
100018da:	b29c      	uxth	r4, r3

        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF] << 8 );
100018dc:	78c5      	ldrb	r5, [r0, #3]
100018de:	022d      	lsls	r5, r5, #8
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF + 1] );
100018e0:	7903      	ldrb	r3, [r0, #4]
100018e2:	431d      	orrs	r5, r3

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usRegCount >= 1 )
            && ( usRegCount < MB_PDU_FUNC_READ_REGCNT_MAX ) )
100018e4:	1e6b      	subs	r3, r5, #1
100018e6:	b29b      	uxth	r3, r3
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF + 1] );

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usRegCount >= 1 )
100018e8:	2b7b      	cmp	r3, #123	; 0x7b
100018ea:	d81f      	bhi.n	1000192c <eMBFuncReadInputRegister+0x64>
100018ec:	1c0e      	adds	r6, r1, #0
100018ee:	1c03      	adds	r3, r0, #0
            && ( usRegCount < MB_PDU_FUNC_READ_REGCNT_MAX ) )
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
100018f0:	2200      	movs	r2, #0
100018f2:	800a      	strh	r2, [r1, #0]

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_INPUT_REGISTER;
100018f4:	3204      	adds	r2, #4
100018f6:	7002      	strb	r2, [r0, #0]
            *usLen += 1;
100018f8:	880a      	ldrh	r2, [r1, #0]
100018fa:	3201      	adds	r2, #1
100018fc:	800a      	strh	r2, [r1, #0]

            /* Second byte in the response contain the number of bytes. */
            *pucFrameCur++ = ( UCHAR )( usRegCount * 2 );
100018fe:	3002      	adds	r0, #2
10001900:	006a      	lsls	r2, r5, #1
10001902:	705a      	strb	r2, [r3, #1]
            *usLen += 1;
10001904:	880b      	ldrh	r3, [r1, #0]
10001906:	3301      	adds	r3, #1
10001908:	800b      	strh	r3, [r1, #0]

            eRegStatus =
1000190a:	1c21      	adds	r1, r4, #0
1000190c:	1c2a      	adds	r2, r5, #0
1000190e:	f000 ffaf 	bl	10002870 <eMBRegInputCB>
                eMBRegInputCB( pucFrameCur, usRegAddress, usRegCount );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
10001912:	2800      	cmp	r0, #0
10001914:	d002      	beq.n	1000191c <eMBFuncReadInputRegister+0x54>
            {
                eStatus = prveMBError2Exception( eRegStatus );
10001916:	f000 f84d 	bl	100019b4 <prveMBError2Exception>
1000191a:	e008      	b.n	1000192e <eMBFuncReadInputRegister+0x66>
            }
            else
            {
                *usLen += usRegCount * 2;
1000191c:	006d      	lsls	r5, r5, #1
1000191e:	8833      	ldrh	r3, [r6, #0]
10001920:	195d      	adds	r5, r3, r5
10001922:	8035      	strh	r5, [r6, #0]
{
    USHORT          usRegAddress;
    USHORT          usRegCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
10001924:	2000      	movs	r0, #0
10001926:	e002      	b.n	1000192e <eMBFuncReadInputRegister+0x66>
    }
    else
    {
        /* Can't be a valid read input register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
10001928:	2003      	movs	r0, #3
1000192a:	e000      	b.n	1000192e <eMBFuncReadInputRegister+0x66>
                *usLen += usRegCount * 2;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
1000192c:	2003      	movs	r0, #3
        /* Can't be a valid read input register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
1000192e:	bd70      	pop	{r4, r5, r6, pc}

10001930 <eMBFuncReportSlaveID>:
    return eStatus;
}

eMBException
eMBFuncReportSlaveID( UCHAR * pucFrame, USHORT * usLen )
{
10001930:	b538      	push	{r3, r4, r5, lr}
10001932:	1c0d      	adds	r5, r1, #0
    memcpy( &pucFrame[MB_PDU_DATA_OFF], &ucMBSlaveID[0], ( size_t )usMBSlaveIDLen );
10001934:	3001      	adds	r0, #1
10001936:	4b05      	ldr	r3, [pc, #20]	; (1000194c <eMBFuncReportSlaveID+0x1c>)
10001938:	881c      	ldrh	r4, [r3, #0]
1000193a:	4905      	ldr	r1, [pc, #20]	; (10001950 <eMBFuncReportSlaveID+0x20>)
1000193c:	1c22      	adds	r2, r4, #0
1000193e:	f001 fa1d 	bl	10002d7c <memcpy>
    *usLen = ( USHORT )( MB_PDU_DATA_OFF + usMBSlaveIDLen );
10001942:	3401      	adds	r4, #1
10001944:	802c      	strh	r4, [r5, #0]
    return MB_EX_NONE;
}
10001946:	2000      	movs	r0, #0
10001948:	bd38      	pop	{r3, r4, r5, pc}
1000194a:	46c0      	nop			; (mov r8, r8)
1000194c:	200005be 	.word	0x200005be
10001950:	200005c0 	.word	0x200005c0

10001954 <xMBUtilSetBits>:

/* ----------------------- Start implementation -----------------------------*/
void
xMBUtilSetBits( UCHAR * ucByteBuf, USHORT usBitOffset, UCHAR ucNBits,
                UCHAR ucValue )
{
10001954:	b5f0      	push	{r4, r5, r6, r7, lr}
    assert( ucNBits <= 8 );
    assert( ( size_t )BITS_UCHAR == sizeof( UCHAR ) * 8 );

    /* Calculate byte offset for first byte containing the bit values starting
     * at usBitOffset. */
    usByteOffset = ( USHORT )( ( usBitOffset ) / BITS_UCHAR );
10001956:	08cd      	lsrs	r5, r1, #3

    /* How many bits precede our bits to set. */
    usNPreBits = ( USHORT )( usBitOffset - usByteOffset * BITS_UCHAR );
10001958:	00ef      	lsls	r7, r5, #3
1000195a:	1bce      	subs	r6, r1, r7
1000195c:	b2b6      	uxth	r6, r6

    /* Move bit field into position over bits to set */
    usValue <<= usNPreBits;
1000195e:	40b3      	lsls	r3, r6
10001960:	1c1e      	adds	r6, r3, #0

    /* Prepare a mask for setting the new bits. */
    usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
10001962:	2401      	movs	r4, #1
10001964:	4094      	lsls	r4, r2
10001966:	1c22      	adds	r2, r4, #0
10001968:	3a01      	subs	r2, #1
1000196a:	b292      	uxth	r2, r2
    usMask <<= usBitOffset - usByteOffset * BITS_UCHAR;
1000196c:	1bc9      	subs	r1, r1, r7
1000196e:	408a      	lsls	r2, r1
10001970:	1c11      	adds	r1, r2, #0

    /* copy bits into temporary storage. */
    usWordBuf = ucByteBuf[usByteOffset];
10001972:	1944      	adds	r4, r0, r5
10001974:	7822      	ldrb	r2, [r4, #0]
    usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;
10001976:	3501      	adds	r5, #1
10001978:	1940      	adds	r0, r0, r5
1000197a:	7803      	ldrb	r3, [r0, #0]
1000197c:	021b      	lsls	r3, r3, #8
1000197e:	4313      	orrs	r3, r2

    /* Zero out bit field bits and then or value bits into them. */
    usWordBuf = ( USHORT )( ( usWordBuf & ( ~usMask ) ) | usValue );
10001980:	438b      	bics	r3, r1
10001982:	4333      	orrs	r3, r6
10001984:	b29b      	uxth	r3, r3

    /* move bits back into storage */
    ucByteBuf[usByteOffset] = ( UCHAR )( usWordBuf & 0xFF );
10001986:	7023      	strb	r3, [r4, #0]
    ucByteBuf[usByteOffset + 1] = ( UCHAR )( usWordBuf >> BITS_UCHAR );
10001988:	0a1b      	lsrs	r3, r3, #8
1000198a:	7003      	strb	r3, [r0, #0]
}
1000198c:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000198e:	46c0      	nop			; (mov r8, r8)

10001990 <xMBUtilGetBits>:

UCHAR
xMBUtilGetBits( UCHAR * ucByteBuf, USHORT usBitOffset, UCHAR ucNBits )
{
10001990:	b510      	push	{r4, lr}
    USHORT          usByteOffset;
    USHORT          usNPreBits;

    /* Calculate byte offset for first byte containing the bit values starting
     * at usBitOffset. */
    usByteOffset = ( USHORT )( ( usBitOffset ) / BITS_UCHAR );
10001992:	08cc      	lsrs	r4, r1, #3

    /* How many bits precede our bits to set. */
    usNPreBits = ( USHORT )( usBitOffset - usByteOffset * BITS_UCHAR );
10001994:	00e3      	lsls	r3, r4, #3
10001996:	1ac9      	subs	r1, r1, r3
10001998:	b289      	uxth	r1, r1

    /* Prepare a mask for setting the new bits. */
    usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
1000199a:	2301      	movs	r3, #1
1000199c:	4093      	lsls	r3, r2
1000199e:	1c1a      	adds	r2, r3, #0
100019a0:	3a01      	subs	r2, #1

    /* copy bits into temporary storage. */
    usWordBuf = ucByteBuf[usByteOffset];
100019a2:	5d03      	ldrb	r3, [r0, r4]
    usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;
100019a4:	1904      	adds	r4, r0, r4
100019a6:	7860      	ldrb	r0, [r4, #1]
100019a8:	0200      	lsls	r0, r0, #8
100019aa:	4318      	orrs	r0, r3

    /* throw away unneeded bits. */
    usWordBuf >>= usNPreBits;
100019ac:	4108      	asrs	r0, r1

    /* mask away bits above the requested bitfield. */
    usWordBuf &= usMask;
100019ae:	4010      	ands	r0, r2

    return ( UCHAR ) usWordBuf;
100019b0:	b2c0      	uxtb	r0, r0
}
100019b2:	bd10      	pop	{r4, pc}

100019b4 <prveMBError2Exception>:
eMBException
prveMBError2Exception( eMBErrorCode eErrorCode )
{
    eMBException    eStatus;

    switch ( eErrorCode )
100019b4:	2801      	cmp	r0, #1
100019b6:	d00a      	beq.n	100019ce <prveMBError2Exception+0x1a>
100019b8:	2800      	cmp	r0, #0
100019ba:	d002      	beq.n	100019c2 <prveMBError2Exception+0xe>
100019bc:	2807      	cmp	r0, #7
100019be:	d002      	beq.n	100019c6 <prveMBError2Exception+0x12>
100019c0:	e003      	b.n	100019ca <prveMBError2Exception+0x16>
    {
        case MB_ENOERR:
            eStatus = MB_EX_NONE;
100019c2:	2000      	movs	r0, #0
100019c4:	e004      	b.n	100019d0 <prveMBError2Exception+0x1c>
        case MB_ENOREG:
            eStatus = MB_EX_ILLEGAL_DATA_ADDRESS;
            break;

        case MB_ETIMEDOUT:
            eStatus = MB_EX_SLAVE_BUSY;
100019c6:	2006      	movs	r0, #6
            break;
100019c8:	e002      	b.n	100019d0 <prveMBError2Exception+0x1c>

        default:
            eStatus = MB_EX_SLAVE_DEVICE_FAILURE;
100019ca:	2004      	movs	r0, #4
            break;
100019cc:	e000      	b.n	100019d0 <prveMBError2Exception+0x1c>
        case MB_ENOERR:
            eStatus = MB_EX_NONE;
            break;

        case MB_ENOREG:
            eStatus = MB_EX_ILLEGAL_DATA_ADDRESS;
100019ce:	2002      	movs	r0, #2
            eStatus = MB_EX_SLAVE_DEVICE_FAILURE;
            break;
    }

    return eStatus;
}
100019d0:	4770      	bx	lr
100019d2:	46c0      	nop			; (mov r8, r8)

100019d4 <prvucMBCHAR2BIN>:
}


static          UCHAR
prvucMBCHAR2BIN( UCHAR ucCharacter )
{
100019d4:	1c02      	adds	r2, r0, #0
    if( ( ucCharacter >= '0' ) && ( ucCharacter <= '9' ) )
100019d6:	1c03      	adds	r3, r0, #0
100019d8:	3b30      	subs	r3, #48	; 0x30
100019da:	b2d8      	uxtb	r0, r3
100019dc:	2809      	cmp	r0, #9
100019de:	d906      	bls.n	100019ee <prvucMBCHAR2BIN+0x1a>
    {
        return ( UCHAR )( ucCharacter - '0' );
    }
    else if( ( ucCharacter >= 'A' ) && ( ucCharacter <= 'F' ) )
100019e0:	3b11      	subs	r3, #17
100019e2:	2b05      	cmp	r3, #5
100019e4:	d802      	bhi.n	100019ec <prvucMBCHAR2BIN+0x18>
    {
        return ( UCHAR )( ucCharacter - 'A' + 0x0A );
100019e6:	3a37      	subs	r2, #55	; 0x37
100019e8:	b2d0      	uxtb	r0, r2
100019ea:	e000      	b.n	100019ee <prvucMBCHAR2BIN+0x1a>
    }
    else
    {
        return 0xFF;
100019ec:	20ff      	movs	r0, #255	; 0xff
    }
}
100019ee:	4770      	bx	lr

100019f0 <prvucMBBIN2CHAR>:

static          UCHAR
prvucMBBIN2CHAR( UCHAR ucByte )
{
    if( ucByte <= 0x09 )
100019f0:	2809      	cmp	r0, #9
100019f2:	d802      	bhi.n	100019fa <prvucMBBIN2CHAR+0xa>
    {
        return ( UCHAR )( '0' + ucByte );
100019f4:	3030      	adds	r0, #48	; 0x30
100019f6:	b2c0      	uxtb	r0, r0
100019f8:	e007      	b.n	10001a0a <prvucMBBIN2CHAR+0x1a>
    }
    else if( ( ucByte >= 0x0A ) && ( ucByte <= 0x0F ) )
100019fa:	1c03      	adds	r3, r0, #0
100019fc:	3b0a      	subs	r3, #10
100019fe:	2b05      	cmp	r3, #5
10001a00:	d802      	bhi.n	10001a08 <prvucMBBIN2CHAR+0x18>
    {
        return ( UCHAR )( ucByte - 0x0A + 'A' );
10001a02:	3037      	adds	r0, #55	; 0x37
10001a04:	b2c0      	uxtb	r0, r0
10001a06:	e000      	b.n	10001a0a <prvucMBBIN2CHAR+0x1a>
    else
    {
        /* Programming error. */
        assert( 0 );
    }
    return '0';
10001a08:	2030      	movs	r0, #48	; 0x30
}
10001a0a:	4770      	bx	lr

10001a0c <prvucMBLRC>:


static          UCHAR
prvucMBLRC( UCHAR * pucFrame, USHORT usLen )
{
    UCHAR           ucLRC = 0;  /* LRC char initialized */
10001a0c:	2300      	movs	r3, #0

    while( usLen-- )
10001a0e:	e004      	b.n	10001a1a <prvucMBLRC+0xe>
    {
        ucLRC += *pucFrame++;   /* Add buffer byte without carry */
10001a10:	7801      	ldrb	r1, [r0, #0]
10001a12:	18cb      	adds	r3, r1, r3
10001a14:	b2db      	uxtb	r3, r3
static          UCHAR
prvucMBLRC( UCHAR * pucFrame, USHORT usLen )
{
    UCHAR           ucLRC = 0;  /* LRC char initialized */

    while( usLen-- )
10001a16:	1c11      	adds	r1, r2, #0
    {
        ucLRC += *pucFrame++;   /* Add buffer byte without carry */
10001a18:	3001      	adds	r0, #1
static          UCHAR
prvucMBLRC( UCHAR * pucFrame, USHORT usLen )
{
    UCHAR           ucLRC = 0;  /* LRC char initialized */

    while( usLen-- )
10001a1a:	1e4a      	subs	r2, r1, #1
10001a1c:	b292      	uxth	r2, r2
10001a1e:	2900      	cmp	r1, #0
10001a20:	d1f6      	bne.n	10001a10 <prvucMBLRC+0x4>
    {
        ucLRC += *pucFrame++;   /* Add buffer byte without carry */
    }

    /* Return twos complement */
    ucLRC = ( UCHAR ) ( -( ( CHAR ) ucLRC ) );
10001a22:	4258      	negs	r0, r3
10001a24:	b2c0      	uxtb	r0, r0
    return ucLRC;
}
10001a26:	4770      	bx	lr

10001a28 <eMBASCIIInit>:
static volatile UCHAR ucMBLFCharacter;

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBASCIIInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
10001a28:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001a2a:	b672      	cpsid	i
    eMBErrorCode    eStatus = MB_ENOERR;
    ( void )ucSlaveAddress;
    
    ENTER_CRITICAL_SECTION(  );
    ucMBLFCharacter = MB_ASCII_DEFAULT_LF;
10001a2c:	240a      	movs	r4, #10
10001a2e:	480a      	ldr	r0, [pc, #40]	; (10001a58 <eMBASCIIInit+0x30>)
10001a30:	7004      	strb	r4, [r0, #0]

    if( xMBPortSerialInit( ucPort, ulBaudRate, 7, eParity ) != TRUE )
10001a32:	1c08      	adds	r0, r1, #0
10001a34:	1c11      	adds	r1, r2, #0
10001a36:	2207      	movs	r2, #7
10001a38:	f7ff fb84 	bl	10001144 <xMBPortSerialInit>
10001a3c:	2801      	cmp	r0, #1
10001a3e:	d106      	bne.n	10001a4e <eMBASCIIInit+0x26>
    {
        eStatus = MB_EPORTERR;
    }
    else if( xMBPortTimersInit( MB_ASCII_TIMEOUT_SEC * 20000UL ) != TRUE )
10001a40:	4806      	ldr	r0, [pc, #24]	; (10001a5c <eMBASCIIInit+0x34>)
10001a42:	f7ff fc15 	bl	10001270 <xMBPortTimersInit>
10001a46:	2801      	cmp	r0, #1
10001a48:	d103      	bne.n	10001a52 <eMBASCIIInit+0x2a>

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBASCIIInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
    eMBErrorCode    eStatus = MB_ENOERR;
10001a4a:	2000      	movs	r0, #0
10001a4c:	e002      	b.n	10001a54 <eMBASCIIInit+0x2c>
    ENTER_CRITICAL_SECTION(  );
    ucMBLFCharacter = MB_ASCII_DEFAULT_LF;

    if( xMBPortSerialInit( ucPort, ulBaudRate, 7, eParity ) != TRUE )
    {
        eStatus = MB_EPORTERR;
10001a4e:	2003      	movs	r0, #3
10001a50:	e000      	b.n	10001a54 <eMBASCIIInit+0x2c>
    }
    else if( xMBPortTimersInit( MB_ASCII_TIMEOUT_SEC * 20000UL ) != TRUE )
    {
        eStatus = MB_EPORTERR;
10001a52:	2003      	movs	r0, #3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
10001a54:	b662      	cpsie	i
    }

    EXIT_CRITICAL_SECTION(  );

    return eStatus;
}
10001a56:	bd10      	pop	{r4, pc}
10001a58:	200005e4 	.word	0x200005e4
10001a5c:	00004e20 	.word	0x00004e20

10001a60 <eMBASCIIStart>:

void
eMBASCIIStart( void )
{
10001a60:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001a62:	b672      	cpsid	i
    ENTER_CRITICAL_SECTION(  );
    vMBPortSerialEnable( TRUE, FALSE );
10001a64:	2001      	movs	r0, #1
10001a66:	2100      	movs	r1, #0
10001a68:	f7ff fb44 	bl	100010f4 <vMBPortSerialEnable>
    eRcvState = STATE_RX_IDLE;
10001a6c:	2200      	movs	r2, #0
10001a6e:	4b03      	ldr	r3, [pc, #12]	; (10001a7c <eMBASCIIStart+0x1c>)
10001a70:	701a      	strb	r2, [r3, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
10001a72:	b662      	cpsie	i
    EXIT_CRITICAL_SECTION(  );

    /* No special startup required for ASCII. */
    ( void )xMBPortEventPost( EV_READY );
10001a74:	2000      	movs	r0, #0
10001a76:	f7ff fb19 	bl	100010ac <xMBPortEventPost>
}
10001a7a:	bd08      	pop	{r3, pc}
10001a7c:	200005eb 	.word	0x200005eb

10001a80 <eMBASCIIStop>:

void
eMBASCIIStop( void )
{
10001a80:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001a82:	b672      	cpsid	i
    ENTER_CRITICAL_SECTION(  );
    vMBPortSerialEnable( FALSE, FALSE );
10001a84:	2000      	movs	r0, #0
10001a86:	2100      	movs	r1, #0
10001a88:	f7ff fb34 	bl	100010f4 <vMBPortSerialEnable>
    vMBPortTimersDisable(  );
10001a8c:	f7ff fc04 	bl	10001298 <vMBPortTimersDisable>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
10001a90:	b662      	cpsie	i
    EXIT_CRITICAL_SECTION(  );
}
10001a92:	bd08      	pop	{r3, pc}

10001a94 <eMBASCIIReceive>:

eMBErrorCode
eMBASCIIReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
{
10001a94:	b570      	push	{r4, r5, r6, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001a96:	b672      	cpsid	i

    ENTER_CRITICAL_SECTION(  );
    assert( usRcvBufferPos < MB_SER_PDU_SIZE_MAX );

    /* Length and CRC check */
    if( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
10001a98:	4b0f      	ldr	r3, [pc, #60]	; (10001ad8 <eMBASCIIReceive+0x44>)
10001a9a:	881b      	ldrh	r3, [r3, #0]
10001a9c:	b29b      	uxth	r3, r3
10001a9e:	2b02      	cmp	r3, #2
10001aa0:	d914      	bls.n	10001acc <eMBASCIIReceive+0x38>
10001aa2:	1c15      	adds	r5, r2, #0
10001aa4:	1c0c      	adds	r4, r1, #0
10001aa6:	1c06      	adds	r6, r0, #0
        && ( prvucMBLRC( ( UCHAR * ) ucASCIIBuf, usRcvBufferPos ) == 0 ) )
10001aa8:	4b0b      	ldr	r3, [pc, #44]	; (10001ad8 <eMBASCIIReceive+0x44>)
10001aaa:	8819      	ldrh	r1, [r3, #0]
10001aac:	b289      	uxth	r1, r1
10001aae:	480b      	ldr	r0, [pc, #44]	; (10001adc <eMBASCIIReceive+0x48>)
10001ab0:	f7ff ffac 	bl	10001a0c <prvucMBLRC>
10001ab4:	2800      	cmp	r0, #0
10001ab6:	d10b      	bne.n	10001ad0 <eMBASCIIReceive+0x3c>
    {
        /* Save the address field. All frames are passed to the upper layed
         * and the decision if a frame is used is done there.
         */
        *pucRcvAddress = ucASCIIBuf[MB_SER_PDU_ADDR_OFF];
10001ab8:	4b08      	ldr	r3, [pc, #32]	; (10001adc <eMBASCIIReceive+0x48>)
10001aba:	781a      	ldrb	r2, [r3, #0]
10001abc:	7032      	strb	r2, [r6, #0]

        /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
         * size of address field and CRC checksum.
         */
        *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_LRC );
10001abe:	4a06      	ldr	r2, [pc, #24]	; (10001ad8 <eMBASCIIReceive+0x44>)
10001ac0:	8812      	ldrh	r2, [r2, #0]
10001ac2:	3a02      	subs	r2, #2
10001ac4:	802a      	strh	r2, [r5, #0]

        /* Return the start of the Modbus PDU to the caller. */
        *pucFrame = ( UCHAR * ) & ucASCIIBuf[MB_SER_PDU_PDU_OFF];
10001ac6:	3301      	adds	r3, #1
10001ac8:	6023      	str	r3, [r4, #0]
10001aca:	e002      	b.n	10001ad2 <eMBASCIIReceive+0x3e>
    }
    else
    {
        eStatus = MB_EIO;
10001acc:	2005      	movs	r0, #5
10001ace:	e000      	b.n	10001ad2 <eMBASCIIReceive+0x3e>
10001ad0:	2005      	movs	r0, #5
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
10001ad2:	b662      	cpsie	i
    }
    EXIT_CRITICAL_SECTION(  );
    return eStatus;
}
10001ad4:	bd70      	pop	{r4, r5, r6, pc}
10001ad6:	46c0      	nop			; (mov r8, r8)
10001ad8:	200005e8 	.word	0x200005e8
10001adc:	20000638 	.word	0x20000638

10001ae0 <eMBASCIISend>:

eMBErrorCode
eMBASCIISend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
10001ae0:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001ae2:	b672      	cpsid	i
    ENTER_CRITICAL_SECTION(  );
    /* Check if the receiver is still in idle state. If not we where too
     * slow with processing the received frame and the master sent another
     * frame on the network. We have to abort sending the frame.
     */
    if( eRcvState == STATE_RX_IDLE )
10001ae4:	4b13      	ldr	r3, [pc, #76]	; (10001b34 <eMBASCIISend+0x54>)
10001ae6:	781b      	ldrb	r3, [r3, #0]
10001ae8:	2b00      	cmp	r3, #0
10001aea:	d120      	bne.n	10001b2e <eMBASCIISend+0x4e>
    {
        /* First byte before the Modbus-PDU is the slave address. */
        pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
10001aec:	1e4b      	subs	r3, r1, #1
10001aee:	4912      	ldr	r1, [pc, #72]	; (10001b38 <eMBASCIISend+0x58>)
10001af0:	600b      	str	r3, [r1, #0]
        usSndBufferCount = 1;
10001af2:	4c12      	ldr	r4, [pc, #72]	; (10001b3c <eMBASCIISend+0x5c>)
10001af4:	2101      	movs	r1, #1
10001af6:	8021      	strh	r1, [r4, #0]

        /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
        pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
10001af8:	7018      	strb	r0, [r3, #0]
        usSndBufferCount += usLength;
10001afa:	8821      	ldrh	r1, [r4, #0]
10001afc:	188a      	adds	r2, r1, r2
10001afe:	b292      	uxth	r2, r2
10001b00:	8022      	strh	r2, [r4, #0]

        /* Calculate LRC checksum for Modbus-Serial-Line-PDU. */
        usLRC = prvucMBLRC( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
10001b02:	8821      	ldrh	r1, [r4, #0]
10001b04:	b289      	uxth	r1, r1
10001b06:	1c18      	adds	r0, r3, #0
10001b08:	f7ff ff80 	bl	10001a0c <prvucMBLRC>
        ucASCIIBuf[usSndBufferCount++] = usLRC;
10001b0c:	8823      	ldrh	r3, [r4, #0]
10001b0e:	b29b      	uxth	r3, r3
10001b10:	1c5a      	adds	r2, r3, #1
10001b12:	b292      	uxth	r2, r2
10001b14:	8022      	strh	r2, [r4, #0]
10001b16:	4a0a      	ldr	r2, [pc, #40]	; (10001b40 <eMBASCIISend+0x60>)
10001b18:	189b      	adds	r3, r3, r2
10001b1a:	7018      	strb	r0, [r3, #0]

        /* Activate the transmitter. */
        eSndState = STATE_TX_START;
10001b1c:	4b09      	ldr	r3, [pc, #36]	; (10001b44 <eMBASCIISend+0x64>)
10001b1e:	2201      	movs	r2, #1
10001b20:	701a      	strb	r2, [r3, #0]
        vMBPortSerialEnable( FALSE, TRUE );
10001b22:	2000      	movs	r0, #0
10001b24:	2101      	movs	r1, #1
10001b26:	f7ff fae5 	bl	100010f4 <vMBPortSerialEnable>
}

eMBErrorCode
eMBASCIISend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;
10001b2a:	2000      	movs	r0, #0
10001b2c:	e000      	b.n	10001b30 <eMBASCIISend+0x50>
        eSndState = STATE_TX_START;
        vMBPortSerialEnable( FALSE, TRUE );
    }
    else
    {
        eStatus = MB_EIO;
10001b2e:	2005      	movs	r0, #5
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
10001b30:	b662      	cpsie	i
    }
    EXIT_CRITICAL_SECTION(  );
    return eStatus;
}
10001b32:	bd10      	pop	{r4, pc}
10001b34:	200005eb 	.word	0x200005eb
10001b38:	200005e0 	.word	0x200005e0
10001b3c:	200005e6 	.word	0x200005e6
10001b40:	20000638 	.word	0x20000638
10001b44:	200005ea 	.word	0x200005ea

10001b48 <xMBASCIIReceiveFSM>:

BOOL
xMBASCIIReceiveFSM( void )
{
10001b48:	b500      	push	{lr}
10001b4a:	b083      	sub	sp, #12
    UCHAR           ucByte;
    UCHAR           ucResult;

    assert( eSndState == STATE_TX_IDLE );

    ( void )xMBPortSerialGetByte( ( CHAR * ) & ucByte );
10001b4c:	466b      	mov	r3, sp
10001b4e:	1dd8      	adds	r0, r3, #7
10001b50:	f7ff fb62 	bl	10001218 <xMBPortSerialGetByte>
    switch ( eRcvState )
10001b54:	4b45      	ldr	r3, [pc, #276]	; (10001c6c <xMBASCIIReceiveFSM+0x124>)
10001b56:	781b      	ldrb	r3, [r3, #0]
10001b58:	b2db      	uxtb	r3, r3
10001b5a:	2b01      	cmp	r3, #1
10001b5c:	d004      	beq.n	10001b68 <xMBASCIIReceiveFSM+0x20>
10001b5e:	2b00      	cmp	r3, #0
10001b60:	d06c      	beq.n	10001c3c <xMBASCIIReceiveFSM+0xf4>
10001b62:	2b02      	cmp	r3, #2
10001b64:	d047      	beq.n	10001bf6 <xMBASCIIReceiveFSM+0xae>
10001b66:	e07a      	b.n	10001c5e <xMBASCIIReceiveFSM+0x116>
         * block. Other characters are part of the data block and their
         * ASCII value is converted back to a binary representation.
         */
    case STATE_RX_RCV:
        /* Enable timer for character timeout. */
        vMBPortTimersEnable(  );
10001b68:	f7ff fb84 	bl	10001274 <vMBPortTimersEnable>
        if( ucByte == ':' )
10001b6c:	466b      	mov	r3, sp
10001b6e:	79d8      	ldrb	r0, [r3, #7]
10001b70:	283a      	cmp	r0, #58	; 0x3a
10001b72:	d106      	bne.n	10001b82 <xMBASCIIReceiveFSM+0x3a>
        {
            /* Empty receive buffer. */
            eBytePos = BYTE_HIGH_NIBBLE;
10001b74:	2300      	movs	r3, #0
10001b76:	4a3e      	ldr	r2, [pc, #248]	; (10001c70 <xMBASCIIReceiveFSM+0x128>)
10001b78:	7013      	strb	r3, [r2, #0]
            usRcvBufferPos = 0;
10001b7a:	4a3e      	ldr	r2, [pc, #248]	; (10001c74 <xMBASCIIReceiveFSM+0x12c>)
10001b7c:	8013      	strh	r3, [r2, #0]
}

BOOL
xMBASCIIReceiveFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001b7e:	2000      	movs	r0, #0
10001b80:	e072      	b.n	10001c68 <xMBASCIIReceiveFSM+0x120>
        {
            /* Empty receive buffer. */
            eBytePos = BYTE_HIGH_NIBBLE;
            usRcvBufferPos = 0;
        }
        else if( ucByte == MB_ASCII_DEFAULT_CR )
10001b82:	280d      	cmp	r0, #13
10001b84:	d104      	bne.n	10001b90 <xMBASCIIReceiveFSM+0x48>
        {
            eRcvState = STATE_RX_WAIT_EOF;
10001b86:	2202      	movs	r2, #2
10001b88:	4b38      	ldr	r3, [pc, #224]	; (10001c6c <xMBASCIIReceiveFSM+0x124>)
10001b8a:	701a      	strb	r2, [r3, #0]
}

BOOL
xMBASCIIReceiveFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001b8c:	2000      	movs	r0, #0
10001b8e:	e06b      	b.n	10001c68 <xMBASCIIReceiveFSM+0x120>
        {
            eRcvState = STATE_RX_WAIT_EOF;
        }
        else
        {
            ucResult = prvucMBCHAR2BIN( ucByte );
10001b90:	f7ff ff20 	bl	100019d4 <prvucMBCHAR2BIN>
            switch ( eBytePos )
10001b94:	4b36      	ldr	r3, [pc, #216]	; (10001c70 <xMBASCIIReceiveFSM+0x128>)
10001b96:	781b      	ldrb	r3, [r3, #0]
10001b98:	b2db      	uxtb	r3, r3
10001b9a:	2b00      	cmp	r3, #0
10001b9c:	d002      	beq.n	10001ba4 <xMBASCIIReceiveFSM+0x5c>
10001b9e:	2b01      	cmp	r3, #1
10001ba0:	d018      	beq.n	10001bd4 <xMBASCIIReceiveFSM+0x8c>
10001ba2:	e05e      	b.n	10001c62 <xMBASCIIReceiveFSM+0x11a>
            {
                /* High nibble of the byte comes first. We check for
                 * a buffer overflow here. */
            case BYTE_HIGH_NIBBLE:
                if( usRcvBufferPos < MB_SER_PDU_SIZE_MAX )
10001ba4:	4b33      	ldr	r3, [pc, #204]	; (10001c74 <xMBASCIIReceiveFSM+0x12c>)
10001ba6:	881b      	ldrh	r3, [r3, #0]
10001ba8:	b29b      	uxth	r3, r3
10001baa:	2bff      	cmp	r3, #255	; 0xff
10001bac:	d80b      	bhi.n	10001bc6 <xMBASCIIReceiveFSM+0x7e>
                {
                    ucASCIIBuf[usRcvBufferPos] = ( UCHAR )( ucResult << 4 );
10001bae:	4b31      	ldr	r3, [pc, #196]	; (10001c74 <xMBASCIIReceiveFSM+0x12c>)
10001bb0:	881b      	ldrh	r3, [r3, #0]
10001bb2:	4a31      	ldr	r2, [pc, #196]	; (10001c78 <xMBASCIIReceiveFSM+0x130>)
10001bb4:	18d3      	adds	r3, r2, r3
10001bb6:	0100      	lsls	r0, r0, #4
10001bb8:	b2c0      	uxtb	r0, r0
10001bba:	7018      	strb	r0, [r3, #0]
                    eBytePos = BYTE_LOW_NIBBLE;
10001bbc:	2201      	movs	r2, #1
10001bbe:	4b2c      	ldr	r3, [pc, #176]	; (10001c70 <xMBASCIIReceiveFSM+0x128>)
10001bc0:	701a      	strb	r2, [r3, #0]
}

BOOL
xMBASCIIReceiveFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001bc2:	2000      	movs	r0, #0
            case BYTE_HIGH_NIBBLE:
                if( usRcvBufferPos < MB_SER_PDU_SIZE_MAX )
                {
                    ucASCIIBuf[usRcvBufferPos] = ( UCHAR )( ucResult << 4 );
                    eBytePos = BYTE_LOW_NIBBLE;
                    break;
10001bc4:	e050      	b.n	10001c68 <xMBASCIIReceiveFSM+0x120>
                }
                else
                {
                    /* not handled in Modbus specification but seems
                     * a resonable implementation. */
                    eRcvState = STATE_RX_IDLE;
10001bc6:	2200      	movs	r2, #0
10001bc8:	4b28      	ldr	r3, [pc, #160]	; (10001c6c <xMBASCIIReceiveFSM+0x124>)
10001bca:	701a      	strb	r2, [r3, #0]
                    /* Disable previously activated timer because of error state. */
                    vMBPortTimersDisable(  );
10001bcc:	f7ff fb64 	bl	10001298 <vMBPortTimersDisable>
}

BOOL
xMBASCIIReceiveFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001bd0:	2000      	movs	r0, #0
                     * a resonable implementation. */
                    eRcvState = STATE_RX_IDLE;
                    /* Disable previously activated timer because of error state. */
                    vMBPortTimersDisable(  );
                }
                break;
10001bd2:	e049      	b.n	10001c68 <xMBASCIIReceiveFSM+0x120>

            case BYTE_LOW_NIBBLE:
                ucASCIIBuf[usRcvBufferPos] |= ucResult;
10001bd4:	4a27      	ldr	r2, [pc, #156]	; (10001c74 <xMBASCIIReceiveFSM+0x12c>)
10001bd6:	8813      	ldrh	r3, [r2, #0]
10001bd8:	4927      	ldr	r1, [pc, #156]	; (10001c78 <xMBASCIIReceiveFSM+0x130>)
10001bda:	18cb      	adds	r3, r1, r3
10001bdc:	7819      	ldrb	r1, [r3, #0]
10001bde:	4308      	orrs	r0, r1
10001be0:	b2c0      	uxtb	r0, r0
10001be2:	7018      	strb	r0, [r3, #0]
                usRcvBufferPos++;
10001be4:	8813      	ldrh	r3, [r2, #0]
10001be6:	3301      	adds	r3, #1
10001be8:	b29b      	uxth	r3, r3
10001bea:	8013      	strh	r3, [r2, #0]
                eBytePos = BYTE_HIGH_NIBBLE;
10001bec:	2200      	movs	r2, #0
10001bee:	4b20      	ldr	r3, [pc, #128]	; (10001c70 <xMBASCIIReceiveFSM+0x128>)
10001bf0:	701a      	strb	r2, [r3, #0]
}

BOOL
xMBASCIIReceiveFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001bf2:	2000      	movs	r0, #0

            case BYTE_LOW_NIBBLE:
                ucASCIIBuf[usRcvBufferPos] |= ucResult;
                usRcvBufferPos++;
                eBytePos = BYTE_HIGH_NIBBLE;
                break;
10001bf4:	e038      	b.n	10001c68 <xMBASCIIReceiveFSM+0x120>
            }
        }
        break;

    case STATE_RX_WAIT_EOF:
        if( ucByte == ucMBLFCharacter )
10001bf6:	466b      	mov	r3, sp
10001bf8:	79da      	ldrb	r2, [r3, #7]
10001bfa:	4b20      	ldr	r3, [pc, #128]	; (10001c7c <xMBASCIIReceiveFSM+0x134>)
10001bfc:	781b      	ldrb	r3, [r3, #0]
10001bfe:	b2db      	uxtb	r3, r3
10001c00:	429a      	cmp	r2, r3
10001c02:	d108      	bne.n	10001c16 <xMBASCIIReceiveFSM+0xce>
        {
            /* Disable character timeout timer because all characters are
             * received. */
            vMBPortTimersDisable(  );
10001c04:	f7ff fb48 	bl	10001298 <vMBPortTimersDisable>
            /* Receiver is again in idle state. */
            eRcvState = STATE_RX_IDLE;
10001c08:	2200      	movs	r2, #0
10001c0a:	4b18      	ldr	r3, [pc, #96]	; (10001c6c <xMBASCIIReceiveFSM+0x124>)
10001c0c:	701a      	strb	r2, [r3, #0]

            /* Notify the caller of eMBASCIIReceive that a new frame
             * was received. */
            xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
10001c0e:	2001      	movs	r0, #1
10001c10:	f7ff fa4c 	bl	100010ac <xMBPortEventPost>
10001c14:	e028      	b.n	10001c68 <xMBASCIIReceiveFSM+0x120>
        }
        else if( ucByte == ':' )
10001c16:	2a3a      	cmp	r2, #58	; 0x3a
10001c18:	d10b      	bne.n	10001c32 <xMBASCIIReceiveFSM+0xea>
        {
            /* Empty receive buffer and back to receive state. */
            eBytePos = BYTE_HIGH_NIBBLE;
10001c1a:	2300      	movs	r3, #0
10001c1c:	4a14      	ldr	r2, [pc, #80]	; (10001c70 <xMBASCIIReceiveFSM+0x128>)
10001c1e:	7013      	strb	r3, [r2, #0]
            usRcvBufferPos = 0;
10001c20:	4a14      	ldr	r2, [pc, #80]	; (10001c74 <xMBASCIIReceiveFSM+0x12c>)
10001c22:	8013      	strh	r3, [r2, #0]
            eRcvState = STATE_RX_RCV;
10001c24:	2201      	movs	r2, #1
10001c26:	4b11      	ldr	r3, [pc, #68]	; (10001c6c <xMBASCIIReceiveFSM+0x124>)
10001c28:	701a      	strb	r2, [r3, #0]

            /* Enable timer for character timeout. */
            vMBPortTimersEnable(  );
10001c2a:	f7ff fb23 	bl	10001274 <vMBPortTimersEnable>
}

BOOL
xMBASCIIReceiveFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001c2e:	2000      	movs	r0, #0
10001c30:	e01a      	b.n	10001c68 <xMBASCIIReceiveFSM+0x120>
            vMBPortTimersEnable(  );
        }
        else
        {
            /* Frame is not okay. Delete entire frame. */
            eRcvState = STATE_RX_IDLE;
10001c32:	2200      	movs	r2, #0
10001c34:	4b0d      	ldr	r3, [pc, #52]	; (10001c6c <xMBASCIIReceiveFSM+0x124>)
10001c36:	701a      	strb	r2, [r3, #0]
}

BOOL
xMBASCIIReceiveFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001c38:	2000      	movs	r0, #0
10001c3a:	e015      	b.n	10001c68 <xMBASCIIReceiveFSM+0x120>
            eRcvState = STATE_RX_IDLE;
        }
        break;

    case STATE_RX_IDLE:
        if( ucByte == ':' )
10001c3c:	466b      	mov	r3, sp
10001c3e:	3307      	adds	r3, #7
10001c40:	781b      	ldrb	r3, [r3, #0]
10001c42:	2b3a      	cmp	r3, #58	; 0x3a
10001c44:	d10f      	bne.n	10001c66 <xMBASCIIReceiveFSM+0x11e>
        {
            /* Enable timer for character timeout. */
            vMBPortTimersEnable(  );
10001c46:	f7ff fb15 	bl	10001274 <vMBPortTimersEnable>
            /* Reset the input buffers to store the frame. */
            usRcvBufferPos = 0;;
10001c4a:	2200      	movs	r2, #0
10001c4c:	4b09      	ldr	r3, [pc, #36]	; (10001c74 <xMBASCIIReceiveFSM+0x12c>)
10001c4e:	801a      	strh	r2, [r3, #0]
            eBytePos = BYTE_HIGH_NIBBLE;
10001c50:	4b07      	ldr	r3, [pc, #28]	; (10001c70 <xMBASCIIReceiveFSM+0x128>)
10001c52:	701a      	strb	r2, [r3, #0]
            eRcvState = STATE_RX_RCV;
10001c54:	2201      	movs	r2, #1
10001c56:	4b05      	ldr	r3, [pc, #20]	; (10001c6c <xMBASCIIReceiveFSM+0x124>)
10001c58:	701a      	strb	r2, [r3, #0]
}

BOOL
xMBASCIIReceiveFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001c5a:	2000      	movs	r0, #0
10001c5c:	e004      	b.n	10001c68 <xMBASCIIReceiveFSM+0x120>
10001c5e:	2000      	movs	r0, #0
10001c60:	e002      	b.n	10001c68 <xMBASCIIReceiveFSM+0x120>
10001c62:	2000      	movs	r0, #0
10001c64:	e000      	b.n	10001c68 <xMBASCIIReceiveFSM+0x120>
10001c66:	2000      	movs	r0, #0
        }
        break;
    }

    return xNeedPoll;
}
10001c68:	b003      	add	sp, #12
10001c6a:	bd00      	pop	{pc}
10001c6c:	200005eb 	.word	0x200005eb
10001c70:	200005e5 	.word	0x200005e5
10001c74:	200005e8 	.word	0x200005e8
10001c78:	20000638 	.word	0x20000638
10001c7c:	200005e4 	.word	0x200005e4

10001c80 <xMBASCIITransmitFSM>:

BOOL
xMBASCIITransmitFSM( void )
{
10001c80:	b570      	push	{r4, r5, r6, lr}
    BOOL            xNeedPoll = FALSE;
    UCHAR           ucByte;

    assert( eRcvState == STATE_RX_IDLE );
    switch ( eSndState )
10001c82:	4b38      	ldr	r3, [pc, #224]	; (10001d64 <xMBASCIITransmitFSM+0xe4>)
10001c84:	781b      	ldrb	r3, [r3, #0]
10001c86:	b2db      	uxtb	r3, r3
10001c88:	2b04      	cmp	r3, #4
10001c8a:	d865      	bhi.n	10001d58 <xMBASCIITransmitFSM+0xd8>
10001c8c:	009b      	lsls	r3, r3, #2
10001c8e:	4a36      	ldr	r2, [pc, #216]	; (10001d68 <xMBASCIITransmitFSM+0xe8>)
10001c90:	58d3      	ldr	r3, [r2, r3]
10001c92:	469f      	mov	pc, r3
    {
        /* Start of transmission. The start of a frame is defined by sending
         * the character ':'. */
    case STATE_TX_START:
        ucByte = ':';
        xMBPortSerialPutByte( ( CHAR )ucByte );
10001c94:	203a      	movs	r0, #58	; 0x3a
10001c96:	f7ff faaf 	bl	100011f8 <xMBPortSerialPutByte>
        eSndState = STATE_TX_DATA;
10001c9a:	2202      	movs	r2, #2
10001c9c:	4b31      	ldr	r3, [pc, #196]	; (10001d64 <xMBASCIITransmitFSM+0xe4>)
10001c9e:	701a      	strb	r2, [r3, #0]
        eBytePos = BYTE_HIGH_NIBBLE;
10001ca0:	2200      	movs	r2, #0
10001ca2:	4b32      	ldr	r3, [pc, #200]	; (10001d6c <xMBASCIITransmitFSM+0xec>)
10001ca4:	701a      	strb	r2, [r3, #0]
}

BOOL
xMBASCIITransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001ca6:	2400      	movs	r4, #0
    case STATE_TX_START:
        ucByte = ':';
        xMBPortSerialPutByte( ( CHAR )ucByte );
        eSndState = STATE_TX_DATA;
        eBytePos = BYTE_HIGH_NIBBLE;
        break;
10001ca8:	e059      	b.n	10001d5e <xMBASCIITransmitFSM+0xde>
        /* Send the data block. Each data byte is encoded as a character hex
         * stream with the high nibble sent first and the low nibble sent
         * last. If all data bytes are exhausted we send a '\r' character
         * to end the transmission. */
    case STATE_TX_DATA:
        if( usSndBufferCount > 0 )
10001caa:	4b31      	ldr	r3, [pc, #196]	; (10001d70 <xMBASCIITransmitFSM+0xf0>)
10001cac:	881b      	ldrh	r3, [r3, #0]
10001cae:	b29b      	uxth	r3, r3
10001cb0:	2b00      	cmp	r3, #0
10001cb2:	d02c      	beq.n	10001d0e <xMBASCIITransmitFSM+0x8e>
        {
            switch ( eBytePos )
10001cb4:	4b2d      	ldr	r3, [pc, #180]	; (10001d6c <xMBASCIITransmitFSM+0xec>)
10001cb6:	781b      	ldrb	r3, [r3, #0]
10001cb8:	b2db      	uxtb	r3, r3
10001cba:	2b00      	cmp	r3, #0
10001cbc:	d002      	beq.n	10001cc4 <xMBASCIITransmitFSM+0x44>
10001cbe:	2b01      	cmp	r3, #1
10001cc0:	d00e      	beq.n	10001ce0 <xMBASCIITransmitFSM+0x60>
10001cc2:	e04b      	b.n	10001d5c <xMBASCIITransmitFSM+0xdc>
            {
            case BYTE_HIGH_NIBBLE:
                ucByte = prvucMBBIN2CHAR( ( UCHAR )( *pucSndBufferCur >> 4 ) );
10001cc4:	4b2b      	ldr	r3, [pc, #172]	; (10001d74 <xMBASCIITransmitFSM+0xf4>)
10001cc6:	681b      	ldr	r3, [r3, #0]
10001cc8:	7818      	ldrb	r0, [r3, #0]
10001cca:	0900      	lsrs	r0, r0, #4
10001ccc:	f7ff fe90 	bl	100019f0 <prvucMBBIN2CHAR>
                xMBPortSerialPutByte( ( CHAR ) ucByte );
10001cd0:	b240      	sxtb	r0, r0
10001cd2:	f7ff fa91 	bl	100011f8 <xMBPortSerialPutByte>
                eBytePos = BYTE_LOW_NIBBLE;
10001cd6:	2201      	movs	r2, #1
10001cd8:	4b24      	ldr	r3, [pc, #144]	; (10001d6c <xMBASCIITransmitFSM+0xec>)
10001cda:	701a      	strb	r2, [r3, #0]
}

BOOL
xMBASCIITransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001cdc:	2400      	movs	r4, #0
            {
            case BYTE_HIGH_NIBBLE:
                ucByte = prvucMBBIN2CHAR( ( UCHAR )( *pucSndBufferCur >> 4 ) );
                xMBPortSerialPutByte( ( CHAR ) ucByte );
                eBytePos = BYTE_LOW_NIBBLE;
                break;
10001cde:	e03e      	b.n	10001d5e <xMBASCIITransmitFSM+0xde>

            case BYTE_LOW_NIBBLE:
                ucByte = prvucMBBIN2CHAR( ( UCHAR )( *pucSndBufferCur & 0x0F ) );
10001ce0:	4c24      	ldr	r4, [pc, #144]	; (10001d74 <xMBASCIITransmitFSM+0xf4>)
10001ce2:	6823      	ldr	r3, [r4, #0]
10001ce4:	7818      	ldrb	r0, [r3, #0]
10001ce6:	230f      	movs	r3, #15
10001ce8:	4018      	ands	r0, r3
10001cea:	f7ff fe81 	bl	100019f0 <prvucMBBIN2CHAR>
                xMBPortSerialPutByte( ( CHAR )ucByte );
10001cee:	b240      	sxtb	r0, r0
10001cf0:	f7ff fa82 	bl	100011f8 <xMBPortSerialPutByte>
                pucSndBufferCur++;
10001cf4:	6823      	ldr	r3, [r4, #0]
10001cf6:	3301      	adds	r3, #1
10001cf8:	6023      	str	r3, [r4, #0]
                eBytePos = BYTE_HIGH_NIBBLE;
10001cfa:	2200      	movs	r2, #0
10001cfc:	4b1b      	ldr	r3, [pc, #108]	; (10001d6c <xMBASCIITransmitFSM+0xec>)
10001cfe:	701a      	strb	r2, [r3, #0]
                usSndBufferCount--;
10001d00:	4a1b      	ldr	r2, [pc, #108]	; (10001d70 <xMBASCIITransmitFSM+0xf0>)
10001d02:	8813      	ldrh	r3, [r2, #0]
10001d04:	3b01      	subs	r3, #1
10001d06:	b29b      	uxth	r3, r3
10001d08:	8013      	strh	r3, [r2, #0]
}

BOOL
xMBASCIITransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001d0a:	2400      	movs	r4, #0
                ucByte = prvucMBBIN2CHAR( ( UCHAR )( *pucSndBufferCur & 0x0F ) );
                xMBPortSerialPutByte( ( CHAR )ucByte );
                pucSndBufferCur++;
                eBytePos = BYTE_HIGH_NIBBLE;
                usSndBufferCount--;
                break;
10001d0c:	e027      	b.n	10001d5e <xMBASCIITransmitFSM+0xde>
            }
        }
        else
        {
            xMBPortSerialPutByte( MB_ASCII_DEFAULT_CR );
10001d0e:	200d      	movs	r0, #13
10001d10:	f7ff fa72 	bl	100011f8 <xMBPortSerialPutByte>
            eSndState = STATE_TX_END;
10001d14:	2203      	movs	r2, #3
10001d16:	4b13      	ldr	r3, [pc, #76]	; (10001d64 <xMBASCIITransmitFSM+0xe4>)
10001d18:	701a      	strb	r2, [r3, #0]
}

BOOL
xMBASCIITransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001d1a:	2400      	movs	r4, #0
10001d1c:	e01f      	b.n	10001d5e <xMBASCIITransmitFSM+0xde>
        }
        break;

        /* Finish the frame by sending a LF character. */
    case STATE_TX_END:
        xMBPortSerialPutByte( ( CHAR )ucMBLFCharacter );
10001d1e:	4b16      	ldr	r3, [pc, #88]	; (10001d78 <xMBASCIITransmitFSM+0xf8>)
10001d20:	7818      	ldrb	r0, [r3, #0]
10001d22:	b240      	sxtb	r0, r0
10001d24:	f7ff fa68 	bl	100011f8 <xMBPortSerialPutByte>
        /* We need another state to make sure that the CR character has
         * been sent. */
        eSndState = STATE_TX_NOTIFY;
10001d28:	2204      	movs	r2, #4
10001d2a:	4b0e      	ldr	r3, [pc, #56]	; (10001d64 <xMBASCIITransmitFSM+0xe4>)
10001d2c:	701a      	strb	r2, [r3, #0]
}

BOOL
xMBASCIITransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001d2e:	2400      	movs	r4, #0
    case STATE_TX_END:
        xMBPortSerialPutByte( ( CHAR )ucMBLFCharacter );
        /* We need another state to make sure that the CR character has
         * been sent. */
        eSndState = STATE_TX_NOTIFY;
        break;
10001d30:	e015      	b.n	10001d5e <xMBASCIITransmitFSM+0xde>

        /* Notify the task which called eMBASCIISend that the frame has
         * been sent. */
    case STATE_TX_NOTIFY:
        eSndState = STATE_TX_IDLE;
10001d32:	4d0c      	ldr	r5, [pc, #48]	; (10001d64 <xMBASCIITransmitFSM+0xe4>)
10001d34:	2600      	movs	r6, #0
10001d36:	702e      	strb	r6, [r5, #0]
        xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
10001d38:	2003      	movs	r0, #3
10001d3a:	f7ff f9b7 	bl	100010ac <xMBPortEventPost>
10001d3e:	1c04      	adds	r4, r0, #0

        /* Disable transmitter. This prevents another transmit buffer
         * empty interrupt. */
        vMBPortSerialEnable( TRUE, FALSE );
10001d40:	2001      	movs	r0, #1
10001d42:	2100      	movs	r1, #0
10001d44:	f7ff f9d6 	bl	100010f4 <vMBPortSerialEnable>
        eSndState = STATE_TX_IDLE;
10001d48:	702e      	strb	r6, [r5, #0]
        break;
10001d4a:	e008      	b.n	10001d5e <xMBASCIITransmitFSM+0xde>

        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBPortSerialEnable( TRUE, FALSE );
10001d4c:	2001      	movs	r0, #1
10001d4e:	2100      	movs	r1, #0
10001d50:	f7ff f9d0 	bl	100010f4 <vMBPortSerialEnable>
}

BOOL
xMBASCIITransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001d54:	2400      	movs	r4, #0
        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBPortSerialEnable( TRUE, FALSE );
        break;
10001d56:	e002      	b.n	10001d5e <xMBASCIITransmitFSM+0xde>
}

BOOL
xMBASCIITransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
10001d58:	2400      	movs	r4, #0
10001d5a:	e000      	b.n	10001d5e <xMBASCIITransmitFSM+0xde>
10001d5c:	2400      	movs	r4, #0
        vMBPortSerialEnable( TRUE, FALSE );
        break;
    }

    return xNeedPoll;
}
10001d5e:	1c20      	adds	r0, r4, #0
10001d60:	bd70      	pop	{r4, r5, r6, pc}
10001d62:	46c0      	nop			; (mov r8, r8)
10001d64:	200005ea 	.word	0x200005ea
10001d68:	10002f90 	.word	0x10002f90
10001d6c:	200005e5 	.word	0x200005e5
10001d70:	200005e6 	.word	0x200005e6
10001d74:	200005e0 	.word	0x200005e0
10001d78:	200005e4 	.word	0x200005e4

10001d7c <xMBASCIITimerT1SExpired>:

BOOL
xMBASCIITimerT1SExpired( void )
{
10001d7c:	b508      	push	{r3, lr}
    switch ( eRcvState )
10001d7e:	4b06      	ldr	r3, [pc, #24]	; (10001d98 <xMBASCIITimerT1SExpired+0x1c>)
10001d80:	781b      	ldrb	r3, [r3, #0]
10001d82:	3b01      	subs	r3, #1
10001d84:	2b01      	cmp	r3, #1
10001d86:	d802      	bhi.n	10001d8e <xMBASCIITimerT1SExpired+0x12>
        /* If we have a timeout we go back to the idle state and wait for
         * the next frame.
         */
    case STATE_RX_RCV:
    case STATE_RX_WAIT_EOF:
        eRcvState = STATE_RX_IDLE;
10001d88:	2200      	movs	r2, #0
10001d8a:	4b03      	ldr	r3, [pc, #12]	; (10001d98 <xMBASCIITimerT1SExpired+0x1c>)
10001d8c:	701a      	strb	r2, [r3, #0]

    default:
        assert( ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_WAIT_EOF ) );
        break;
    }
    vMBPortTimersDisable(  );
10001d8e:	f7ff fa83 	bl	10001298 <vMBPortTimersDisable>

    /* no context switch required. */
    return FALSE;
}
10001d92:	2000      	movs	r0, #0
10001d94:	bd08      	pop	{r3, pc}
10001d96:	46c0      	nop			; (mov r8, r8)
10001d98:	200005eb 	.word	0x200005eb

10001d9c <eMBInit>:
};

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBInit( eMBMode eMode, UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
10001d9c:	b570      	push	{r4, r5, r6, lr}
10001d9e:	1c05      	adds	r5, r0, #0
10001da0:	ac04      	add	r4, sp, #16
10001da2:	7826      	ldrb	r6, [r4, #0]
    eMBErrorCode    eStatus = MB_ENOERR;

    /* check preconditions */
    if( ( ucSlaveAddress == MB_ADDRESS_BROADCAST ) ||
        ( ucSlaveAddress < MB_ADDRESS_MIN ) || ( ucSlaveAddress > MB_ADDRESS_MAX ) )
10001da4:	1e4c      	subs	r4, r1, #1
10001da6:	b2e4      	uxtb	r4, r4
eMBInit( eMBMode eMode, UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
    eMBErrorCode    eStatus = MB_ENOERR;

    /* check preconditions */
    if( ( ucSlaveAddress == MB_ADDRESS_BROADCAST ) ||
10001da8:	2cf6      	cmp	r4, #246	; 0xf6
10001daa:	d853      	bhi.n	10001e54 <eMBInit+0xb8>
    {
        eStatus = MB_EINVAL;
    }
    else
    {
        ucMBAddress = ucSlaveAddress;
10001dac:	4c2c      	ldr	r4, [pc, #176]	; (10001e60 <eMBInit+0xc4>)
10001dae:	7021      	strb	r1, [r4, #0]

        switch ( eMode )
10001db0:	2800      	cmp	r0, #0
10001db2:	d002      	beq.n	10001dba <eMBInit+0x1e>
10001db4:	2801      	cmp	r0, #1
10001db6:	d020      	beq.n	10001dfa <eMBInit+0x5e>
10001db8:	e03f      	b.n	10001e3a <eMBInit+0x9e>
        {
#if MB_RTU_ENABLED > 0
        case MB_RTU:
            pvMBFrameStartCur = eMBRTUStart;
10001dba:	4c2a      	ldr	r4, [pc, #168]	; (10001e64 <eMBInit+0xc8>)
10001dbc:	482a      	ldr	r0, [pc, #168]	; (10001e68 <eMBInit+0xcc>)
10001dbe:	6004      	str	r4, [r0, #0]
            pvMBFrameStopCur = eMBRTUStop;
10001dc0:	4c2a      	ldr	r4, [pc, #168]	; (10001e6c <eMBInit+0xd0>)
10001dc2:	482b      	ldr	r0, [pc, #172]	; (10001e70 <eMBInit+0xd4>)
10001dc4:	6004      	str	r4, [r0, #0]
            peMBFrameSendCur = eMBRTUSend;
10001dc6:	4c2b      	ldr	r4, [pc, #172]	; (10001e74 <eMBInit+0xd8>)
10001dc8:	482b      	ldr	r0, [pc, #172]	; (10001e78 <eMBInit+0xdc>)
10001dca:	6004      	str	r4, [r0, #0]
            peMBFrameReceiveCur = eMBRTUReceive;
10001dcc:	4c2b      	ldr	r4, [pc, #172]	; (10001e7c <eMBInit+0xe0>)
10001dce:	482c      	ldr	r0, [pc, #176]	; (10001e80 <eMBInit+0xe4>)
10001dd0:	6004      	str	r4, [r0, #0]
            pvMBFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBPortClose : NULL;
10001dd2:	2400      	movs	r4, #0
10001dd4:	482b      	ldr	r0, [pc, #172]	; (10001e84 <eMBInit+0xe8>)
10001dd6:	6004      	str	r4, [r0, #0]
            pxMBFrameCBByteReceived = xMBRTUReceiveFSM;
10001dd8:	4c2b      	ldr	r4, [pc, #172]	; (10001e88 <eMBInit+0xec>)
10001dda:	482c      	ldr	r0, [pc, #176]	; (10001e8c <eMBInit+0xf0>)
10001ddc:	6004      	str	r4, [r0, #0]
            pxMBFrameCBTransmitterEmpty = xMBRTUTransmitFSM;
10001dde:	4c2c      	ldr	r4, [pc, #176]	; (10001e90 <eMBInit+0xf4>)
10001de0:	482c      	ldr	r0, [pc, #176]	; (10001e94 <eMBInit+0xf8>)
10001de2:	6004      	str	r4, [r0, #0]
            pxMBPortCBTimerExpired = xMBRTUTimerT35Expired;
10001de4:	4c2c      	ldr	r4, [pc, #176]	; (10001e98 <eMBInit+0xfc>)
10001de6:	482d      	ldr	r0, [pc, #180]	; (10001e9c <eMBInit+0x100>)
10001de8:	6004      	str	r4, [r0, #0]

            eStatus = eMBRTUInit( ucMBAddress, ucPort, ulBaudRate, eParity );
10001dea:	1c08      	adds	r0, r1, #0
10001dec:	1c11      	adds	r1, r2, #0
10001dee:	1c1a      	adds	r2, r3, #0
10001df0:	1c33      	adds	r3, r6, #0
10001df2:	f7ff fa7b 	bl	100012ec <eMBRTUInit>
10001df6:	1c04      	adds	r4, r0, #0
            break;
10001df8:	e020      	b.n	10001e3c <eMBInit+0xa0>
#endif
#if MB_ASCII_ENABLED > 0
        case MB_ASCII:
            pvMBFrameStartCur = eMBASCIIStart;
10001dfa:	4c29      	ldr	r4, [pc, #164]	; (10001ea0 <eMBInit+0x104>)
10001dfc:	481a      	ldr	r0, [pc, #104]	; (10001e68 <eMBInit+0xcc>)
10001dfe:	6004      	str	r4, [r0, #0]
            pvMBFrameStopCur = eMBASCIIStop;
10001e00:	4c28      	ldr	r4, [pc, #160]	; (10001ea4 <eMBInit+0x108>)
10001e02:	481b      	ldr	r0, [pc, #108]	; (10001e70 <eMBInit+0xd4>)
10001e04:	6004      	str	r4, [r0, #0]
            peMBFrameSendCur = eMBASCIISend;
10001e06:	4c28      	ldr	r4, [pc, #160]	; (10001ea8 <eMBInit+0x10c>)
10001e08:	481b      	ldr	r0, [pc, #108]	; (10001e78 <eMBInit+0xdc>)
10001e0a:	6004      	str	r4, [r0, #0]
            peMBFrameReceiveCur = eMBASCIIReceive;
10001e0c:	4c27      	ldr	r4, [pc, #156]	; (10001eac <eMBInit+0x110>)
10001e0e:	481c      	ldr	r0, [pc, #112]	; (10001e80 <eMBInit+0xe4>)
10001e10:	6004      	str	r4, [r0, #0]
            pvMBFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBPortClose : NULL;
10001e12:	2400      	movs	r4, #0
10001e14:	481b      	ldr	r0, [pc, #108]	; (10001e84 <eMBInit+0xe8>)
10001e16:	6004      	str	r4, [r0, #0]
            pxMBFrameCBByteReceived = xMBASCIIReceiveFSM;
10001e18:	4c25      	ldr	r4, [pc, #148]	; (10001eb0 <eMBInit+0x114>)
10001e1a:	481c      	ldr	r0, [pc, #112]	; (10001e8c <eMBInit+0xf0>)
10001e1c:	6004      	str	r4, [r0, #0]
            pxMBFrameCBTransmitterEmpty = xMBASCIITransmitFSM;
10001e1e:	4c25      	ldr	r4, [pc, #148]	; (10001eb4 <eMBInit+0x118>)
10001e20:	481c      	ldr	r0, [pc, #112]	; (10001e94 <eMBInit+0xf8>)
10001e22:	6004      	str	r4, [r0, #0]
            pxMBPortCBTimerExpired = xMBASCIITimerT1SExpired;
10001e24:	4c24      	ldr	r4, [pc, #144]	; (10001eb8 <eMBInit+0x11c>)
10001e26:	481d      	ldr	r0, [pc, #116]	; (10001e9c <eMBInit+0x100>)
10001e28:	6004      	str	r4, [r0, #0]

            eStatus = eMBASCIIInit( ucMBAddress, ucPort, ulBaudRate, eParity );
10001e2a:	1c08      	adds	r0, r1, #0
10001e2c:	1c11      	adds	r1, r2, #0
10001e2e:	1c1a      	adds	r2, r3, #0
10001e30:	1c33      	adds	r3, r6, #0
10001e32:	f7ff fdf9 	bl	10001a28 <eMBASCIIInit>
10001e36:	1c04      	adds	r4, r0, #0
            break;
10001e38:	e000      	b.n	10001e3c <eMBInit+0xa0>
#endif
        default:
            eStatus = MB_EINVAL;
10001e3a:	2402      	movs	r4, #2
        }

        if( eStatus == MB_ENOERR )
10001e3c:	2c00      	cmp	r4, #0
10001e3e:	d10c      	bne.n	10001e5a <eMBInit+0xbe>
        {
            if( !xMBPortEventInit(  ) )
10001e40:	f7ff f92c 	bl	1000109c <xMBPortEventInit>
10001e44:	2800      	cmp	r0, #0
10001e46:	d007      	beq.n	10001e58 <eMBInit+0xbc>
                /* port dependent event module initalization failed. */
                eStatus = MB_EPORTERR;
            }
            else
            {
                eMBCurrentMode = eMode;
10001e48:	4b1c      	ldr	r3, [pc, #112]	; (10001ebc <eMBInit+0x120>)
10001e4a:	701d      	strb	r5, [r3, #0]
                eMBState = STATE_DISABLED;
10001e4c:	2201      	movs	r2, #1
10001e4e:	4b1c      	ldr	r3, [pc, #112]	; (10001ec0 <eMBInit+0x124>)
10001e50:	701a      	strb	r2, [r3, #0]
10001e52:	e002      	b.n	10001e5a <eMBInit+0xbe>

    /* check preconditions */
    if( ( ucSlaveAddress == MB_ADDRESS_BROADCAST ) ||
        ( ucSlaveAddress < MB_ADDRESS_MIN ) || ( ucSlaveAddress > MB_ADDRESS_MAX ) )
    {
        eStatus = MB_EINVAL;
10001e54:	2402      	movs	r4, #2
10001e56:	e000      	b.n	10001e5a <eMBInit+0xbe>
        if( eStatus == MB_ENOERR )
        {
            if( !xMBPortEventInit(  ) )
            {
                /* port dependent event module initalization failed. */
                eStatus = MB_EPORTERR;
10001e58:	2403      	movs	r4, #3
                eMBState = STATE_DISABLED;
            }
        }
    }
    return eStatus;
}
10001e5a:	1c20      	adds	r0, r4, #0
10001e5c:	bd70      	pop	{r4, r5, r6, pc}
10001e5e:	46c0      	nop			; (mov r8, r8)
10001e60:	2000060b 	.word	0x2000060b
10001e64:	10001331 	.word	0x10001331
10001e68:	200005f4 	.word	0x200005f4
10001e6c:	10001351 	.word	0x10001351
10001e70:	200005ec 	.word	0x200005ec
10001e74:	100013b1 	.word	0x100013b1
10001e78:	200005fc 	.word	0x200005fc
10001e7c:	10001365 	.word	0x10001365
10001e80:	200005f0 	.word	0x200005f0
10001e84:	2000060c 	.word	0x2000060c
10001e88:	10001429 	.word	0x10001429
10001e8c:	20000740 	.word	0x20000740
10001e90:	100014b9 	.word	0x100014b9
10001e94:	20000738 	.word	0x20000738
10001e98:	1000152d 	.word	0x1000152d
10001e9c:	2000073c 	.word	0x2000073c
10001ea0:	10001a61 	.word	0x10001a61
10001ea4:	10001a81 	.word	0x10001a81
10001ea8:	10001ae1 	.word	0x10001ae1
10001eac:	10001a95 	.word	0x10001a95
10001eb0:	10001b49 	.word	0x10001b49
10001eb4:	10001c81 	.word	0x10001c81
10001eb8:	10001d7d 	.word	0x10001d7d
10001ebc:	20000601 	.word	0x20000601
10001ec0:	200005a0 	.word	0x200005a0

10001ec4 <eMBEnable>:
    return eStatus;
}

eMBErrorCode
eMBEnable( void )
{
10001ec4:	b508      	push	{r3, lr}
    eMBErrorCode    eStatus = MB_ENOERR;

    if( eMBState == STATE_DISABLED )
10001ec6:	4b07      	ldr	r3, [pc, #28]	; (10001ee4 <eMBEnable+0x20>)
10001ec8:	781b      	ldrb	r3, [r3, #0]
10001eca:	2b01      	cmp	r3, #1
10001ecc:	d107      	bne.n	10001ede <eMBEnable+0x1a>
    {
        /* Activate the protocol stack. */
        pvMBFrameStartCur(  );
10001ece:	4b06      	ldr	r3, [pc, #24]	; (10001ee8 <eMBEnable+0x24>)
10001ed0:	681b      	ldr	r3, [r3, #0]
10001ed2:	4798      	blx	r3
        eMBState = STATE_ENABLED;
10001ed4:	2200      	movs	r2, #0
10001ed6:	4b03      	ldr	r3, [pc, #12]	; (10001ee4 <eMBEnable+0x20>)
10001ed8:	701a      	strb	r2, [r3, #0]
}

eMBErrorCode
eMBEnable( void )
{
    eMBErrorCode    eStatus = MB_ENOERR;
10001eda:	2000      	movs	r0, #0
10001edc:	e000      	b.n	10001ee0 <eMBEnable+0x1c>
        pvMBFrameStartCur(  );
        eMBState = STATE_ENABLED;
    }
    else
    {
        eStatus = MB_EILLSTATE;
10001ede:	2006      	movs	r0, #6
    }
    return eStatus;
}
10001ee0:	bd08      	pop	{r3, pc}
10001ee2:	46c0      	nop			; (mov r8, r8)
10001ee4:	200005a0 	.word	0x200005a0
10001ee8:	200005f4 	.word	0x200005f4

10001eec <eMBPoll>:
    return eStatus;
}

eMBErrorCode
eMBPoll( void )
{
10001eec:	b530      	push	{r4, r5, lr}
10001eee:	b083      	sub	sp, #12
    int             i;
    eMBErrorCode    eStatus = MB_ENOERR;
    eMBEventType    eEvent;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
10001ef0:	4b38      	ldr	r3, [pc, #224]	; (10001fd4 <eMBPoll+0xe8>)
10001ef2:	781b      	ldrb	r3, [r3, #0]
10001ef4:	2b00      	cmp	r3, #0
10001ef6:	d160      	bne.n	10001fba <eMBPoll+0xce>
        return MB_EILLSTATE;
    }

    /* Check if there is a event available. If not return control to caller.
     * Otherwise we will handle the event. */
    if( xMBPortEventGet( &eEvent ) == TRUE )
10001ef8:	466b      	mov	r3, sp
10001efa:	1dd8      	adds	r0, r3, #7
10001efc:	f7ff f8e2 	bl	100010c4 <xMBPortEventGet>
10001f00:	2801      	cmp	r0, #1
10001f02:	d15c      	bne.n	10001fbe <eMBPoll+0xd2>
    {
        switch ( eEvent )
10001f04:	466b      	mov	r3, sp
10001f06:	3307      	adds	r3, #7
10001f08:	781b      	ldrb	r3, [r3, #0]
10001f0a:	2b01      	cmp	r3, #1
10001f0c:	d002      	beq.n	10001f14 <eMBPoll+0x28>
10001f0e:	2b02      	cmp	r3, #2
10001f10:	d015      	beq.n	10001f3e <eMBPoll+0x52>
10001f12:	e056      	b.n	10001fc2 <eMBPoll+0xd6>
        {
        case EV_READY:
            break;

        case EV_FRAME_RECEIVED:
            eStatus = peMBFrameReceiveCur( &ucRcvAddress, &ucMBFrame, &usLength );
10001f14:	4b30      	ldr	r3, [pc, #192]	; (10001fd8 <eMBPoll+0xec>)
10001f16:	681b      	ldr	r3, [r3, #0]
10001f18:	4830      	ldr	r0, [pc, #192]	; (10001fdc <eMBPoll+0xf0>)
10001f1a:	4931      	ldr	r1, [pc, #196]	; (10001fe0 <eMBPoll+0xf4>)
10001f1c:	4a31      	ldr	r2, [pc, #196]	; (10001fe4 <eMBPoll+0xf8>)
10001f1e:	4798      	blx	r3
            if( eStatus == MB_ENOERR )
10001f20:	2800      	cmp	r0, #0
10001f22:	d150      	bne.n	10001fc6 <eMBPoll+0xda>
            {
                /* Check if the frame is for us. If not ignore the frame. */
                if( ( ucRcvAddress == ucMBAddress ) || ( ucRcvAddress == MB_ADDRESS_BROADCAST ) )
10001f24:	4b2d      	ldr	r3, [pc, #180]	; (10001fdc <eMBPoll+0xf0>)
10001f26:	781b      	ldrb	r3, [r3, #0]
10001f28:	4a2f      	ldr	r2, [pc, #188]	; (10001fe8 <eMBPoll+0xfc>)
10001f2a:	7812      	ldrb	r2, [r2, #0]
10001f2c:	4293      	cmp	r3, r2
10001f2e:	d001      	beq.n	10001f34 <eMBPoll+0x48>
10001f30:	2b00      	cmp	r3, #0
10001f32:	d14a      	bne.n	10001fca <eMBPoll+0xde>
                {
                    ( void )xMBPortEventPost( EV_EXECUTE );
10001f34:	2002      	movs	r0, #2
10001f36:	f7ff f8b9 	bl	100010ac <xMBPortEventPost>

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
10001f3a:	2000      	movs	r0, #0
10001f3c:	e048      	b.n	10001fd0 <eMBPoll+0xe4>
                }
            }
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
10001f3e:	4b28      	ldr	r3, [pc, #160]	; (10001fe0 <eMBPoll+0xf4>)
10001f40:	6818      	ldr	r0, [r3, #0]
10001f42:	7804      	ldrb	r4, [r0, #0]
10001f44:	4b29      	ldr	r3, [pc, #164]	; (10001fec <eMBPoll+0x100>)
10001f46:	701c      	strb	r4, [r3, #0]
            eException = MB_EX_ILLEGAL_FUNCTION;
10001f48:	2201      	movs	r2, #1
10001f4a:	4b29      	ldr	r3, [pc, #164]	; (10001ff0 <eMBPoll+0x104>)
10001f4c:	701a      	strb	r2, [r3, #0]
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
10001f4e:	2300      	movs	r3, #0
10001f50:	e00f      	b.n	10001f72 <eMBPoll+0x86>
            {
                /* No more function handlers registered. Abort. */
                if( xFuncHandlers[i].ucFunctionCode == 0 )
10001f52:	00da      	lsls	r2, r3, #3
10001f54:	4927      	ldr	r1, [pc, #156]	; (10001ff4 <eMBPoll+0x108>)
10001f56:	5c52      	ldrb	r2, [r2, r1]
10001f58:	2a00      	cmp	r2, #0
10001f5a:	d00c      	beq.n	10001f76 <eMBPoll+0x8a>
                {
                    break;
                }
                else if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
10001f5c:	4294      	cmp	r4, r2
10001f5e:	d107      	bne.n	10001f70 <eMBPoll+0x84>
                {
                    eException = xFuncHandlers[i].pxHandler( ucMBFrame, &usLength );
10001f60:	00db      	lsls	r3, r3, #3
10001f62:	18cb      	adds	r3, r1, r3
10001f64:	685b      	ldr	r3, [r3, #4]
10001f66:	491f      	ldr	r1, [pc, #124]	; (10001fe4 <eMBPoll+0xf8>)
10001f68:	4798      	blx	r3
10001f6a:	4b21      	ldr	r3, [pc, #132]	; (10001ff0 <eMBPoll+0x104>)
10001f6c:	7018      	strb	r0, [r3, #0]
                    break;
10001f6e:	e002      	b.n	10001f76 <eMBPoll+0x8a>
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
            eException = MB_EX_ILLEGAL_FUNCTION;
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
10001f70:	3301      	adds	r3, #1
10001f72:	2b0f      	cmp	r3, #15
10001f74:	d9ed      	bls.n	10001f52 <eMBPoll+0x66>
                }
            }

            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
10001f76:	4b19      	ldr	r3, [pc, #100]	; (10001fdc <eMBPoll+0xf0>)
10001f78:	781b      	ldrb	r3, [r3, #0]
10001f7a:	2b00      	cmp	r3, #0
10001f7c:	d027      	beq.n	10001fce <eMBPoll+0xe2>
            {
                if( eException != MB_EX_NONE )
10001f7e:	4b1c      	ldr	r3, [pc, #112]	; (10001ff0 <eMBPoll+0x104>)
10001f80:	781b      	ldrb	r3, [r3, #0]
10001f82:	2b00      	cmp	r3, #0
10001f84:	d00e      	beq.n	10001fa4 <eMBPoll+0xb8>
                {
                    /* An exception occured. Build an error frame. */
                    usLength = 0;
10001f86:	4a17      	ldr	r2, [pc, #92]	; (10001fe4 <eMBPoll+0xf8>)
                    ucMBFrame[usLength++] = ( UCHAR )( ucFunctionCode | MB_FUNC_ERROR );
10001f88:	4815      	ldr	r0, [pc, #84]	; (10001fe0 <eMBPoll+0xf4>)
10001f8a:	6804      	ldr	r4, [r0, #0]
10001f8c:	2101      	movs	r1, #1
10001f8e:	8011      	strh	r1, [r2, #0]
10001f90:	4916      	ldr	r1, [pc, #88]	; (10001fec <eMBPoll+0x100>)
10001f92:	780d      	ldrb	r5, [r1, #0]
10001f94:	2180      	movs	r1, #128	; 0x80
10001f96:	4329      	orrs	r1, r5
10001f98:	7021      	strb	r1, [r4, #0]
                    ucMBFrame[usLength++] = eException;
10001f9a:	6800      	ldr	r0, [r0, #0]
10001f9c:	8811      	ldrh	r1, [r2, #0]
10001f9e:	1c4c      	adds	r4, r1, #1
10001fa0:	8014      	strh	r4, [r2, #0]
10001fa2:	5443      	strb	r3, [r0, r1]
                }
                if( ( eMBCurrentMode == MB_ASCII ) && MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS )
                {
                    vMBPortTimersDelay( MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS );
                }                
                eStatus = peMBFrameSendCur( ucMBAddress, ucMBFrame, usLength );
10001fa4:	4b14      	ldr	r3, [pc, #80]	; (10001ff8 <eMBPoll+0x10c>)
10001fa6:	681b      	ldr	r3, [r3, #0]
10001fa8:	4a0f      	ldr	r2, [pc, #60]	; (10001fe8 <eMBPoll+0xfc>)
10001faa:	7810      	ldrb	r0, [r2, #0]
10001fac:	4a0c      	ldr	r2, [pc, #48]	; (10001fe0 <eMBPoll+0xf4>)
10001fae:	6811      	ldr	r1, [r2, #0]
10001fb0:	4a0c      	ldr	r2, [pc, #48]	; (10001fe4 <eMBPoll+0xf8>)
10001fb2:	8812      	ldrh	r2, [r2, #0]
10001fb4:	4798      	blx	r3

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
10001fb6:	2000      	movs	r0, #0
10001fb8:	e00a      	b.n	10001fd0 <eMBPoll+0xe4>
    eMBEventType    eEvent;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
    {
        return MB_EILLSTATE;
10001fba:	2006      	movs	r0, #6
10001fbc:	e008      	b.n	10001fd0 <eMBPoll+0xe4>

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
10001fbe:	2000      	movs	r0, #0
10001fc0:	e006      	b.n	10001fd0 <eMBPoll+0xe4>
10001fc2:	2000      	movs	r0, #0
10001fc4:	e004      	b.n	10001fd0 <eMBPoll+0xe4>
10001fc6:	2000      	movs	r0, #0
10001fc8:	e002      	b.n	10001fd0 <eMBPoll+0xe4>
10001fca:	2000      	movs	r0, #0
10001fcc:	e000      	b.n	10001fd0 <eMBPoll+0xe4>
10001fce:	2000      	movs	r0, #0
}
10001fd0:	b003      	add	sp, #12
10001fd2:	bd30      	pop	{r4, r5, pc}
10001fd4:	200005a0 	.word	0x200005a0
10001fd8:	200005f0 	.word	0x200005f0
10001fdc:	200005f8 	.word	0x200005f8
10001fe0:	20000604 	.word	0x20000604
10001fe4:	20000608 	.word	0x20000608
10001fe8:	2000060b 	.word	0x2000060b
10001fec:	20000600 	.word	0x20000600
10001ff0:	2000060a 	.word	0x2000060a
10001ff4:	20000520 	.word	0x20000520
10001ff8:	200005fc 	.word	0x200005fc

10001ffc <SystemCoreSetup>:

__WEAK void SystemCoreSetup(void)
{
#ifndef USE_DYNAMIC_FLASH_WS
  /* Fix flash wait states to 1 cycle (see DS Addendum) */
  NVM->NVMCONF |= NVM_NVMCONF_WS_Msk;
10001ffc:	4b06      	ldr	r3, [pc, #24]	; (10002018 <SystemCoreSetup+0x1c>)
10001ffe:	8919      	ldrh	r1, [r3, #8]
10002000:	2280      	movs	r2, #128	; 0x80
10002002:	0152      	lsls	r2, r2, #5
10002004:	430a      	orrs	r2, r1
10002006:	811a      	strh	r2, [r3, #8]
  NVM->CONFIG1 |= NVM_CONFIG1_FIXWS_Msk;
10002008:	2148      	movs	r1, #72	; 0x48
1000200a:	5a58      	ldrh	r0, [r3, r1]
1000200c:	2280      	movs	r2, #128	; 0x80
1000200e:	0112      	lsls	r2, r2, #4
10002010:	4302      	orrs	r2, r0
10002012:	525a      	strh	r2, [r3, r1]
#endif
}
10002014:	4770      	bx	lr
10002016:	46c0      	nop			; (mov r8, r8)
10002018:	40050000 	.word	0x40050000

1000201c <SystemCoreClockUpdate>:
  
  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
1000201c:	b508      	push	{r3, lr}
  static uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
1000201e:	4a0d      	ldr	r2, [pc, #52]	; (10002054 <SystemCoreClockUpdate+0x38>)
10002020:	6813      	ldr	r3, [r2, #0]
10002022:	041b      	lsls	r3, r3, #16
10002024:	0e1b      	lsrs	r3, r3, #24
10002026:	490c      	ldr	r1, [pc, #48]	; (10002058 <SystemCoreClockUpdate+0x3c>)
10002028:	600b      	str	r3, [r1, #0]
  FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
1000202a:	6812      	ldr	r2, [r2, #0]
1000202c:	21ff      	movs	r1, #255	; 0xff
1000202e:	4011      	ands	r1, r2
10002030:	4a0a      	ldr	r2, [pc, #40]	; (1000205c <SystemCoreClockUpdate+0x40>)
10002032:	6011      	str	r1, [r2, #0]
  
  if (IDIV != 0)
10002034:	2b00      	cmp	r3, #0
10002036:	d008      	beq.n	1000204a <SystemCoreClockUpdate+0x2e>
  {
    /* Fractional divider is enabled and used */
    SystemCoreClock = ((DCO1_FREQUENCY << 6U) / ((IDIV << 8) + FDIV)) << 1U;
10002038:	021b      	lsls	r3, r3, #8
1000203a:	18c9      	adds	r1, r1, r3
1000203c:	4808      	ldr	r0, [pc, #32]	; (10002060 <SystemCoreClockUpdate+0x44>)
1000203e:	f000 fde5 	bl	10002c0c <__aeabi_uidiv>
10002042:	0040      	lsls	r0, r0, #1
10002044:	4b07      	ldr	r3, [pc, #28]	; (10002064 <SystemCoreClockUpdate+0x48>)
10002046:	6018      	str	r0, [r3, #0]
10002048:	e002      	b.n	10002050 <SystemCoreClockUpdate+0x34>
  }
  else
  {
    /* Fractional divider bypassed. Simply divide DCO_DCLK by 2 */
    SystemCoreClock = DCO1_FREQUENCY >> 1U;
1000204a:	4a07      	ldr	r2, [pc, #28]	; (10002068 <SystemCoreClockUpdate+0x4c>)
1000204c:	4b05      	ldr	r3, [pc, #20]	; (10002064 <SystemCoreClockUpdate+0x48>)
1000204e:	601a      	str	r2, [r3, #0]
  }
}
10002050:	bd08      	pop	{r3, pc}
10002052:	46c0      	nop			; (mov r8, r8)
10002054:	40010300 	.word	0x40010300
10002058:	20000610 	.word	0x20000610
1000205c:	20000614 	.word	0x20000614
10002060:	f4240000 	.word	0xf4240000
10002064:	20003ffc 	.word	0x20003ffc
10002068:	01e84800 	.word	0x01e84800

1000206c <SystemCoreClockSetup>:
  NVM->CONFIG1 |= NVM_CONFIG1_FIXWS_Msk;
#endif
}

__WEAK void SystemCoreClockSetup(void)
{
1000206c:	b508      	push	{r3, lr}
  /* Override values of CLOCK_VAL1 and CLOCK_VAL2 defined in vector table */
  /* MCLK = 32MHz, PCLK = 64MHz */
  
  SCU_GENERAL->PASSWD = 0x000000C0UL; /* disable bit protection */
1000206e:	22c0      	movs	r2, #192	; 0xc0
10002070:	4b07      	ldr	r3, [pc, #28]	; (10002090 <SystemCoreClockSetup+0x24>)
10002072:	625a      	str	r2, [r3, #36]	; 0x24
  SCU_CLK->CLKCR = 0x3FF10100UL;
10002074:	4a07      	ldr	r2, [pc, #28]	; (10002094 <SystemCoreClockSetup+0x28>)
10002076:	4b08      	ldr	r3, [pc, #32]	; (10002098 <SystemCoreClockSetup+0x2c>)
10002078:	601a      	str	r2, [r3, #0]
  while((SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk));
1000207a:	4b07      	ldr	r3, [pc, #28]	; (10002098 <SystemCoreClockSetup+0x2c>)
1000207c:	681b      	ldr	r3, [r3, #0]
1000207e:	005b      	lsls	r3, r3, #1
10002080:	d4fb      	bmi.n	1000207a <SystemCoreClockSetup+0xe>
  SCU_GENERAL->PASSWD = 0x000000C3UL; /* enable bit protection */
10002082:	22c3      	movs	r2, #195	; 0xc3
10002084:	4b02      	ldr	r3, [pc, #8]	; (10002090 <SystemCoreClockSetup+0x24>)
10002086:	625a      	str	r2, [r3, #36]	; 0x24
  
  SystemCoreClockUpdate();
10002088:	f7ff ffc8 	bl	1000201c <SystemCoreClockUpdate>
}
1000208c:	bd08      	pop	{r3, pc}
1000208e:	46c0      	nop			; (mov r8, r8)
10002090:	40010000 	.word	0x40010000
10002094:	3ff10100 	.word	0x3ff10100
10002098:	40010300 	.word	0x40010300

1000209c <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{    
1000209c:	b508      	push	{r3, lr}
  SystemCoreSetup();
1000209e:	f7ff ffad 	bl	10001ffc <SystemCoreSetup>
  SystemCoreClockSetup();
100020a2:	f7ff ffe3 	bl	1000206c <SystemCoreClockSetup>
}
100020a6:	bd08      	pop	{r3, pc}

100020a8 <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
100020a8:	b5f0      	push	{r4, r5, r6, r7, lr}
100020aa:	464f      	mov	r7, r9
100020ac:	4646      	mov	r6, r8
100020ae:	b4c0      	push	{r6, r7}
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
  XMC_ASSERT("XMC_GPIO_Init: Invalid input hysteresis", XMC_GPIO_CHECK_INPUT_HYSTERESIS(config->input_hysteresis));
  
  /* Switch to input */
  port->IOCR[pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
100020b0:	088b      	lsrs	r3, r1, #2
100020b2:	4699      	mov	r9, r3
100020b4:	3304      	adds	r3, #4
100020b6:	009b      	lsls	r3, r3, #2
100020b8:	581e      	ldr	r6, [r3, r0]
100020ba:	2503      	movs	r5, #3
100020bc:	400d      	ands	r5, r1
100020be:	00ed      	lsls	r5, r5, #3
100020c0:	27f8      	movs	r7, #248	; 0xf8
100020c2:	40af      	lsls	r7, r5
100020c4:	43be      	bics	r6, r7
100020c6:	501e      	str	r6, [r3, r0]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
100020c8:	6f43      	ldr	r3, [r0, #116]	; 0x74
100020ca:	004f      	lsls	r7, r1, #1
100020cc:	2603      	movs	r6, #3
100020ce:	40be      	lsls	r6, r7
100020d0:	43b3      	bics	r3, r6
100020d2:	6743      	str	r3, [r0, #116]	; 0x74

  /* Set input hysteresis */
  port->PHCR[(uint32_t)pin >> 3U] &= ~(uint32_t)((uint32_t)PORT_PHCR_Msk << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U)));
100020d4:	08cb      	lsrs	r3, r1, #3
100020d6:	3310      	adds	r3, #16
100020d8:	009b      	lsls	r3, r3, #2
100020da:	581c      	ldr	r4, [r3, r0]
100020dc:	2607      	movs	r6, #7
100020de:	400e      	ands	r6, r1
100020e0:	00b6      	lsls	r6, r6, #2
100020e2:	2704      	movs	r7, #4
100020e4:	40b7      	lsls	r7, r6
100020e6:	43bc      	bics	r4, r7
100020e8:	501c      	str	r4, [r3, r0]
  port->PHCR[(uint32_t)pin >> 3U] |= (uint32_t)config->input_hysteresis << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U));
100020ea:	581f      	ldr	r7, [r3, r0]
100020ec:	46bc      	mov	ip, r7
100020ee:	7857      	ldrb	r7, [r2, #1]
100020f0:	40b7      	lsls	r7, r6
100020f2:	1c3e      	adds	r6, r7, #0
100020f4:	4667      	mov	r7, ip
100020f6:	433e      	orrs	r6, r7
100020f8:	501e      	str	r6, [r3, r0]
    
  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
100020fa:	4b0c      	ldr	r3, [pc, #48]	; (1000212c <XMC_GPIO_Init+0x84>)
100020fc:	4298      	cmp	r0, r3
100020fe:	d104      	bne.n	1000210a <XMC_GPIO_Init+0x62>
  {    
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
10002100:	6e03      	ldr	r3, [r0, #96]	; 0x60
10002102:	2601      	movs	r6, #1
10002104:	408e      	lsls	r6, r1
10002106:	43b3      	bics	r3, r6
10002108:	6603      	str	r3, [r0, #96]	; 0x60
  }
  /* Set output level */
  port->OMR = (uint32_t)config->output_level << pin;
1000210a:	6853      	ldr	r3, [r2, #4]
1000210c:	408b      	lsls	r3, r1
1000210e:	6043      	str	r3, [r0, #4]
  
  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << (PORT_IOCR_PC_Size * (pin & 0x3U));
10002110:	464b      	mov	r3, r9
10002112:	3304      	adds	r3, #4
10002114:	009b      	lsls	r3, r3, #2
10002116:	5819      	ldr	r1, [r3, r0]
10002118:	7812      	ldrb	r2, [r2, #0]
1000211a:	40aa      	lsls	r2, r5
1000211c:	1c15      	adds	r5, r2, #0
1000211e:	430d      	orrs	r5, r1
10002120:	501d      	str	r5, [r3, r0]
}
10002122:	bc0c      	pop	{r2, r3}
10002124:	4690      	mov	r8, r2
10002126:	4699      	mov	r9, r3
10002128:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000212a:	46c0      	nop			; (mov r8, r8)
1000212c:	40040200 	.word	0x40040200

10002130 <XMC_SCU_CLOCK_lFrequencyUpScaling>:

}

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
10002130:	b510      	push	{r4, lr}
  while (curr_idiv > (target_idiv * 4UL))
10002132:	e00d      	b.n	10002150 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x20>
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */
10002134:	0880      	lsrs	r0, r0, #2

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10002136:	4c08      	ldr	r4, [pc, #32]	; (10002158 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x28>)
10002138:	6822      	ldr	r2, [r4, #0]
1000213a:	4b08      	ldr	r3, [pc, #32]	; (1000215c <XMC_SCU_CLOCK_lFrequencyUpScaling+0x2c>)
1000213c:	4013      	ands	r3, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) | 
1000213e:	0202      	lsls	r2, r0, #8
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10002140:	4313      	orrs	r3, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) | 
10002142:	4a07      	ldr	r2, [pc, #28]	; (10002160 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x30>)
10002144:	4313      	orrs	r3, r2
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10002146:	6023      	str	r3, [r4, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) | 
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10002148:	4b03      	ldr	r3, [pc, #12]	; (10002158 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x28>)
1000214a:	681b      	ldr	r3, [r3, #0]
1000214c:	005b      	lsls	r3, r3, #1
1000214e:	d4fb      	bmi.n	10002148 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x18>
}

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
  while (curr_idiv > (target_idiv * 4UL))
10002150:	008b      	lsls	r3, r1, #2
10002152:	4283      	cmp	r3, r0
10002154:	d3ee      	bcc.n	10002134 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x4>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
    /* Wait voltage suply stabilization */
    }
  }
}
10002156:	bd10      	pop	{r4, pc}
10002158:	40010300 	.word	0x40010300
1000215c:	c00f00ff 	.word	0xc00f00ff
10002160:	3ff00000 	.word	0x3ff00000

10002164 <XMC_SCU_CLOCK_lFrequencyDownScaling>:

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
10002164:	b510      	push	{r4, lr}

  while ((curr_idiv * 4UL) < target_idiv)
10002166:	e010      	b.n	1000218a <XMC_SCU_CLOCK_lFrequencyDownScaling+0x26>
  {
    if(0U == curr_idiv)
10002168:	2800      	cmp	r0, #0
1000216a:	d100      	bne.n	1000216e <XMC_SCU_CLOCK_lFrequencyDownScaling+0xa>
    {
      curr_idiv = 1U;
1000216c:	3001      	adds	r0, #1
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
1000216e:	0080      	lsls	r0, r0, #2
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10002170:	4c08      	ldr	r4, [pc, #32]	; (10002194 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x30>)
10002172:	6822      	ldr	r2, [r4, #0]
10002174:	4b08      	ldr	r3, [pc, #32]	; (10002198 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x34>)
10002176:	4013      	ands	r3, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
10002178:	0202      	lsls	r2, r0, #8
    if(0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000217a:	4313      	orrs	r3, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
1000217c:	4a07      	ldr	r2, [pc, #28]	; (1000219c <XMC_SCU_CLOCK_lFrequencyDownScaling+0x38>)
1000217e:	4313      	orrs	r3, r2
    if(0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10002180:	6023      	str	r3, [r4, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10002182:	4b04      	ldr	r3, [pc, #16]	; (10002194 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x30>)
10002184:	681b      	ldr	r3, [r3, #0]
10002186:	005b      	lsls	r3, r3, #1
10002188:	d4fb      	bmi.n	10002182 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x1e>

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{

  while ((curr_idiv * 4UL) < target_idiv)
1000218a:	0083      	lsls	r3, r0, #2
1000218c:	428b      	cmp	r3, r1
1000218e:	d3eb      	bcc.n	10002168 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x4>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
    /* Wait voltage suply stabilization */
    }
  }
}
10002190:	bd10      	pop	{r4, pc}
10002192:	46c0      	nop			; (mov r8, r8)
10002194:	40010300 	.word	0x40010300
10002198:	c00f00ff 	.word	0xc00f00ff
1000219c:	3ff00000 	.word	0x3ff00000

100021a0 <XMC_SCU_LockProtectedBits>:
}

/* API to lock protected bitfields from being modified */
void XMC_SCU_LockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_ENABLE;
100021a0:	22c3      	movs	r2, #195	; 0xc3
100021a2:	4b01      	ldr	r3, [pc, #4]	; (100021a8 <XMC_SCU_LockProtectedBits+0x8>)
100021a4:	625a      	str	r2, [r3, #36]	; 0x24
}
100021a6:	4770      	bx	lr
100021a8:	40010000 	.word	0x40010000

100021ac <XMC_SCU_UnlockProtectedBits>:

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
100021ac:	22c0      	movs	r2, #192	; 0xc0
100021ae:	4b03      	ldr	r3, [pc, #12]	; (100021bc <XMC_SCU_UnlockProtectedBits+0x10>)
100021b0:	625a      	str	r2, [r3, #36]	; 0x24

  while(((SCU_GENERAL->PASSWD) & SCU_GENERAL_PASSWD_PROTS_Msk))
100021b2:	4b02      	ldr	r3, [pc, #8]	; (100021bc <XMC_SCU_UnlockProtectedBits+0x10>)
100021b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100021b6:	075b      	lsls	r3, r3, #29
100021b8:	d4fb      	bmi.n	100021b2 <XMC_SCU_UnlockProtectedBits+0x6>
  {
    /* Loop until the lock is removed */
  }
}
100021ba:	4770      	bx	lr
100021bc:	40010000 	.word	0x40010000

100021c0 <XMC_SCU_CLOCK_UngatePeripheralClock>:
  XMC_SCU_LockProtectedBits();
}

/* API which ungates a clock note at its source */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
100021c0:	b510      	push	{r4, lr}
100021c2:	1c04      	adds	r4, r0, #0
  XMC_SCU_UnlockProtectedBits();
100021c4:	f7ff fff2 	bl	100021ac <XMC_SCU_UnlockProtectedBits>
  SCU_CLK->CGATCLR0 |= (uint32_t)peripheral;
100021c8:	4b05      	ldr	r3, [pc, #20]	; (100021e0 <XMC_SCU_CLOCK_UngatePeripheralClock+0x20>)
100021ca:	691a      	ldr	r2, [r3, #16]
100021cc:	4314      	orrs	r4, r2
100021ce:	611c      	str	r4, [r3, #16]
  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
100021d0:	4b03      	ldr	r3, [pc, #12]	; (100021e0 <XMC_SCU_CLOCK_UngatePeripheralClock+0x20>)
100021d2:	681b      	ldr	r3, [r3, #0]
100021d4:	005b      	lsls	r3, r3, #1
100021d6:	d4fb      	bmi.n	100021d0 <XMC_SCU_CLOCK_UngatePeripheralClock+0x10>
  {
    /* Wait voltage suply stabilization */
  }
  XMC_SCU_LockProtectedBits();
100021d8:	f7ff ffe2 	bl	100021a0 <XMC_SCU_LockProtectedBits>
}
100021dc:	bd10      	pop	{r4, pc}
100021de:	46c0      	nop			; (mov r8, r8)
100021e0:	40010300 	.word	0x40010300

100021e4 <XMC_SCU_CLOCK_ScaleMCLKFrequency>:
}


/* A utility routine which updates the fractional dividers in steps */
void XMC_SCU_CLOCK_ScaleMCLKFrequency(uint32_t idiv, uint32_t fdiv)
{
100021e4:	b538      	push	{r3, r4, r5, lr}
100021e6:	1c04      	adds	r4, r0, #0
100021e8:	1c0d      	adds	r5, r1, #0
  /* Find out current and target value of idiv */
  uint32_t curr_idiv;

  XMC_SCU_UnlockProtectedBits();
100021ea:	f7ff ffdf 	bl	100021ac <XMC_SCU_UnlockProtectedBits>

  /* Take a snapshot of value already programmed into IDIV */
  curr_idiv = (SCU_CLK->CLKCR & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
100021ee:	4b15      	ldr	r3, [pc, #84]	; (10002244 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x60>)
100021f0:	6818      	ldr	r0, [r3, #0]
100021f2:	0400      	lsls	r0, r0, #16
100021f4:	0e00      	lsrs	r0, r0, #24

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100021f6:	6819      	ldr	r1, [r3, #0]
100021f8:	4a13      	ldr	r2, [pc, #76]	; (10002248 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x64>)
100021fa:	400a      	ands	r2, r1
100021fc:	4315      	orrs	r5, r2
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
100021fe:	4a13      	ldr	r2, [pc, #76]	; (1000224c <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x68>)
10002200:	4315      	orrs	r5, r2

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10002202:	601d      	str	r5, [r3, #0]
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#endif

  while ((SCU_CLK->CLKCR)& SCU_CLK_CLKCR_VDDC2LOW_Msk)
10002204:	4b0f      	ldr	r3, [pc, #60]	; (10002244 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x60>)
10002206:	681b      	ldr	r3, [r3, #0]
10002208:	005b      	lsls	r3, r3, #1
1000220a:	d4fb      	bmi.n	10002204 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x20>
  {
    /* Spin until the core supply stabilizes */
  }

  if(curr_idiv <= idiv)
1000220c:	42a0      	cmp	r0, r4
1000220e:	d803      	bhi.n	10002218 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x34>
  {
    /* Requested IDIV is greater than currently programmed IDIV. So downscale the frequency */
    XMC_SCU_CLOCK_lFrequencyDownScaling(curr_idiv, idiv);
10002210:	1c21      	adds	r1, r4, #0
10002212:	f7ff ffa7 	bl	10002164 <XMC_SCU_CLOCK_lFrequencyDownScaling>
10002216:	e002      	b.n	1000221e <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x3a>
  }
  else
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
10002218:	1c21      	adds	r1, r4, #0
1000221a:	f7ff ff89 	bl	10002130 <XMC_SCU_CLOCK_lFrequencyUpScaling>
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000221e:	4a09      	ldr	r2, [pc, #36]	; (10002244 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x60>)
10002220:	6811      	ldr	r1, [r2, #0]
10002222:	4b0b      	ldr	r3, [pc, #44]	; (10002250 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x6c>)
10002224:	400b      	ands	r3, r1
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
10002226:	0224      	lsls	r4, r4, #8
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10002228:	431c      	orrs	r4, r3
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
1000222a:	4b08      	ldr	r3, [pc, #32]	; (1000224c <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x68>)
1000222c:	431c      	orrs	r4, r3
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000222e:	6014      	str	r4, [r2, #0]
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10002230:	4b04      	ldr	r3, [pc, #16]	; (10002244 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x60>)
10002232:	681b      	ldr	r3, [r3, #0]
10002234:	005b      	lsls	r3, r3, #1
10002236:	d4fb      	bmi.n	10002230 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x4c>
  {
    /* Wait voltage suply stabilization */
  }

  XMC_SCU_LockProtectedBits();
10002238:	f7ff ffb2 	bl	100021a0 <XMC_SCU_LockProtectedBits>

  SystemCoreClockUpdate();
1000223c:	f7ff feee 	bl	1000201c <SystemCoreClockUpdate>

}
10002240:	bd38      	pop	{r3, r4, r5, pc}
10002242:	46c0      	nop			; (mov r8, r8)
10002244:	40010300 	.word	0x40010300
10002248:	c00fff00 	.word	0xc00fff00
1000224c:	3ff00000 	.word	0x3ff00000
10002250:	c00f00ff 	.word	0xc00f00ff

10002254 <XMC_SCU_CLOCK_Init>:
}


/* API which initializes the clock tree ofthe device */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
10002254:	b510      	push	{r4, lr}
10002256:	1c04      	adds	r4, r0, #0
  /* Remove protection */
  XMC_SCU_UnlockProtectedBits();
10002258:	f7ff ffa8 	bl	100021ac <XMC_SCU_UnlockProtectedBits>
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
1000225c:	4a07      	ldr	r2, [pc, #28]	; (1000227c <XMC_SCU_CLOCK_Init+0x28>)
1000225e:	6811      	ldr	r1, [r2, #0]
10002260:	4b07      	ldr	r3, [pc, #28]	; (10002280 <XMC_SCU_CLOCK_Init+0x2c>)
10002262:	400b      	ands	r3, r1
10002264:	68a1      	ldr	r1, [r4, #8]
10002266:	430b      	orrs	r3, r1
                   config->rtc_src |
10002268:	6861      	ldr	r1, [r4, #4]
1000226a:	430b      	orrs	r3, r1
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
1000226c:	6013      	str	r3, [r2, #0]
                   config->rtc_src |
                   config->pclk_src;

  /* Close the lock opened above. */
  XMC_SCU_LockProtectedBits();
1000226e:	f7ff ff97 	bl	100021a0 <XMC_SCU_LockProtectedBits>

  /* Update the dividers now */
  XMC_SCU_CLOCK_ScaleMCLKFrequency(config->idiv, config->fdiv);
10002272:	7860      	ldrb	r0, [r4, #1]
10002274:	7821      	ldrb	r1, [r4, #0]
10002276:	f7ff ffb5 	bl	100021e4 <XMC_SCU_CLOCK_ScaleMCLKFrequency>

}
1000227a:	bd10      	pop	{r4, pc}
1000227c:	40010300 	.word	0x40010300
10002280:	fff0ffff 	.word	0xfff0ffff

10002284 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:
/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
  return (SystemCoreClock);
10002284:	4b01      	ldr	r3, [pc, #4]	; (1000228c <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x8>)
10002286:	6818      	ldr	r0, [r3, #0]
}
10002288:	4770      	bx	lr
1000228a:	46c0      	nop			; (mov r8, r8)
1000228c:	20003ffc 	.word	0x20003ffc

10002290 <XMC_CCU4_EnableModule>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/

void XMC_CCU4_EnableModule(XMC_CCU4_MODULE_t *const module)
{
10002290:	b508      	push	{r3, lr}
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
10002292:	4b03      	ldr	r3, [pc, #12]	; (100022a0 <XMC_CCU4_EnableModule+0x10>)
10002294:	4298      	cmp	r0, r3
10002296:	d102      	bne.n	1000229e <XMC_CCU4_EnableModule+0xe>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
10002298:	2004      	movs	r0, #4
1000229a:	f7ff ff91 	bl	100021c0 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU4_lDeassertReset(module);
#endif
}
1000229e:	bd08      	pop	{r3, pc}
100022a0:	48040000 	.word	0x48040000

100022a4 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
100022a4:	b538      	push	{r3, r4, r5, lr}
100022a6:	1c04      	adds	r4, r0, #0
100022a8:	1c0d      	adds	r5, r1, #0
  
  XMC_ASSERT("XMC_CCU4_Init:Invalid module pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_Init:Invalid mcs action", XMC_CCU4_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
100022aa:	f7ff fff1 	bl	10002290 <XMC_CCU4_EnableModule>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
100022ae:	68e3      	ldr	r3, [r4, #12]
100022b0:	2280      	movs	r2, #128	; 0x80
100022b2:	0052      	lsls	r2, r2, #1
100022b4:	4313      	orrs	r3, r2
100022b6:	60e3      	str	r3, [r4, #12]
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
  
  gctrl = module->GCTRL;
100022b8:	6821      	ldr	r1, [r4, #0]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
100022ba:	4b03      	ldr	r3, [pc, #12]	; (100022c8 <XMC_CCU4_Init+0x24>)
100022bc:	400b      	ands	r3, r1
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
100022be:	03a9      	lsls	r1, r5, #14
100022c0:	4319      	orrs	r1, r3
  
  module->GCTRL = gctrl;
100022c2:	6021      	str	r1, [r4, #0]
}
100022c4:	bd38      	pop	{r3, r4, r5, pc}
100022c6:	46c0      	nop			; (mov r8, r8)
100022c8:	ffff3fff 	.word	0xffff3fff

100022cc <XMC_CCU4_SetModuleClock>:
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU4_SetModuleClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_SetModuleClock:Invalid Module Clock", XMC_CCU4_SLICE_CHECK_CLOCK(clock));

  gctrl = module->GCTRL;
100022cc:	6803      	ldr	r3, [r0, #0]
  gctrl &= ~((uint32_t) CCU4_GCTRL_PCIS_Msk);
100022ce:	2230      	movs	r2, #48	; 0x30
100022d0:	4393      	bics	r3, r2
  gctrl |= ((uint32_t) clock) << CCU4_GCTRL_PCIS_Pos;
100022d2:	0109      	lsls	r1, r1, #4
100022d4:	4319      	orrs	r1, r3
  
  module->GCTRL = gctrl;
100022d6:	6001      	str	r1, [r0, #0]
}
100022d8:	4770      	bx	lr
100022da:	46c0      	nop			; (mov r8, r8)

100022dc <XMC_CCU4_SLICE_CompareInit>:
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
100022dc:	680b      	ldr	r3, [r1, #0]
100022de:	6143      	str	r3, [r0, #20]
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
100022e0:	794b      	ldrb	r3, [r1, #5]
100022e2:	069b      	lsls	r3, r3, #26
100022e4:	0fdb      	lsrs	r3, r3, #31
100022e6:	051b      	lsls	r3, r3, #20
100022e8:	6043      	str	r3, [r0, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
100022ea:	790b      	ldrb	r3, [r1, #4]
100022ec:	071b      	lsls	r3, r3, #28
100022ee:	0f1b      	lsrs	r3, r3, #28
100022f0:	6243      	str	r3, [r0, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
100022f2:	794b      	ldrb	r3, [r1, #5]
100022f4:	071b      	lsls	r3, r3, #28
100022f6:	0f1b      	lsrs	r3, r3, #28
100022f8:	6203      	str	r3, [r0, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
100022fa:	794b      	ldrb	r3, [r1, #5]
100022fc:	06db      	lsls	r3, r3, #27
100022fe:	0fdb      	lsrs	r3, r3, #31
10002300:	6183      	str	r3, [r0, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
10002302:	790b      	ldrb	r3, [r1, #4]
10002304:	091b      	lsrs	r3, r3, #4
10002306:	62c3      	str	r3, [r0, #44]	; 0x2c
}
10002308:	4770      	bx	lr
1000230a:	46c0      	nop			; (mov r8, r8)

1000230c <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
1000230c:	b510      	push	{r4, lr}

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  
  srs = slice->SRS;
1000230e:	23a8      	movs	r3, #168	; 0xa8
10002310:	58c3      	ldr	r3, [r0, r3]
  
  switch(event)
10002312:	2909      	cmp	r1, #9
10002314:	d80e      	bhi.n	10002334 <XMC_CCU4_SLICE_SetInterruptNode+0x28>
10002316:	0089      	lsls	r1, r1, #2
10002318:	4c0c      	ldr	r4, [pc, #48]	; (1000234c <XMC_CCU4_SLICE_SetInterruptNode+0x40>)
1000231a:	5861      	ldr	r1, [r4, r1]
1000231c:	468f      	mov	pc, r1
  {
    case XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH:
    case XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH:
      mask = ((uint32_t) CCU4_CC4_SRS_POSR_Msk);
1000231e:	2403      	movs	r4, #3
      pos  = CCU4_CC4_SRS_POSR_Pos;
10002320:	2100      	movs	r1, #0
10002322:	e00d      	b.n	10002340 <XMC_CCU4_SLICE_SetInterruptNode+0x34>
      mask = ((uint32_t) CCU4_CC4_SRS_CMSR_Msk);
      pos  = CCU4_CC4_SRS_CMSR_Pos;
      break;

    case XMC_CCU4_SLICE_IRQ_ID_EVENT0:
      mask = ((uint32_t) CCU4_CC4_SRS_E0SR_Msk);
10002324:	24c0      	movs	r4, #192	; 0xc0
10002326:	00a4      	lsls	r4, r4, #2
      pos  = CCU4_CC4_SRS_E0SR_Pos;
10002328:	2108      	movs	r1, #8
      break;
1000232a:	e009      	b.n	10002340 <XMC_CCU4_SLICE_SetInterruptNode+0x34>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT1:
      mask = ((uint32_t) CCU4_CC4_SRS_E1SR_Msk);
1000232c:	24c0      	movs	r4, #192	; 0xc0
1000232e:	0124      	lsls	r4, r4, #4
      pos  = CCU4_CC4_SRS_E1SR_Pos;
10002330:	210a      	movs	r1, #10
      break;
10002332:	e005      	b.n	10002340 <XMC_CCU4_SLICE_SetInterruptNode+0x34>

    default:
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
10002334:	24c0      	movs	r4, #192	; 0xc0
10002336:	01a4      	lsls	r4, r4, #6
      pos  = CCU4_CC4_SRS_E2SR_Pos;
10002338:	210c      	movs	r1, #12
      break;
1000233a:	e001      	b.n	10002340 <XMC_CCU4_SLICE_SetInterruptNode+0x34>
      pos  = CCU4_CC4_SRS_POSR_Pos;
      break;

    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP:
    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN:
      mask = ((uint32_t) CCU4_CC4_SRS_CMSR_Msk);
1000233c:	240c      	movs	r4, #12
      pos  = CCU4_CC4_SRS_CMSR_Pos;
1000233e:	2102      	movs	r1, #2
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
      pos  = CCU4_CC4_SRS_E2SR_Pos;
      break;
  }
  
  srs &= ~mask; 
10002340:	43a3      	bics	r3, r4
  srs |= (uint32_t)sr << pos;
10002342:	408a      	lsls	r2, r1
10002344:	431a      	orrs	r2, r3
  slice->SRS = srs;
10002346:	23a8      	movs	r3, #168	; 0xa8
10002348:	50c2      	str	r2, [r0, r3]
}
1000234a:	bd10      	pop	{r4, pc}
1000234c:	10002fa4 	.word	0x10002fa4

10002350 <XMC_UART_CH_Init>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 *********************************************************************************************************************/

void XMC_UART_CH_Init(XMC_USIC_CH_t *channel, const XMC_UART_CH_CONFIG_t *const config)
{
10002350:	b570      	push	{r4, r5, r6, lr}
10002352:	1c05      	adds	r5, r0, #0
10002354:	1c0e      	adds	r6, r1, #0
  uint32_t oversampling = XMC_UART_CH_OVERSAMPLING;

  /* USIC channel switched on*/
  XMC_USIC_CH_Enable(channel);
10002356:	f000 f8c1 	bl	100024dc <XMC_USIC_CH_Enable>
  
  if(config->oversampling != 0U)
1000235a:	79f4      	ldrb	r4, [r6, #7]
1000235c:	2c00      	cmp	r4, #0
1000235e:	d100      	bne.n	10002362 <XMC_UART_CH_Init+0x12>
 * API IMPLEMENTATION
 *********************************************************************************************************************/

void XMC_UART_CH_Init(XMC_USIC_CH_t *channel, const XMC_UART_CH_CONFIG_t *const config)
{
  uint32_t oversampling = XMC_UART_CH_OVERSAMPLING;
10002360:	3410      	adds	r4, #16
  {
    oversampling = (uint32_t)config->oversampling;
  }
  
  /* Configure baud rate */
  (void)XMC_USIC_CH_SetBaudrate(channel, config->baudrate, oversampling);
10002362:	1c28      	adds	r0, r5, #0
10002364:	6831      	ldr	r1, [r6, #0]
10002366:	1c22      	adds	r2, r4, #0
10002368:	f000 f85c 	bl	10002424 <XMC_USIC_CH_SetBaudrate>
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision 
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
1000236c:	79b3      	ldrb	r3, [r6, #6]
1000236e:	3b01      	subs	r3, #1
10002370:	005b      	lsls	r3, r3, #1
                                    (((oversampling >> 1UL) + 1UL) << USIC_CH_PCR_ASCMode_SP_Pos) |
10002372:	0864      	lsrs	r4, r4, #1
10002374:	3401      	adds	r4, #1
10002376:	0224      	lsls	r4, r4, #8
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision 
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
10002378:	431c      	orrs	r4, r3
1000237a:	4b11      	ldr	r3, [pc, #68]	; (100023c0 <XMC_UART_CH_Init+0x70>)
1000237c:	431c      	orrs	r4, r3
1000237e:	63ec      	str	r4, [r5, #60]	; 0x3c
  /* Set passive data level, high
     Set word length. Data bits - 1
     If frame length is > 0, frame_lemgth-1; else, FLE = WLE (Data bits - 1)
     Transmission Mode: The shift control signal is considered active if it
     is at 1-level. This is the setting to be programmed to allow data transfers */
  channel->SCTR = (uint32_t)((((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_WLE_Pos) |
10002380:	7933      	ldrb	r3, [r6, #4]
10002382:	3b01      	subs	r3, #1
10002384:	061b      	lsls	r3, r3, #24
10002386:	2281      	movs	r2, #129	; 0x81
10002388:	0052      	lsls	r2, r2, #1
1000238a:	4313      	orrs	r3, r2
1000238c:	636b      	str	r3, [r5, #52]	; 0x34
                             ((0x1UL << USIC_CH_SCTR_TRM_Pos) | USIC_CH_SCTR_PDL_Msk));

  if (config->frame_length != 0U)
1000238e:	7973      	ldrb	r3, [r6, #5]
10002390:	2b00      	cmp	r3, #0
10002392:	d005      	beq.n	100023a0 <XMC_UART_CH_Init+0x50>
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->frame_length - 1UL) << USIC_CH_SCTR_FLE_Pos);
10002394:	6b6a      	ldr	r2, [r5, #52]	; 0x34
10002396:	3b01      	subs	r3, #1
10002398:	041b      	lsls	r3, r3, #16
1000239a:	4313      	orrs	r3, r2
1000239c:	636b      	str	r3, [r5, #52]	; 0x34
1000239e:	e005      	b.n	100023ac <XMC_UART_CH_Init+0x5c>
  }
  else
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_FLE_Pos);
100023a0:	6b69      	ldr	r1, [r5, #52]	; 0x34
100023a2:	7932      	ldrb	r2, [r6, #4]
100023a4:	1e53      	subs	r3, r2, #1
100023a6:	041b      	lsls	r3, r3, #16
100023a8:	430b      	orrs	r3, r1
100023aa:	636b      	str	r3, [r5, #52]	; 0x34
  }

  /* Enable transfer buffer */
  channel->TCSR = (0x1UL << USIC_CH_TCSR_TDEN_Pos) |
100023ac:	23a0      	movs	r3, #160	; 0xa0
100023ae:	00db      	lsls	r3, r3, #3
100023b0:	63ab      	str	r3, [r5, #56]	; 0x38
                  USIC_CH_TCSR_TDSSM_Msk;

  /* Clear protocol status */
  channel->PSCR = 0xFFFFFFFFUL;
100023b2:	2301      	movs	r3, #1
100023b4:	425b      	negs	r3, r3
100023b6:	64eb      	str	r3, [r5, #76]	; 0x4c

  /* Set parity settings */
  channel->CCR = (uint32_t)config->parity_mode;
100023b8:	8933      	ldrh	r3, [r6, #8]
100023ba:	642b      	str	r3, [r5, #64]	; 0x40
}
100023bc:	bd70      	pop	{r4, r5, r6, pc}
100023be:	46c0      	nop			; (mov r8, r8)
100023c0:	00030001 	.word	0x00030001

100023c4 <XMC_UART_CH_Transmit>:
}

void XMC_UART_CH_Transmit(XMC_USIC_CH_t *const channel, const uint16_t data)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0UL)
100023c4:	2384      	movs	r3, #132	; 0x84
100023c6:	005b      	lsls	r3, r3, #1
100023c8:	58c2      	ldr	r2, [r0, r3]
100023ca:	23e0      	movs	r3, #224	; 0xe0
100023cc:	04db      	lsls	r3, r3, #19
100023ce:	421a      	tst	r2, r3
100023d0:	d108      	bne.n	100023e4 <XMC_UART_CH_Transmit+0x20>
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
100023d2:	6b83      	ldr	r3, [r0, #56]	; 0x38
  {
    /* Wait till the Transmit Buffer is free for transmission */
    while(XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
100023d4:	061b      	lsls	r3, r3, #24
100023d6:	d4fc      	bmi.n	100023d2 <XMC_UART_CH_Transmit+0xe>
100023d8:	2380      	movs	r3, #128	; 0x80
100023da:	019b      	lsls	r3, r3, #6
100023dc:	64c3      	str	r3, [r0, #76]	; 0x4c
  
    /* Clear the Transmit Buffer indication flag */
    XMC_UART_CH_ClearStatusFlag(channel, (uint32_t)XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);
  
    /*Transmit data */
    channel->TBUF[0U] = data;
100023de:	2380      	movs	r3, #128	; 0x80
100023e0:	50c1      	str	r1, [r0, r3]
100023e2:	e002      	b.n	100023ea <XMC_UART_CH_Transmit+0x26>
  }
  else
  {
    channel->IN[0U] = data;
100023e4:	23c0      	movs	r3, #192	; 0xc0
100023e6:	005b      	lsls	r3, r3, #1
100023e8:	50c1      	str	r1, [r0, r3]
  }
}
100023ea:	4770      	bx	lr

100023ec <XMC_UART_CH_GetReceivedData>:
uint16_t XMC_UART_CH_GetReceivedData(XMC_USIC_CH_t *const channel)
{
  uint16_t retval;

  /* Check FIFO size */
  if ((channel->RBCTR & USIC_CH_RBCTR_SIZE_Msk) == 0U)
100023ec:	2386      	movs	r3, #134	; 0x86
100023ee:	005b      	lsls	r3, r3, #1
100023f0:	58c2      	ldr	r2, [r0, r3]
100023f2:	23e0      	movs	r3, #224	; 0xe0
100023f4:	04db      	lsls	r3, r3, #19
100023f6:	421a      	tst	r2, r3
100023f8:	d102      	bne.n	10002400 <XMC_UART_CH_GetReceivedData+0x14>
  {
    retval = (uint16_t)channel->RBUF;
100023fa:	6d40      	ldr	r0, [r0, #84]	; 0x54
100023fc:	b280      	uxth	r0, r0
100023fe:	e003      	b.n	10002408 <XMC_UART_CH_GetReceivedData+0x1c>
  }
  else
  {
    retval = (uint16_t)channel->OUTR;
10002400:	238e      	movs	r3, #142	; 0x8e
10002402:	005b      	lsls	r3, r3, #1
10002404:	58c0      	ldr	r0, [r0, r3]
10002406:	b280      	uxth	r0, r0
  }

  return retval;
}
10002408:	4770      	bx	lr
1000240a:	46c0      	nop			; (mov r8, r8)

1000240c <XMC_UART_CH_EnableEvent>:
  return status;
}

void XMC_UART_CH_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
  channel->CCR |= (event&0x1fc00U);
1000240c:	6c02      	ldr	r2, [r0, #64]	; 0x40
1000240e:	23fe      	movs	r3, #254	; 0xfe
10002410:	025b      	lsls	r3, r3, #9
10002412:	400b      	ands	r3, r1
10002414:	4313      	orrs	r3, r2
10002416:	6403      	str	r3, [r0, #64]	; 0x40
  channel->PCR_ASCMode |= (event&0xf8U);
10002418:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
1000241a:	22f8      	movs	r2, #248	; 0xf8
1000241c:	4011      	ands	r1, r2
1000241e:	4319      	orrs	r1, r3
10002420:	63c1      	str	r1, [r0, #60]	; 0x3c
}
10002422:	4770      	bx	lr

10002424 <XMC_USIC_CH_SetBaudrate>:
{
  channel->KSCFG = (uint32_t)((channel->KSCFG & (~USIC_CH_KSCFG_MODEN_Msk)) | USIC_CH_KSCFG_BPMODEN_Msk);
}

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t oversampling)
{
10002424:	b5f0      	push	{r4, r5, r6, r7, lr}
10002426:	465f      	mov	r7, fp
10002428:	464e      	mov	r6, r9
1000242a:	b4c0      	push	{r6, r7}
1000242c:	b083      	sub	sp, #12
  
  uint32_t pdiv_frac;
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
1000242e:	2963      	cmp	r1, #99	; 0x63
10002430:	d93d      	bls.n	100024ae <XMC_USIC_CH_SetBaudrate+0x8a>
10002432:	2a00      	cmp	r2, #0
10002434:	d03d      	beq.n	100024b2 <XMC_USIC_CH_SetBaudrate+0x8e>
10002436:	1c15      	adds	r5, r2, #0
10002438:	1c0c      	adds	r4, r1, #0
1000243a:	4683      	mov	fp, r0
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
1000243c:	f7ff ff22 	bl	10002284 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
10002440:	2164      	movs	r1, #100	; 0x64
10002442:	f000 fbe3 	bl	10002c0c <__aeabi_uidiv>
10002446:	4681      	mov	r9, r0
    rate = rate / 100U;
10002448:	1c20      	adds	r0, r4, #0
1000244a:	2164      	movs	r1, #100	; 0x64
1000244c:	f000 fbde 	bl	10002c0c <__aeabi_uidiv>
10002450:	1c07      	adds	r7, r0, #0

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;
10002452:	4e1b      	ldr	r6, [pc, #108]	; (100024c0 <XMC_USIC_CH_SetBaudrate+0x9c>)
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
    rate = rate / 100U;

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
10002454:	2301      	movs	r3, #1
10002456:	9301      	str	r3, [sp, #4]
  if ((rate >= 100U) && (oversampling != 0U))
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
    rate = rate / 100U;

    clock_divider_min = 1U;
10002458:	9300      	str	r3, [sp, #0]
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
1000245a:	1c34      	adds	r4, r6, #0
1000245c:	e011      	b.n	10002482 <XMC_USIC_CH_SetBaudrate+0x5e>
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
1000245e:	4648      	mov	r0, r9
10002460:	4360      	muls	r0, r4
10002462:	1c29      	adds	r1, r5, #0
10002464:	4379      	muls	r1, r7
10002466:	f000 fbd1 	bl	10002c0c <__aeabi_uidiv>
      pdiv_int = pdiv >> 10U;
1000246a:	0a83      	lsrs	r3, r0, #10
      pdiv_frac = pdiv & 0x3ffU;
1000246c:	0580      	lsls	r0, r0, #22
1000246e:	0d80      	lsrs	r0, r0, #22

      if ((pdiv_int < 1024U) && (pdiv_frac < pdiv_frac_min))
10002470:	4a13      	ldr	r2, [pc, #76]	; (100024c0 <XMC_USIC_CH_SetBaudrate+0x9c>)
10002472:	4293      	cmp	r3, r2
10002474:	d804      	bhi.n	10002480 <XMC_USIC_CH_SetBaudrate+0x5c>
10002476:	42b0      	cmp	r0, r6
10002478:	d202      	bcs.n	10002480 <XMC_USIC_CH_SetBaudrate+0x5c>
      {
        pdiv_frac_min = pdiv_frac;
1000247a:	1c06      	adds	r6, r0, #0
        pdiv_int_min = pdiv_int;
1000247c:	9301      	str	r3, [sp, #4]
        clock_divider_min = clock_divider;
1000247e:	9400      	str	r4, [sp, #0]

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
10002480:	3c01      	subs	r4, #1
10002482:	2c00      	cmp	r4, #0
10002484:	d1eb      	bne.n	1000245e <XMC_USIC_CH_SetBaudrate+0x3a>
        pdiv_int_min = pdiv_int;
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
10002486:	2380      	movs	r3, #128	; 0x80
10002488:	021b      	lsls	r3, r3, #8
1000248a:	9f00      	ldr	r7, [sp, #0]
1000248c:	431f      	orrs	r7, r3
1000248e:	465b      	mov	r3, fp
10002490:	611f      	str	r7, [r3, #16]
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
10002492:	695a      	ldr	r2, [r3, #20]
10002494:	4b0b      	ldr	r3, [pc, #44]	; (100024c4 <XMC_USIC_CH_SetBaudrate+0xa0>)
10002496:	4013      	ands	r3, r2
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
10002498:	3d01      	subs	r5, #1
1000249a:	02ad      	lsls	r5, r5, #10
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
1000249c:	431d      	orrs	r5, r3
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
1000249e:	9e01      	ldr	r6, [sp, #4]
100024a0:	3e01      	subs	r6, #1
100024a2:	0436      	lsls	r6, r6, #16

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
100024a4:	4335      	orrs	r5, r6
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
100024a6:	465b      	mov	r3, fp
100024a8:	615d      	str	r5, [r3, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
                    
    status = XMC_USIC_CH_STATUS_OK;
100024aa:	2000      	movs	r0, #0
100024ac:	e002      	b.n	100024b4 <XMC_USIC_CH_SetBaudrate+0x90>
  }
  else 
  {
    status = XMC_USIC_CH_STATUS_ERROR;
100024ae:	2001      	movs	r0, #1
100024b0:	e000      	b.n	100024b4 <XMC_USIC_CH_SetBaudrate+0x90>
100024b2:	2001      	movs	r0, #1
  }
  
  return status;
}
100024b4:	b003      	add	sp, #12
100024b6:	bc0c      	pop	{r2, r3}
100024b8:	4691      	mov	r9, r2
100024ba:	469b      	mov	fp, r3
100024bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
100024be:	46c0      	nop			; (mov r8, r8)
100024c0:	000003ff 	.word	0x000003ff
100024c4:	fc0080ef 	.word	0xfc0080ef

100024c8 <XMC_USIC_Enable>:
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
                   (service_request << (uint32_t)interrupt_node));
}

void XMC_USIC_Enable(XMC_USIC_t *const usic)
{
100024c8:	b508      	push	{r3, lr}
  if (usic == USIC0)
100024ca:	4b03      	ldr	r3, [pc, #12]	; (100024d8 <XMC_USIC_Enable+0x10>)
100024cc:	4298      	cmp	r0, r3
100024ce:	d102      	bne.n	100024d6 <XMC_USIC_Enable+0xe>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC0);
100024d0:	2008      	movs	r0, #8
100024d2:	f7ff fe75 	bl	100021c0 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif  
  else
  {
    XMC_ASSERT("USIC module not available", 0/*Always*/);
  }
}
100024d6:	bd08      	pop	{r3, pc}
100024d8:	48000008 	.word	0x48000008

100024dc <XMC_USIC_CH_Enable>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel)
{
100024dc:	b510      	push	{r4, lr}
100024de:	1c04      	adds	r4, r0, #0
  XMC_ASSERT("XMC_USIC_CH_Enable: channel not valid", XMC_USIC_IsChannelValid(channel));

  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
100024e0:	2390      	movs	r3, #144	; 0x90
100024e2:	05db      	lsls	r3, r3, #23
100024e4:	4298      	cmp	r0, r3
100024e6:	d002      	beq.n	100024ee <XMC_USIC_CH_Enable+0x12>
100024e8:	4b07      	ldr	r3, [pc, #28]	; (10002508 <XMC_USIC_CH_Enable+0x2c>)
100024ea:	4298      	cmp	r0, r3
100024ec:	d102      	bne.n	100024f4 <XMC_USIC_CH_Enable+0x18>
  {
    XMC_USIC_Enable(XMC_USIC0);
100024ee:	4807      	ldr	r0, [pc, #28]	; (1000250c <XMC_USIC_CH_Enable+0x30>)
100024f0:	f7ff ffea 	bl	100024c8 <XMC_USIC_Enable>
  {
    XMC_ASSERT("USIC module not available", 0U/*Always*/);
  }

  /* USIC channel switched on*/
  channel->KSCFG = (USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk);
100024f4:	2303      	movs	r3, #3
100024f6:	60e3      	str	r3, [r4, #12]
  while ((channel->KSCFG & USIC_CH_KSCFG_MODEN_Msk) == 0U)
100024f8:	68e3      	ldr	r3, [r4, #12]
100024fa:	07db      	lsls	r3, r3, #31
100024fc:	d5fc      	bpl.n	100024f8 <XMC_USIC_CH_Enable+0x1c>
  {
    /* Wait till the channel is enabled */
  }

  /* Set USIC channel in IDLE mode */
  channel->CCR &= (uint32_t)~USIC_CH_CCR_MODE_Msk;
100024fe:	6c23      	ldr	r3, [r4, #64]	; 0x40
10002500:	220f      	movs	r2, #15
10002502:	4393      	bics	r3, r2
10002504:	6423      	str	r3, [r4, #64]	; 0x40
}
10002506:	bd10      	pop	{r4, pc}
10002508:	48000200 	.word	0x48000200
1000250c:	48000008 	.word	0x48000008

10002510 <_init>:
  }
}

/* Init */
void _init(void)
{}
10002510:	4770      	bx	lr
10002512:	46c0      	nop			; (mov r8, r8)

10002514 <SysTick_Handler>:
volatile bool boService=true;
extern void ff_check_position( void );

volatile uint32_t Delay_x =0;
void SysTick_Handler(void)
{
10002514:	b508      	push	{r3, lr}
	if(Delay_x>0){
10002516:	4b07      	ldr	r3, [pc, #28]	; (10002534 <SysTick_Handler+0x20>)
10002518:	681b      	ldr	r3, [r3, #0]
1000251a:	2b00      	cmp	r3, #0
1000251c:	d003      	beq.n	10002526 <SysTick_Handler+0x12>
		Delay_x--;
1000251e:	4a05      	ldr	r2, [pc, #20]	; (10002534 <SysTick_Handler+0x20>)
10002520:	6813      	ldr	r3, [r2, #0]
10002522:	3b01      	subs	r3, #1
10002524:	6013      	str	r3, [r2, #0]
	}
	if(boService==false){
10002526:	4b04      	ldr	r3, [pc, #16]	; (10002538 <SysTick_Handler+0x24>)
10002528:	781b      	ldrb	r3, [r3, #0]
1000252a:	2b00      	cmp	r3, #0
1000252c:	d101      	bne.n	10002532 <SysTick_Handler+0x1e>
		ff_check_position();
1000252e:	f000 fab5 	bl	10002a9c <ff_check_position>
	}


}
10002532:	bd08      	pop	{r3, pc}
10002534:	2000061c 	.word	0x2000061c
10002538:	200005a1 	.word	0x200005a1

1000253c <SetUpGPIO>:


void SetUpGPIO(){
1000253c:	b5f0      	push	{r4, r5, r6, r7, lr}
1000253e:	b087      	sub	sp, #28
	 * P2.10
	 * P2.11
	 *
	 */

	XMC_GPIO_CONFIG_t pin_input_config_pullup =
10002540:	ac04      	add	r4, sp, #16
10002542:	4b41      	ldr	r3, [pc, #260]	; (10002648 <SetUpGPIO+0x10c>)
10002544:	1c22      	adds	r2, r4, #0
10002546:	cb03      	ldmia	r3!, {r0, r1}
10002548:	c203      	stmia	r2!, {r0, r1}
1000254a:	1c1e      	adds	r6, r3, #0
		{
		   .mode                = XMC_GPIO_MODE_INPUT_PULL_UP,
		   .input_hysteresis    = XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
		   .output_level        = XMC_GPIO_OUTPUT_LEVEL_LOW,
		};
	XMC_GPIO_Init(P2_4, &pin_input_config_pullup);
1000254c:	483f      	ldr	r0, [pc, #252]	; (1000264c <SetUpGPIO+0x110>)
1000254e:	2104      	movs	r1, #4
10002550:	1c22      	adds	r2, r4, #0
10002552:	f7ff fda9 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P2_5, &pin_input_config_pullup);
10002556:	483d      	ldr	r0, [pc, #244]	; (1000264c <SetUpGPIO+0x110>)
10002558:	2105      	movs	r1, #5
1000255a:	1c22      	adds	r2, r4, #0
1000255c:	f7ff fda4 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P2_6, &pin_input_config_pullup);
10002560:	483a      	ldr	r0, [pc, #232]	; (1000264c <SetUpGPIO+0x110>)
10002562:	2106      	movs	r1, #6
10002564:	1c22      	adds	r2, r4, #0
10002566:	f7ff fd9f 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P2_7, &pin_input_config_pullup);
1000256a:	4838      	ldr	r0, [pc, #224]	; (1000264c <SetUpGPIO+0x110>)
1000256c:	2107      	movs	r1, #7
1000256e:	1c22      	adds	r2, r4, #0
10002570:	f7ff fd9a 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P2_8, &pin_input_config_pullup);
10002574:	4835      	ldr	r0, [pc, #212]	; (1000264c <SetUpGPIO+0x110>)
10002576:	2108      	movs	r1, #8
10002578:	1c22      	adds	r2, r4, #0
1000257a:	f7ff fd95 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P2_9, &pin_input_config_pullup);
1000257e:	4833      	ldr	r0, [pc, #204]	; (1000264c <SetUpGPIO+0x110>)
10002580:	2109      	movs	r1, #9
10002582:	1c22      	adds	r2, r4, #0
10002584:	f7ff fd90 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P2_10, &pin_input_config_pullup);
10002588:	4830      	ldr	r0, [pc, #192]	; (1000264c <SetUpGPIO+0x110>)
1000258a:	210a      	movs	r1, #10
1000258c:	1c22      	adds	r2, r4, #0
1000258e:	f7ff fd8b 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P2_11, &pin_input_config_pullup);
10002592:	482e      	ldr	r0, [pc, #184]	; (1000264c <SetUpGPIO+0x110>)
10002594:	210b      	movs	r1, #11
10002596:	1c22      	adds	r2, r4, #0
10002598:	f7ff fd86 	bl	100020a8 <XMC_GPIO_Init>

	XMC_GPIO_CONFIG_t pin_output_config_push_pull =
1000259c:	ac02      	add	r4, sp, #8
1000259e:	1c23      	adds	r3, r4, #0
100025a0:	ce06      	ldmia	r6!, {r1, r2}
100025a2:	c306      	stmia	r3!, {r1, r2}
100025a4:	1c37      	adds	r7, r6, #0
			   .input_hysteresis    = XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
			   .output_level        = XMC_GPIO_OUTPUT_LEVEL_HIGH,
			};

	/* Output for Waveform Generation Flap Flap */
	XMC_GPIO_Init(P0_13, &pin_output_config_push_pull); /* !AD    */
100025a6:	4d2a      	ldr	r5, [pc, #168]	; (10002650 <SetUpGPIO+0x114>)
100025a8:	1c28      	adds	r0, r5, #0
100025aa:	210d      	movs	r1, #13
100025ac:	1c22      	adds	r2, r4, #0
100025ae:	f7ff fd7b 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P0_1, &pin_output_config_push_pull); /* !COL    */
100025b2:	1c28      	adds	r0, r5, #0
100025b4:	2101      	movs	r1, #1
100025b6:	1c22      	adds	r2, r4, #0
100025b8:	f7ff fd76 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P0_2, &pin_output_config_push_pull); /* !Start    */
100025bc:	1c28      	adds	r0, r5, #0
100025be:	2102      	movs	r1, #2
100025c0:	1c22      	adds	r2, r4, #0
100025c2:	f7ff fd71 	bl	100020a8 <XMC_GPIO_Init>

	/* LEDs */
   XMC_GPIO_Init(XMC_GPIO_PORT0,4, &pin_output_config_push_pull);
100025c6:	1c28      	adds	r0, r5, #0
100025c8:	2104      	movs	r1, #4
100025ca:	1c22      	adds	r2, r4, #0
100025cc:	f7ff fd6c 	bl	100020a8 <XMC_GPIO_Init>
   XMC_GPIO_Init(XMC_GPIO_PORT0,3, &pin_output_config_push_pull);
100025d0:	1c28      	adds	r0, r5, #0
100025d2:	2103      	movs	r1, #3
100025d4:	1c22      	adds	r2, r4, #0
100025d6:	f7ff fd67 	bl	100020a8 <XMC_GPIO_Init>


	/* Encoder Input */
	XMC_GPIO_CONFIG_t pin_input_config_inv_pullup =
100025da:	466b      	mov	r3, sp
100025dc:	cf06      	ldmia	r7!, {r1, r2}
100025de:	c306      	stmia	r3!, {r1, r2}
		   .mode                = XMC_GPIO_MODE_INPUT_INVERTED_PULL_UP,
		   .input_hysteresis    = XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
		   .output_level        = XMC_GPIO_OUTPUT_LEVEL_LOW,
		};

	XMC_GPIO_Init(P1_0, &pin_input_config_inv_pullup);
100025e0:	4f1c      	ldr	r7, [pc, #112]	; (10002654 <SetUpGPIO+0x118>)
100025e2:	1c38      	adds	r0, r7, #0
100025e4:	2100      	movs	r1, #0
100025e6:	466a      	mov	r2, sp
100025e8:	f7ff fd5e 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P1_1, &pin_input_config_inv_pullup);
100025ec:	1c38      	adds	r0, r7, #0
100025ee:	2101      	movs	r1, #1
100025f0:	466a      	mov	r2, sp
100025f2:	f7ff fd59 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P1_2, &pin_input_config_inv_pullup);
100025f6:	1c38      	adds	r0, r7, #0
100025f8:	2102      	movs	r1, #2
100025fa:	466a      	mov	r2, sp
100025fc:	f7ff fd54 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P1_3, &pin_input_config_inv_pullup);
10002600:	1c38      	adds	r0, r7, #0
10002602:	2103      	movs	r1, #3
10002604:	466a      	mov	r2, sp
10002606:	f7ff fd4f 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P1_4, &pin_input_config_inv_pullup);
1000260a:	1c38      	adds	r0, r7, #0
1000260c:	2104      	movs	r1, #4
1000260e:	466a      	mov	r2, sp
10002610:	f7ff fd4a 	bl	100020a8 <XMC_GPIO_Init>
	XMC_GPIO_Init(P1_5, &pin_input_config_inv_pullup);
10002614:	1c38      	adds	r0, r7, #0
10002616:	2105      	movs	r1, #5
10002618:	466a      	mov	r2, sp
1000261a:	f7ff fd45 	bl	100020a8 <XMC_GPIO_Init>


	/* TX Init */
	XMC_GPIO_Init(P2_2, &pin_output_config_push_pull);
1000261e:	480b      	ldr	r0, [pc, #44]	; (1000264c <SetUpGPIO+0x110>)
10002620:	2102      	movs	r1, #2
10002622:	1c22      	adds	r2, r4, #0
10002624:	f7ff fd40 	bl	100020a8 <XMC_GPIO_Init>
10002628:	2380      	movs	r3, #128	; 0x80
1000262a:	019b      	lsls	r3, r3, #6
1000262c:	606b      	str	r3, [r5, #4]
1000262e:	2302      	movs	r3, #2
10002630:	606b      	str	r3, [r5, #4]
10002632:	3302      	adds	r3, #2
10002634:	606b      	str	r3, [r5, #4]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
10002636:	2380      	movs	r3, #128	; 0x80
10002638:	031b      	lsls	r3, r3, #12
1000263a:	606b      	str	r3, [r5, #4]

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
1000263c:	2310      	movs	r3, #16
1000263e:	606b      	str	r3, [r5, #4]

	/* Disable TX  */
	XMC_GPIO_SetOutputLow(P0_3);
	XMC_GPIO_SetOutputHigh(P0_4);

	ff_setup();
10002640:	f000 fa20 	bl	10002a84 <ff_setup>
}
10002644:	b007      	add	sp, #28
10002646:	bdf0      	pop	{r4, r5, r6, r7, pc}
10002648:	10002fcc 	.word	0x10002fcc
1000264c:	40040200 	.word	0x40040200
10002650:	40040000 	.word	0x40040000
10002654:	40040100 	.word	0x40040100

10002658 <ReverseBits>:
  .idiv = 1,  /**MCLK = 32MHz */
};

unsigned char ReverseBits(uint8_t v)
{
    v = ((v >> 1) & 0x55) | ((v & 0x55) << 1);
10002658:	2255      	movs	r2, #85	; 0x55
1000265a:	1c13      	adds	r3, r2, #0
1000265c:	4003      	ands	r3, r0
1000265e:	005b      	lsls	r3, r3, #1
10002660:	0840      	lsrs	r0, r0, #1
10002662:	4010      	ands	r0, r2
10002664:	4318      	orrs	r0, r3
    v = ((v >> 2) & 0x33) | ((v & 0x33) << 2);
10002666:	3a22      	subs	r2, #34	; 0x22
10002668:	1c13      	adds	r3, r2, #0
1000266a:	4003      	ands	r3, r0
1000266c:	009b      	lsls	r3, r3, #2
1000266e:	0880      	lsrs	r0, r0, #2
10002670:	4010      	ands	r0, r2
10002672:	4318      	orrs	r0, r3
    v = ((v >> 4) & 0x0F) | ((v & 0x0F) << 4);
10002674:	0103      	lsls	r3, r0, #4
10002676:	0900      	lsrs	r0, r0, #4
10002678:	4318      	orrs	r0, r3
1000267a:	b2c0      	uxtb	r0, r0
    return v;
}
1000267c:	4770      	bx	lr
1000267e:	46c0      	nop			; (mov r8, r8)

10002680 <ReadDipSwitch>:

uint8_t ReadDipSwitch( void ){
10002680:	b508      	push	{r3, lr}

uint8_t Value = ((PORT2->IN & 0x00000FF0)>>4);
10002682:	4b04      	ldr	r3, [pc, #16]	; (10002694 <ReadDipSwitch+0x14>)
10002684:	6a58      	ldr	r0, [r3, #36]	; 0x24
10002686:	0500      	lsls	r0, r0, #20
10002688:	0e00      	lsrs	r0, r0, #24
/* Change bits as someone may need to read more */
Value=ReverseBits(Value);
1000268a:	f7ff ffe5 	bl	10002658 <ReverseBits>
Value=~Value;
1000268e:	43c0      	mvns	r0, r0
10002690:	b2c0      	uxtb	r0, r0
return Value;

}
10002692:	bd08      	pop	{r3, pc}
10002694:	40040200 	.word	0x40040200

10002698 <__delay_ms>:

void __delay_ms(uint32_t d){

	while(Delay_x!=d){
10002698:	e001      	b.n	1000269e <__delay_ms+0x6>
		  Delay_x=d;
1000269a:	4b06      	ldr	r3, [pc, #24]	; (100026b4 <__delay_ms+0x1c>)
1000269c:	6018      	str	r0, [r3, #0]

}

void __delay_ms(uint32_t d){

	while(Delay_x!=d){
1000269e:	4b05      	ldr	r3, [pc, #20]	; (100026b4 <__delay_ms+0x1c>)
100026a0:	681b      	ldr	r3, [r3, #0]
100026a2:	4283      	cmp	r3, r0
100026a4:	d1f9      	bne.n	1000269a <__delay_ms+0x2>
100026a6:	e000      	b.n	100026aa <__delay_ms+0x12>
		  Delay_x=d;
	  }

	  while(Delay_x>0){
		  __NOP();
100026a8:	46c0      	nop			; (mov r8, r8)

	while(Delay_x!=d){
		  Delay_x=d;
	  }

	  while(Delay_x>0){
100026aa:	4b02      	ldr	r3, [pc, #8]	; (100026b4 <__delay_ms+0x1c>)
100026ac:	681b      	ldr	r3, [r3, #0]
100026ae:	2b00      	cmp	r3, #0
100026b0:	d1fa      	bne.n	100026a8 <__delay_ms+0x10>
		  __NOP();
	  }

}
100026b2:	4770      	bx	lr
100026b4:	2000061c 	.word	0x2000061c

100026b8 <main>:
volatile uint8_t u8Address=0;
int main(void)
{
100026b8:	b530      	push	{r4, r5, lr}
100026ba:	b083      	sub	sp, #12
	uint32_t Delay = 0xFFFF;
	uint8_t u8DIPSwitch=0;
	/* Ensure clock frequency is set at 64MHz (MCLK) */
	XMC_SCU_CLOCK_Init(&clock_config);
100026bc:	4848      	ldr	r0, [pc, #288]	; (100027e0 <main+0x128>)
100026be:	f7ff fdc9 	bl	10002254 <XMC_SCU_CLOCK_Init>

	/* Ensure fCCU reaches CCU40 */
		XMC_CCU4_SetModuleClock(MODULE_PTR, XMC_CCU4_CLOCK_SCU);
100026c2:	4c48      	ldr	r4, [pc, #288]	; (100027e4 <main+0x12c>)
100026c4:	1c20      	adds	r0, r4, #0
100026c6:	2100      	movs	r1, #0
100026c8:	f7ff fe00 	bl	100022cc <XMC_CCU4_SetModuleClock>
		XMC_CCU4_Init(MODULE_PTR, XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
100026cc:	1c20      	adds	r0, r4, #0
100026ce:	2100      	movs	r1, #0
100026d0:	f7ff fde8 	bl	100022a4 <XMC_CCU4_Init>
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1) << slice_number;
100026d4:	68e2      	ldr	r2, [r4, #12]
100026d6:	2301      	movs	r3, #1
100026d8:	4313      	orrs	r3, r2
100026da:	60e3      	str	r3, [r4, #12]
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
100026dc:	68e3      	ldr	r3, [r4, #12]
100026de:	2280      	movs	r2, #128	; 0x80
100026e0:	0052      	lsls	r2, r2, #1
100026e2:	4313      	orrs	r3, r2
100026e4:	60e3      	str	r3, [r4, #12]

		/* Start the prescaler and restore clocks to slices */
		XMC_CCU4_StartPrescaler(MODULE_PTR);

		/* Initialize the Slice */
		XMC_CCU4_SLICE_CompareInit(SLICE_PTR, &compare_config);
100026e6:	4d40      	ldr	r5, [pc, #256]	; (100027e8 <main+0x130>)
100026e8:	1c28      	adds	r0, r5, #0
100026ea:	4940      	ldr	r1, [pc, #256]	; (100027ec <main+0x134>)
100026ec:	f7ff fdf6 	bl	100022dc <XMC_CCU4_SLICE_CompareInit>
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
                                                const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
100026f0:	22a4      	movs	r2, #164	; 0xa4
100026f2:	58a9      	ldr	r1, [r5, r2]
100026f4:	2304      	movs	r3, #4
100026f6:	430b      	orrs	r3, r1
100026f8:	50ab      	str	r3, [r5, r2]

		/* Enable compare match events */
		XMC_CCU4_SLICE_EnableEvent(SLICE_PTR, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);

	    /* Connect compare match event to SR0 */
		XMC_CCU4_SLICE_SetInterruptNode(SLICE_PTR, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP, XMC_CCU4_SLICE_SR_ID_0);
100026fa:	1c28      	adds	r0, r5, #0
100026fc:	2102      	movs	r1, #2
100026fe:	2200      	movs	r2, #0
10002700:	f7ff fe04 	bl	1000230c <XMC_CCU4_SLICE_SetInterruptNode>
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002704:	4a3a      	ldr	r2, [pc, #232]	; (100027f0 <main+0x138>)
10002706:	21c5      	movs	r1, #197	; 0xc5
10002708:	0089      	lsls	r1, r1, #2
1000270a:	5850      	ldr	r0, [r2, r1]
1000270c:	4b39      	ldr	r3, [pc, #228]	; (100027f4 <main+0x13c>)
1000270e:	4003      	ands	r3, r0
10002710:	20c0      	movs	r0, #192	; 0xc0
10002712:	0200      	lsls	r0, r0, #8
10002714:	4303      	orrs	r3, r0
10002716:	5053      	str	r3, [r2, r1]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
10002718:	2380      	movs	r3, #128	; 0x80
1000271a:	039b      	lsls	r3, r3, #14
1000271c:	6013      	str	r3, [r2, #0]
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
1000271e:	237f      	movs	r3, #127	; 0x7f
10002720:	63eb      	str	r3, [r5, #60]	; 0x3c
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
10002722:	636b      	str	r3, [r5, #52]	; 0x34
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
10002724:	3b7a      	subs	r3, #122	; 0x7a
10002726:	6123      	str	r3, [r4, #16]





  SetUpGPIO();
10002728:	f7ff ff08 	bl	1000253c <SetUpGPIO>


  MB_register_UART(XMC_UART0_CH0);
1000272c:	2090      	movs	r0, #144	; 0x90
1000272e:	05c0      	lsls	r0, r0, #23
10002730:	f7fe fcda 	bl	100010e8 <MB_register_UART>
  SysTick_Config(SystemCoreClock / TICKS_PER_SECOND);
10002734:	4b30      	ldr	r3, [pc, #192]	; (100027f8 <main+0x140>)
10002736:	6818      	ldr	r0, [r3, #0]
10002738:	21fa      	movs	r1, #250	; 0xfa
1000273a:	0089      	lsls	r1, r1, #2
1000273c:	f000 fa66 	bl	10002c0c <__aeabi_uidiv>
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
10002740:	3801      	subs	r0, #1
10002742:	4b2e      	ldr	r3, [pc, #184]	; (100027fc <main+0x144>)
10002744:	4298      	cmp	r0, r3
10002746:	d80d      	bhi.n	10002764 <main+0xac>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
10002748:	4a2d      	ldr	r2, [pc, #180]	; (10002800 <main+0x148>)
1000274a:	6050      	str	r0, [r2, #4]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1000274c:	492d      	ldr	r1, [pc, #180]	; (10002804 <main+0x14c>)
1000274e:	6a0b      	ldr	r3, [r1, #32]
10002750:	021b      	lsls	r3, r3, #8
10002752:	0a1b      	lsrs	r3, r3, #8
10002754:	20c0      	movs	r0, #192	; 0xc0
10002756:	0600      	lsls	r0, r0, #24
10002758:	4303      	orrs	r3, r0
1000275a:	620b      	str	r3, [r1, #32]
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
1000275c:	2300      	movs	r3, #0
1000275e:	6093      	str	r3, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
10002760:	3307      	adds	r3, #7
10002762:	6013      	str	r3, [r2, #0]
  /* Address of 0 disabels the device */
  __delay_ms(250);
10002764:	20fa      	movs	r0, #250	; 0xfa
10002766:	f7ff ff97 	bl	10002698 <__delay_ms>
  do{
	  u8DIPSwitch = ReadDipSwitch();
1000276a:	f7ff ff89 	bl	10002680 <ReadDipSwitch>
1000276e:	1c03      	adds	r3, r0, #0
  }
  while(0==(u8DIPSwitch&0x3F));
10002770:	223f      	movs	r2, #63	; 0x3f
10002772:	4010      	ands	r0, r2
10002774:	d0f9      	beq.n	1000276a <main+0xb2>
  if(0!=(u8DIPSwitch&0x80)){
10002776:	061a      	lsls	r2, r3, #24
10002778:	d50f      	bpl.n	1000279a <main+0xe2>
	  /* We enter the Testmode Position will be set by DIP Switch */
	  if(u8DIPSwitch&0x40){
1000277a:	065b      	lsls	r3, r3, #25
1000277c:	d503      	bpl.n	10002786 <main+0xce>
		  voService();
1000277e:	f000 fa39 	bl	10002bf4 <voService>
		  while(1==1){
		  __NOP();
10002782:	46c0      	nop			; (mov r8, r8)
		  }
10002784:	e7fd      	b.n	10002782 <main+0xca>
	  } else{
		  boService=false;
10002786:	2200      	movs	r2, #0
10002788:	4b1f      	ldr	r3, [pc, #124]	; (10002808 <main+0x150>)
1000278a:	701a      	strb	r2, [r3, #0]
		  while(1==1){
			  /* We Read the Dipswitch and Write the Position */
			  u8DIPSwitch = ReadDipSwitch();
1000278c:	f7ff ff78 	bl	10002680 <ReadDipSwitch>
			  voManualSetPosition((u8DIPSwitch&0x3F));
10002790:	233f      	movs	r3, #63	; 0x3f
10002792:	4018      	ands	r0, r3
10002794:	f000 fa26 	bl	10002be4 <voManualSetPosition>
		  }
10002798:	e7f8      	b.n	1000278c <main+0xd4>
	  }


  } else {
	  boService=false;
1000279a:	2300      	movs	r3, #0
1000279c:	4a1a      	ldr	r2, [pc, #104]	; (10002808 <main+0x150>)
1000279e:	7013      	strb	r3, [r2, #0]
	  u8Address = u8DIPSwitch&0x3F;
100027a0:	4a1a      	ldr	r2, [pc, #104]	; (1000280c <main+0x154>)
100027a2:	7010      	strb	r0, [r2, #0]
	  eMBInit(MB_RTU,u8Address,0,115200,MB_PAR_NONE);
100027a4:	7811      	ldrb	r1, [r2, #0]
100027a6:	b2c9      	uxtb	r1, r1
100027a8:	9300      	str	r3, [sp, #0]
100027aa:	2000      	movs	r0, #0
100027ac:	2200      	movs	r2, #0
100027ae:	23e1      	movs	r3, #225	; 0xe1
100027b0:	025b      	lsls	r3, r3, #9
100027b2:	f7ff faf3 	bl	10001d9c <eMBInit>
	  eMBEnable();
100027b6:	f7ff fb85 	bl	10001ec4 <eMBEnable>
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
100027ba:	4b0d      	ldr	r3, [pc, #52]	; (100027f0 <main+0x138>)
100027bc:	2280      	movs	r2, #128	; 0x80
100027be:	0092      	lsls	r2, r2, #2
100027c0:	21c0      	movs	r1, #192	; 0xc0
100027c2:	0049      	lsls	r1, r1, #1
100027c4:	505a      	str	r2, [r3, r1]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
100027c6:	601a      	str	r2, [r3, #0]

}
volatile uint8_t u8Address=0;
int main(void)
{
	uint32_t Delay = 0xFFFF;
100027c8:	4c11      	ldr	r4, [pc, #68]	; (10002810 <main+0x158>)
	  NVIC_ClearPendingIRQ(USIC0_0_IRQn);
	  NVIC_EnableIRQ(USIC0_0_IRQn);
	  while(1)
	  {
		/* Infinite loop */
		  if(Delay>0){
100027ca:	2c00      	cmp	r4, #0
100027cc:	d001      	beq.n	100027d2 <main+0x11a>
			  Delay--;
100027ce:	3c01      	subs	r4, #1
100027d0:	e003      	b.n	100027da <main+0x122>

__STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10001U << pin;
100027d2:	4a10      	ldr	r2, [pc, #64]	; (10002814 <main+0x15c>)
100027d4:	4b10      	ldr	r3, [pc, #64]	; (10002818 <main+0x160>)
100027d6:	605a      	str	r2, [r3, #4]
		  }else{
			  XMC_GPIO_ToggleOutput(XMC_GPIO_PORT0,4);
			  Delay=0xFFFF;
100027d8:	4c0d      	ldr	r4, [pc, #52]	; (10002810 <main+0x158>)
		  }
		  mb_stack_task();
100027da:	f000 f921 	bl	10002a20 <mb_stack_task>
	  }
100027de:	e7f4      	b.n	100027ca <main+0x112>
100027e0:	10002fe4 	.word	0x10002fe4
100027e4:	48040000 	.word	0x48040000
100027e8:	48040100 	.word	0x48040100
100027ec:	200005a4 	.word	0x200005a4
100027f0:	e000e100 	.word	0xe000e100
100027f4:	ffff00ff 	.word	0xffff00ff
100027f8:	20003ffc 	.word	0x20003ffc
100027fc:	00ffffff 	.word	0x00ffffff
10002800:	e000e010 	.word	0xe000e010
10002804:	e000ed00 	.word	0xe000ed00
10002808:	200005a1 	.word	0x200005a1
1000280c:	20000618 	.word	0x20000618
10002810:	0000ffff 	.word	0x0000ffff
10002814:	00100010 	.word	0x00100010
10002818:	40040000 	.word	0x40040000

1000281c <USIC0_0_IRQHandler>:
}
void Default_handler( void ){
/* We shall never end here */
}

void USIC0_0_IRQHandler ( void ){
1000281c:	b510      	push	{r4, lr}
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_EnableEvent(),  XMC_UART_CH_ClearStatusFlag()\n\n\n
 */
__STATIC_INLINE uint32_t XMC_UART_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
{
  return channel->PSR_ASCMode;
1000281e:	2390      	movs	r3, #144	; 0x90
10002820:	05db      	lsls	r3, r3, #23
10002822:	6c9c      	ldr	r4, [r3, #72]	; 0x48

/* This can be called by diffetent Sources therfore we need to determine witch */
uint32_t status = XMC_UART_CH_GetStatusFlag( XMC_UART0_CH0 );

    // Did we receive data?
    if ((status & (XMC_UART_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION | XMC_UART_CH_STATUS_FLAG_RECEIVE_INDICATION)) != 0U)
10002824:	23c0      	movs	r3, #192	; 0xc0
10002826:	021b      	lsls	r3, r3, #8
10002828:	421c      	tst	r4, r3
1000282a:	d009      	beq.n	10002840 <USIC0_0_IRQHandler+0x24>
    {
    	/* We need to add the correct callback here */
    	MB_RxHandler();
1000282c:	f7fe fd08 	bl	10001240 <MB_RxHandler>
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_DisableEvent(),  XMC_UART_CH_GetStatusFlag()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, const uint32_t flag)
{
  channel->PSCR = flag;
10002830:	2390      	movs	r3, #144	; 0x90
10002832:	05db      	lsls	r3, r3, #23
10002834:	2280      	movs	r2, #128	; 0x80
10002836:	0212      	lsls	r2, r2, #8
10002838:	64da      	str	r2, [r3, #76]	; 0x4c
1000283a:	2280      	movs	r2, #128	; 0x80
1000283c:	01d2      	lsls	r2, r2, #7
1000283e:	64da      	str	r2, [r3, #76]	; 0x4c
    	XMC_UART_CH_ClearStatusFlag(XMC_UART0_CH0, XMC_UART_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION );
    	XMC_UART_CH_ClearStatusFlag(XMC_UART0_CH0, XMC_UART_CH_STATUS_FLAG_RECEIVE_INDICATION);
    }

    /* Transmission in Progress ? */
    if (( status & ( XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION)) != 0U){
10002840:	04a3      	lsls	r3, r4, #18
10002842:	d504      	bpl.n	1000284e <USIC0_0_IRQHandler+0x32>
10002844:	2280      	movs	r2, #128	; 0x80
10002846:	0192      	lsls	r2, r2, #6
10002848:	2390      	movs	r3, #144	; 0x90
1000284a:	05db      	lsls	r3, r3, #23
1000284c:	64da      	str	r2, [r3, #76]	; 0x4c
    	 XMC_UART_CH_ClearStatusFlag(XMC_UART0_CH0, XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    }

    /* Transmitt finished */
    if ((status & ( XMC_UART_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION)) != 0U){
1000284e:	04e3      	lsls	r3, r4, #19
10002850:	d506      	bpl.n	10002860 <USIC0_0_IRQHandler+0x44>
10002852:	2280      	movs	r2, #128	; 0x80
10002854:	0152      	lsls	r2, r2, #5
10002856:	2390      	movs	r3, #144	; 0x90
10002858:	05db      	lsls	r3, r3, #23
1000285a:	64da      	str	r2, [r3, #76]	; 0x4c
    	/* We can if requiered refill data to the buffer */
    	XMC_UART_CH_ClearStatusFlag(XMC_UART0_CH0, XMC_UART_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION);
    	MB_TxHandler();
1000285c:	f7fe fcf8 	bl	10001250 <MB_TxHandler>
    }

	if ((status & ( XMC_UART_CH_STATUS_FLAG_TRANSMITTER_FRAME_FINISHED)) != 0U){
10002860:	05e3      	lsls	r3, r4, #23
10002862:	d504      	bpl.n	1000286e <USIC0_0_IRQHandler+0x52>
10002864:	2280      	movs	r2, #128	; 0x80
10002866:	0052      	lsls	r2, r2, #1
10002868:	2390      	movs	r3, #144	; 0x90
1000286a:	05db      	lsls	r3, r3, #23
1000286c:	64da      	str	r2, [r3, #76]	; 0x4c
	    	/* We can if requiered refill data to the buffer */
	    	XMC_UART_CH_ClearStatusFlag(XMC_UART0_CH0, XMC_UART_CH_STATUS_FLAG_TRANSMITTER_FRAME_FINISHED);

	}

}
1000286e:	bd10      	pop	{r4, pc}

10002870 <eMBRegInputCB>:
eMBErrorCode eMBRegInputCB( uint8_t *buffer, uint16_t address, uint16_t count )
{
  eMBErrorCode status = MB_ENOERR;
  uint16_t     register_index;

  if (( address >= (uint16_t)REG_INPUT_START_ADDR )
10002870:	2900      	cmp	r1, #0
10002872:	d00f      	beq.n	10002894 <eMBRegInputCB+0x24>
     && ( (uint16_t)(address + count) <= (uint16_t)(REG_INPUT_START_ADDR + REG_INPUT_COUNT) ))
10002874:	1889      	adds	r1, r1, r2
10002876:	b289      	uxth	r1, r1
10002878:	2905      	cmp	r1, #5
1000287a:	d907      	bls.n	1000288c <eMBRegInputCB+0x1c>
      count--;
    }
  }
  else
  {
    status = MB_ENOREG;
1000287c:	2001      	movs	r0, #1
1000287e:	e00a      	b.n	10002896 <eMBRegInputCB+0x26>
  {
    register_index = ( uint16_t )( address - REG_INPUT_START_ADDR );
    while( count > 0U )
    {
      /* Pass current register values to the protocol stack. */
      *buffer = ( uint8_t )( reg_input_buffer[register_index] >> 8 );
10002880:	2300      	movs	r3, #0
10002882:	7003      	strb	r3, [r0, #0]
      buffer++;
      *buffer = ( uint8_t )( reg_input_buffer[register_index] & 0xFFU );
10002884:	7043      	strb	r3, [r0, #1]
      buffer++;
10002886:	3002      	adds	r0, #2
      register_index++;
      count--;
10002888:	3a01      	subs	r2, #1
1000288a:	b292      	uxth	r2, r2

  if (( address >= (uint16_t)REG_INPUT_START_ADDR )
     && ( (uint16_t)(address + count) <= (uint16_t)(REG_INPUT_START_ADDR + REG_INPUT_COUNT) ))
  {
    register_index = ( uint16_t )( address - REG_INPUT_START_ADDR );
    while( count > 0U )
1000288c:	2a00      	cmp	r2, #0
1000288e:	d1f7      	bne.n	10002880 <eMBRegInputCB+0x10>
 *           MB_ENOREG if failure (illegal register access)
 *
 * */
eMBErrorCode eMBRegInputCB( uint8_t *buffer, uint16_t address, uint16_t count )
{
  eMBErrorCode status = MB_ENOERR;
10002890:	2000      	movs	r0, #0
10002892:	e000      	b.n	10002896 <eMBRegInputCB+0x26>
      count--;
    }
  }
  else
  {
    status = MB_ENOREG;
10002894:	2001      	movs	r0, #1
  }
  return status;
}
10002896:	4770      	bx	lr

10002898 <eMBRegHoldingCB>:
 * @return:  MB_ENOERR if success
 *           MB_ENOREG if failure (illegal register access)
 *
 * */
eMBErrorCode eMBRegHoldingCB( uint8_t *buffer, uint16_t address, uint16_t count, eMBRegisterMode mode )
{
10002898:	b570      	push	{r4, r5, r6, lr}
  eMBErrorCode status = MB_ENOERR;
  uint16_t register_index;

  if ( ( address >= REG_HOLDING_START_ADDR ) &&
     ( (uint16_t)(address + count) <= (uint16_t)(REG_HOLDING_START_ADDR + REG_HOLDING_COUNT)) )
1000289a:	188c      	adds	r4, r1, r2
1000289c:	b2a4      	uxth	r4, r4
eMBErrorCode eMBRegHoldingCB( uint8_t *buffer, uint16_t address, uint16_t count, eMBRegisterMode mode )
{
  eMBErrorCode status = MB_ENOERR;
  uint16_t register_index;

  if ( ( address >= REG_HOLDING_START_ADDR ) &&
1000289e:	2c04      	cmp	r4, #4
100028a0:	d82f      	bhi.n	10002902 <eMBRegHoldingCB+0x6a>
     ( (uint16_t)(address + count) <= (uint16_t)(REG_HOLDING_START_ADDR + REG_HOLDING_COUNT)) )
  {
    register_index = ( uint16_t )( address - REG_HOLDING_START_ADDR );
    switch ( mode )
100028a2:	2b00      	cmp	r3, #0
100028a4:	d002      	beq.n	100028ac <eMBRegHoldingCB+0x14>
100028a6:	2b01      	cmp	r3, #1
100028a8:	d027      	beq.n	100028fa <eMBRegHoldingCB+0x62>
100028aa:	e02c      	b.n	10002906 <eMBRegHoldingCB+0x6e>
    {
      /* Pass current register values to the protocol stack. */
      case MB_REG_READ:
    	if(register_index>0){
100028ac:	2900      	cmp	r1, #0
100028ae:	d00e      	beq.n	100028ce <eMBRegHoldingCB+0x36>
    		register_index--;
100028b0:	3901      	subs	r1, #1
100028b2:	b289      	uxth	r1, r1
100028b4:	e00b      	b.n	100028ce <eMBRegHoldingCB+0x36>
    	}
        while( count > 0U )
        {
          *buffer = (uint8_t)( reg_holding_buffer[register_index] >> 8 );
100028b6:	4c15      	ldr	r4, [pc, #84]	; (1000290c <eMBRegHoldingCB+0x74>)
100028b8:	004d      	lsls	r5, r1, #1
100028ba:	5b2b      	ldrh	r3, [r5, r4]
100028bc:	0a1b      	lsrs	r3, r3, #8
100028be:	7003      	strb	r3, [r0, #0]
          buffer++;
          *buffer = (uint8_t)( reg_holding_buffer[register_index] & 0xFFU );
100028c0:	5b2b      	ldrh	r3, [r5, r4]
100028c2:	7043      	strb	r3, [r0, #1]
          buffer++;
100028c4:	3002      	adds	r0, #2
          register_index++;
100028c6:	3101      	adds	r1, #1
100028c8:	b289      	uxth	r1, r1
          count--;
100028ca:	3a01      	subs	r2, #1
100028cc:	b292      	uxth	r2, r2
      /* Pass current register values to the protocol stack. */
      case MB_REG_READ:
    	if(register_index>0){
    		register_index--;
    	}
        while( count > 0U )
100028ce:	2a00      	cmp	r2, #0
100028d0:	d1f1      	bne.n	100028b6 <eMBRegHoldingCB+0x1e>
 *           MB_ENOREG if failure (illegal register access)
 *
 * */
eMBErrorCode eMBRegHoldingCB( uint8_t *buffer, uint16_t address, uint16_t count, eMBRegisterMode mode )
{
  eMBErrorCode status = MB_ENOERR;
100028d2:	2000      	movs	r0, #0
100028d4:	e018      	b.n	10002908 <eMBRegHoldingCB+0x70>
      /* Update current register values with new values from the
       * protocol stack. */
      case MB_REG_WRITE:
        while( count > 0U )
        {
          if(register_index>0){
100028d6:	2900      	cmp	r1, #0
100028d8:	d001      	beq.n	100028de <eMBRegHoldingCB+0x46>
        	  register_index--;
100028da:	3901      	subs	r1, #1
100028dc:	b289      	uxth	r1, r1
          }
          reg_holding_buffer[register_index] = (uint16_t)((uint16_t)*buffer << 8);
100028de:	7805      	ldrb	r5, [r0, #0]
100028e0:	022d      	lsls	r5, r5, #8
100028e2:	4b0a      	ldr	r3, [pc, #40]	; (1000290c <eMBRegHoldingCB+0x74>)
100028e4:	004c      	lsls	r4, r1, #1
100028e6:	52e5      	strh	r5, [r4, r3]
          buffer++;
          reg_holding_buffer[register_index] |= *buffer;
100028e8:	5ae6      	ldrh	r6, [r4, r3]
100028ea:	7845      	ldrb	r5, [r0, #1]
100028ec:	4335      	orrs	r5, r6
100028ee:	52e5      	strh	r5, [r4, r3]
          buffer++;
100028f0:	3002      	adds	r0, #2
          register_index++;
100028f2:	3101      	adds	r1, #1
100028f4:	b289      	uxth	r1, r1
          count--;
100028f6:	3a01      	subs	r2, #1
100028f8:	b292      	uxth	r2, r2
        }
        break;
      /* Update current register values with new values from the
       * protocol stack. */
      case MB_REG_WRITE:
        while( count > 0U )
100028fa:	2a00      	cmp	r2, #0
100028fc:	d1eb      	bne.n	100028d6 <eMBRegHoldingCB+0x3e>
 *           MB_ENOREG if failure (illegal register access)
 *
 * */
eMBErrorCode eMBRegHoldingCB( uint8_t *buffer, uint16_t address, uint16_t count, eMBRegisterMode mode )
{
  eMBErrorCode status = MB_ENOERR;
100028fe:	2000      	movs	r0, #0
10002900:	e002      	b.n	10002908 <eMBRegHoldingCB+0x70>
        break;
    }
  }
  else
  {
      status = MB_ENOREG;
10002902:	2001      	movs	r0, #1
10002904:	e000      	b.n	10002908 <eMBRegHoldingCB+0x70>
          register_index++;
          count--;
        }
        break;
      default:
        status = MB_ENOREG;
10002906:	2001      	movs	r0, #1
  else
  {
      status = MB_ENOREG;
  }
  return status;
}
10002908:	bd70      	pop	{r4, r5, r6, pc}
1000290a:	46c0      	nop			; (mov r8, r8)
1000290c:	20000630 	.word	0x20000630

10002910 <eMBRegCoilsCB>:
 * @return:  MB_ENOERR if success
 *           MB_ENOREG if failure (illegal register access)
 *
 * */
eMBErrorCode eMBRegCoilsCB( uint8_t *buffer, uint16_t address, uint16_t count, eMBRegisterMode mode )
{
10002910:	b570      	push	{r4, r5, r6, lr}
10002912:	1c06      	adds	r6, r0, #0
  eMBErrorCode status = MB_ENOERR;
  int16_t signed_count = (int16_t)count;
10002914:	b295      	uxth	r5, r2
  uint16_t bit_offset;

  /* Check if we have registers mapped at this block. */
  if( ( address >= REG_COILS_START_ADDR ) &&
10002916:	4825      	ldr	r0, [pc, #148]	; (100029ac <eMBRegCoilsCB+0x9c>)
10002918:	4281      	cmp	r1, r0
1000291a:	d941      	bls.n	100029a0 <eMBRegCoilsCB+0x90>
      ( (uint16_t)(address + count) <= (uint16_t)(REG_COILS_START_ADDR + REG_COILS_COUNT)) )
1000291c:	188a      	adds	r2, r1, r2
1000291e:	b292      	uxth	r2, r2
  eMBErrorCode status = MB_ENOERR;
  int16_t signed_count = (int16_t)count;
  uint16_t bit_offset;

  /* Check if we have registers mapped at this block. */
  if( ( address >= REG_COILS_START_ADDR ) &&
10002920:	3009      	adds	r0, #9
10002922:	4282      	cmp	r2, r0
10002924:	d83e      	bhi.n	100029a4 <eMBRegCoilsCB+0x94>
      ( (uint16_t)(address + count) <= (uint16_t)(REG_COILS_START_ADDR + REG_COILS_COUNT)) )
  {
    bit_offset = ( uint16_t )( address - REG_COILS_START_ADDR );
10002926:	4a22      	ldr	r2, [pc, #136]	; (100029b0 <eMBRegCoilsCB+0xa0>)
10002928:	4694      	mov	ip, r2
1000292a:	4461      	add	r1, ip
1000292c:	b28c      	uxth	r4, r1
    switch ( mode )
1000292e:	2b00      	cmp	r3, #0
10002930:	d017      	beq.n	10002962 <eMBRegCoilsCB+0x52>
10002932:	2b01      	cmp	r3, #1
10002934:	d02f      	beq.n	10002996 <eMBRegCoilsCB+0x86>
10002936:	e037      	b.n	100029a8 <eMBRegCoilsCB+0x98>
    {
      /* Read current values and pass to protocol stack. */
      case MB_REG_READ:
        while( signed_count > 0 )
        {
          if (signed_count > 8)
10002938:	b22b      	sxth	r3, r5
1000293a:	2b08      	cmp	r3, #8
1000293c:	dd06      	ble.n	1000294c <eMBRegCoilsCB+0x3c>
          {
            *buffer = xMBUtilGetBits( reg_coils_buffers, bit_offset, 8U);
1000293e:	481d      	ldr	r0, [pc, #116]	; (100029b4 <eMBRegCoilsCB+0xa4>)
10002940:	1c21      	adds	r1, r4, #0
10002942:	2208      	movs	r2, #8
10002944:	f7ff f824 	bl	10001990 <xMBUtilGetBits>
10002948:	7030      	strb	r0, [r6, #0]
1000294a:	e005      	b.n	10002958 <eMBRegCoilsCB+0x48>
          }
          else
          {
            *buffer = xMBUtilGetBits( reg_coils_buffers, bit_offset, (uint8_t)signed_count);
1000294c:	b2ea      	uxtb	r2, r5
1000294e:	4819      	ldr	r0, [pc, #100]	; (100029b4 <eMBRegCoilsCB+0xa4>)
10002950:	1c21      	adds	r1, r4, #0
10002952:	f7ff f81d 	bl	10001990 <xMBUtilGetBits>
10002956:	7030      	strb	r0, [r6, #0]
          }
          buffer++;
10002958:	3601      	adds	r6, #1
          signed_count -= 8;
1000295a:	3d08      	subs	r5, #8
1000295c:	b2ad      	uxth	r5, r5
          bit_offset += 8U;
1000295e:	3408      	adds	r4, #8
10002960:	b2a4      	uxth	r4, r4
    bit_offset = ( uint16_t )( address - REG_COILS_START_ADDR );
    switch ( mode )
    {
      /* Read current values and pass to protocol stack. */
      case MB_REG_READ:
        while( signed_count > 0 )
10002962:	b22b      	sxth	r3, r5
10002964:	2b00      	cmp	r3, #0
10002966:	dce7      	bgt.n	10002938 <eMBRegCoilsCB+0x28>
 *           MB_ENOREG if failure (illegal register access)
 *
 * */
eMBErrorCode eMBRegCoilsCB( uint8_t *buffer, uint16_t address, uint16_t count, eMBRegisterMode mode )
{
  eMBErrorCode status = MB_ENOERR;
10002968:	2000      	movs	r0, #0
1000296a:	e01e      	b.n	100029aa <eMBRegCoilsCB+0x9a>
        break;
      /* Update current register values. */
      case MB_REG_WRITE:
        while( signed_count > 0 )
        {
          if (signed_count > 8)
1000296c:	b22b      	sxth	r3, r5
1000296e:	2b08      	cmp	r3, #8
10002970:	dd06      	ble.n	10002980 <eMBRegCoilsCB+0x70>
          {
            xMBUtilSetBits( reg_coils_buffers, bit_offset, 8U, *buffer );
10002972:	7833      	ldrb	r3, [r6, #0]
10002974:	480f      	ldr	r0, [pc, #60]	; (100029b4 <eMBRegCoilsCB+0xa4>)
10002976:	1c21      	adds	r1, r4, #0
10002978:	2208      	movs	r2, #8
1000297a:	f7fe ffeb 	bl	10001954 <xMBUtilSetBits>
1000297e:	e005      	b.n	1000298c <eMBRegCoilsCB+0x7c>
          }
          else
          {
            xMBUtilSetBits( reg_coils_buffers, bit_offset, (uint8_t)signed_count, *buffer );
10002980:	b2ea      	uxtb	r2, r5
10002982:	7833      	ldrb	r3, [r6, #0]
10002984:	480b      	ldr	r0, [pc, #44]	; (100029b4 <eMBRegCoilsCB+0xa4>)
10002986:	1c21      	adds	r1, r4, #0
10002988:	f7fe ffe4 	bl	10001954 <xMBUtilSetBits>
          }
          buffer++;
1000298c:	3601      	adds	r6, #1
          signed_count -= 8;
1000298e:	3d08      	subs	r5, #8
10002990:	b2ad      	uxth	r5, r5
          bit_offset += (uint8_t)8;
10002992:	3408      	adds	r4, #8
10002994:	b2a4      	uxth	r4, r4
          bit_offset += 8U;
        }
        break;
      /* Update current register values. */
      case MB_REG_WRITE:
        while( signed_count > 0 )
10002996:	b22b      	sxth	r3, r5
10002998:	2b00      	cmp	r3, #0
1000299a:	dce7      	bgt.n	1000296c <eMBRegCoilsCB+0x5c>
 *           MB_ENOREG if failure (illegal register access)
 *
 * */
eMBErrorCode eMBRegCoilsCB( uint8_t *buffer, uint16_t address, uint16_t count, eMBRegisterMode mode )
{
  eMBErrorCode status = MB_ENOERR;
1000299c:	2000      	movs	r0, #0
1000299e:	e004      	b.n	100029aa <eMBRegCoilsCB+0x9a>
        break;
    }
  }
  else
  {
    status = MB_ENOREG;
100029a0:	2001      	movs	r0, #1
100029a2:	e002      	b.n	100029aa <eMBRegCoilsCB+0x9a>
100029a4:	2001      	movs	r0, #1
100029a6:	e000      	b.n	100029aa <eMBRegCoilsCB+0x9a>
          signed_count -= 8;
          bit_offset += (uint8_t)8;
        }
        break;
      default:
        status = MB_ENOREG;
100029a8:	2001      	movs	r0, #1
  else
  {
    status = MB_ENOREG;
  }
  return status;
}
100029aa:	bd70      	pop	{r4, r5, r6, pc}
100029ac:	000003e7 	.word	0x000003e7
100029b0:	fffffc18 	.word	0xfffffc18
100029b4:	20000624 	.word	0x20000624

100029b8 <eMBRegDiscreteCB>:
 * @return : MB_ENOERR if success
 *           MB_ENOREG if failure (illegal register access)
 *
 * */
eMBErrorCode eMBRegDiscreteCB( uint8_t *buffer, uint16_t address, uint16_t count )
{
100029b8:	b570      	push	{r4, r5, r6, lr}
100029ba:	1c06      	adds	r6, r0, #0
  eMBErrorCode status = MB_ENOERR;
  int16_t signed_count = (int16_t)count;
100029bc:	b294      	uxth	r4, r2
  uint16_t bit_offset;

  /* Check if we have registers mapped at this block. */
  if( ( address >= REG_DISC_START_ADDR ) &&
100029be:	4b15      	ldr	r3, [pc, #84]	; (10002a14 <eMBRegDiscreteCB+0x5c>)
100029c0:	4299      	cmp	r1, r3
100029c2:	d923      	bls.n	10002a0c <eMBRegDiscreteCB+0x54>
    ( (uint16_t)(address + count) <= (uint16_t)(REG_DISC_START_ADDR + REG_DISC_COUNT)) )
100029c4:	188a      	adds	r2, r1, r2
100029c6:	b292      	uxth	r2, r2
  eMBErrorCode status = MB_ENOERR;
  int16_t signed_count = (int16_t)count;
  uint16_t bit_offset;

  /* Check if we have registers mapped at this block. */
  if( ( address >= REG_DISC_START_ADDR ) &&
100029c8:	3309      	adds	r3, #9
100029ca:	429a      	cmp	r2, r3
100029cc:	d820      	bhi.n	10002a10 <eMBRegDiscreteCB+0x58>
    ( (uint16_t)(address + count) <= (uint16_t)(REG_DISC_START_ADDR + REG_DISC_COUNT)) )
  {
    bit_offset = (uint16_t)( address - REG_DISC_START_ADDR );
100029ce:	4b12      	ldr	r3, [pc, #72]	; (10002a18 <eMBRegDiscreteCB+0x60>)
100029d0:	469c      	mov	ip, r3
100029d2:	4461      	add	r1, ip
100029d4:	b28d      	uxth	r5, r1
    while( signed_count > 0 )
100029d6:	e014      	b.n	10002a02 <eMBRegDiscreteCB+0x4a>
    {
      if (signed_count > 8)
100029d8:	b223      	sxth	r3, r4
100029da:	2b08      	cmp	r3, #8
100029dc:	dd06      	ble.n	100029ec <eMBRegDiscreteCB+0x34>
      {
         *buffer = xMBUtilGetBits( reg_discrete_input_buffer, bit_offset, 8U );
100029de:	480f      	ldr	r0, [pc, #60]	; (10002a1c <eMBRegDiscreteCB+0x64>)
100029e0:	1c29      	adds	r1, r5, #0
100029e2:	2208      	movs	r2, #8
100029e4:	f7fe ffd4 	bl	10001990 <xMBUtilGetBits>
100029e8:	7030      	strb	r0, [r6, #0]
100029ea:	e005      	b.n	100029f8 <eMBRegDiscreteCB+0x40>
      }
      else
      {
         *buffer = xMBUtilGetBits( reg_discrete_input_buffer, bit_offset, (uint8_t)signed_count);
100029ec:	b2e2      	uxtb	r2, r4
100029ee:	480b      	ldr	r0, [pc, #44]	; (10002a1c <eMBRegDiscreteCB+0x64>)
100029f0:	1c29      	adds	r1, r5, #0
100029f2:	f7fe ffcd 	bl	10001990 <xMBUtilGetBits>
100029f6:	7030      	strb	r0, [r6, #0]
      }
      buffer++;
100029f8:	3601      	adds	r6, #1
      signed_count -= 8;
100029fa:	3c08      	subs	r4, #8
100029fc:	b2a4      	uxth	r4, r4
      bit_offset += (uint8_t)8;
100029fe:	3508      	adds	r5, #8
10002a00:	b2ad      	uxth	r5, r5
  /* Check if we have registers mapped at this block. */
  if( ( address >= REG_DISC_START_ADDR ) &&
    ( (uint16_t)(address + count) <= (uint16_t)(REG_DISC_START_ADDR + REG_DISC_COUNT)) )
  {
    bit_offset = (uint16_t)( address - REG_DISC_START_ADDR );
    while( signed_count > 0 )
10002a02:	b223      	sxth	r3, r4
10002a04:	2b00      	cmp	r3, #0
10002a06:	dce7      	bgt.n	100029d8 <eMBRegDiscreteCB+0x20>
 *           MB_ENOREG if failure (illegal register access)
 *
 * */
eMBErrorCode eMBRegDiscreteCB( uint8_t *buffer, uint16_t address, uint16_t count )
{
  eMBErrorCode status = MB_ENOERR;
10002a08:	2000      	movs	r0, #0
10002a0a:	e002      	b.n	10002a12 <eMBRegDiscreteCB+0x5a>
      bit_offset += (uint8_t)8;
    }
  }
  else
  {
    status = MB_ENOREG;
10002a0c:	2001      	movs	r0, #1
10002a0e:	e000      	b.n	10002a12 <eMBRegDiscreteCB+0x5a>
10002a10:	2001      	movs	r0, #1
  }
  return status;
}
10002a12:	bd70      	pop	{r4, r5, r6, pc}
10002a14:	000007cf 	.word	0x000007cf
10002a18:	fffff830 	.word	0xfffff830
10002a1c:	2000062c 	.word	0x2000062c

10002a20 <mb_stack_task>:

void mb_stack_task (void){
10002a20:	b508      	push	{r3, lr}
/* May every 8.6uS there be a new char */
/* Process modbus protocol stack */
(void)eMBPoll();
10002a22:	f7ff fa63 	bl	10001eec <eMBPoll>
/* All other housekeeping regarding modbus here */

 	
}
10002a26:	bd08      	pop	{r3, pc}

10002a28 <clr_pin>:



void clr_pin(FF_CNTRL_PIN_t pin)
{
  switch(pin){
10002a28:	2801      	cmp	r0, #1
10002a2a:	d009      	beq.n	10002a40 <clr_pin+0x18>
10002a2c:	2800      	cmp	r0, #0
10002a2e:	d002      	beq.n	10002a36 <clr_pin+0xe>
10002a30:	2802      	cmp	r0, #2
10002a32:	d00a      	beq.n	10002a4a <clr_pin+0x22>
10002a34:	e00d      	b.n	10002a52 <clr_pin+0x2a>
__STATIC_INLINE void P0_13_set(void){
    PORT0->OMR = 0x00002000UL;
}

__STATIC_INLINE void P0_13_reset(void){
    PORT0->OMR = 0x20000000UL;
10002a36:	2280      	movs	r2, #128	; 0x80
10002a38:	0592      	lsls	r2, r2, #22
10002a3a:	4b06      	ldr	r3, [pc, #24]	; (10002a54 <clr_pin+0x2c>)
10002a3c:	605a      	str	r2, [r3, #4]
10002a3e:	e008      	b.n	10002a52 <clr_pin+0x2a>
__STATIC_INLINE void P0_1_set(void){
    PORT0->OMR = 0x00000002UL;
}

__STATIC_INLINE void P0_1_reset(void){
    PORT0->OMR = 0x00020000UL;
10002a40:	2280      	movs	r2, #128	; 0x80
10002a42:	0292      	lsls	r2, r2, #10
10002a44:	4b03      	ldr	r3, [pc, #12]	; (10002a54 <clr_pin+0x2c>)
10002a46:	605a      	str	r2, [r3, #4]
10002a48:	e003      	b.n	10002a52 <clr_pin+0x2a>
__STATIC_INLINE void P0_2_set(void){
    PORT0->OMR = 0x00000004UL;
}

__STATIC_INLINE void P0_2_reset(void){
    PORT0->OMR = 0x00040000UL;
10002a4a:	2280      	movs	r2, #128	; 0x80
10002a4c:	02d2      	lsls	r2, r2, #11
10002a4e:	4b01      	ldr	r3, [pc, #4]	; (10002a54 <clr_pin+0x2c>)
10002a50:	605a      	str	r2, [r3, #4]
	default:{
		/* Unsuppoted pin */
	} break;
  }

}
10002a52:	4770      	bx	lr
10002a54:	40040000 	.word	0x40040000

10002a58 <set_pin>:

void set_pin(FF_CNTRL_PIN_t pin)
{
	switch(pin){
10002a58:	2801      	cmp	r0, #1
10002a5a:	d009      	beq.n	10002a70 <set_pin+0x18>
10002a5c:	2800      	cmp	r0, #0
10002a5e:	d002      	beq.n	10002a66 <set_pin+0xe>
10002a60:	2802      	cmp	r0, #2
10002a62:	d009      	beq.n	10002a78 <set_pin+0x20>
10002a64:	e00b      	b.n	10002a7e <set_pin+0x26>
__STATIC_INLINE void P0_13_set_large_hysteresis(){
    PORT0->PHCR1 |= 0x00400000UL;
}

__STATIC_INLINE void P0_13_set(void){
    PORT0->OMR = 0x00002000UL;
10002a66:	2280      	movs	r2, #128	; 0x80
10002a68:	0192      	lsls	r2, r2, #6
10002a6a:	4b05      	ldr	r3, [pc, #20]	; (10002a80 <set_pin+0x28>)
10002a6c:	605a      	str	r2, [r3, #4]
10002a6e:	e006      	b.n	10002a7e <set_pin+0x26>
__STATIC_INLINE void P0_1_set_large_hysteresis(){
    PORT0->PHCR0 |= 0x00000040UL;
}

__STATIC_INLINE void P0_1_set(void){
    PORT0->OMR = 0x00000002UL;
10002a70:	2202      	movs	r2, #2
10002a72:	4b03      	ldr	r3, [pc, #12]	; (10002a80 <set_pin+0x28>)
10002a74:	605a      	str	r2, [r3, #4]
10002a76:	e002      	b.n	10002a7e <set_pin+0x26>
__STATIC_INLINE void P0_2_set_large_hysteresis(){
    PORT0->PHCR0 |= 0x00000400UL;
}

__STATIC_INLINE void P0_2_set(void){
    PORT0->OMR = 0x00000004UL;
10002a78:	2204      	movs	r2, #4
10002a7a:	4b01      	ldr	r3, [pc, #4]	; (10002a80 <set_pin+0x28>)
10002a7c:	605a      	str	r2, [r3, #4]

		default:{
			/* Unsuppoted pin */
		} break;
	}
}
10002a7e:	4770      	bx	lr
10002a80:	40040000 	.word	0x40040000

10002a84 <ff_setup>:

/* FF Control */



void ff_setup() {
10002a84:	b508      	push	{r3, lr}


  set_pin(FF_PIN_START);
10002a86:	2002      	movs	r0, #2
10002a88:	f7ff ffe6 	bl	10002a58 <set_pin>
  set_pin(FF_PIN_LINE);
10002a8c:	2001      	movs	r0, #1
10002a8e:	f7ff ffe3 	bl	10002a58 <set_pin>
  set_pin(FF_PIN_ADC);
10002a92:	2000      	movs	r0, #0
10002a94:	f7ff ffe0 	bl	10002a58 <set_pin>

}
10002a98:	bd08      	pop	{r3, pc}
10002a9a:	46c0      	nop			; (mov r8, r8)

10002a9c <ff_check_position>:

void ff_check_position(){
10002a9c:	b508      	push	{r3, lr}
  static FF_FSM_STATE_t FSM_STATE = FF_FSM_IDLE;
  static uint32_t u32Delay=0;
  uint16_t position = 0;


  switch(FSM_STATE){
10002a9e:	4b4c      	ldr	r3, [pc, #304]	; (10002bd0 <ff_check_position+0x134>)
10002aa0:	781a      	ldrb	r2, [r3, #0]
10002aa2:	2a06      	cmp	r2, #6
10002aa4:	d900      	bls.n	10002aa8 <ff_check_position+0xc>
10002aa6:	e08f      	b.n	10002bc8 <ff_check_position+0x12c>
10002aa8:	0093      	lsls	r3, r2, #2
10002aaa:	4a4a      	ldr	r2, [pc, #296]	; (10002bd4 <ff_check_position+0x138>)
10002aac:	58d3      	ldr	r3, [r2, r3]
10002aae:	469f      	mov	pc, r3

  case FF_FSM_IDLE:{
	  FSM_STATE=FF_FSM_START_POS_READ;
10002ab0:	2201      	movs	r2, #1
10002ab2:	4b47      	ldr	r3, [pc, #284]	; (10002bd0 <ff_check_position+0x134>)
10002ab4:	701a      	strb	r2, [r3, #0]
	  u32Delay=0;
10002ab6:	2200      	movs	r2, #0
10002ab8:	4b47      	ldr	r3, [pc, #284]	; (10002bd8 <ff_check_position+0x13c>)
10002aba:	601a      	str	r2, [r3, #0]
  }break;
10002abc:	e087      	b.n	10002bce <ff_check_position+0x132>

  case FF_FSM_START_POS_READ:{
   clr_pin(FF_PIN_ADC);
10002abe:	2000      	movs	r0, #0
10002ac0:	f7ff ffb2 	bl	10002a28 <clr_pin>
   clr_pin(FF_PIN_LINE);
10002ac4:	2001      	movs	r0, #1
10002ac6:	f7ff ffaf 	bl	10002a28 <clr_pin>
   if(u32Delay>0){
10002aca:	4b43      	ldr	r3, [pc, #268]	; (10002bd8 <ff_check_position+0x13c>)
10002acc:	681b      	ldr	r3, [r3, #0]
10002ace:	2b00      	cmp	r3, #0
10002ad0:	d003      	beq.n	10002ada <ff_check_position+0x3e>
	   u32Delay--;
10002ad2:	3b01      	subs	r3, #1
10002ad4:	4a40      	ldr	r2, [pc, #256]	; (10002bd8 <ff_check_position+0x13c>)
10002ad6:	6013      	str	r3, [r2, #0]
10002ad8:	e079      	b.n	10002bce <ff_check_position+0x132>
   } else {
   FSM_STATE=FF_FSM_POS_REG_COMP;
10002ada:	2202      	movs	r2, #2
10002adc:	4b3c      	ldr	r3, [pc, #240]	; (10002bd0 <ff_check_position+0x134>)
10002ade:	701a      	strb	r2, [r3, #0]
10002ae0:	e075      	b.n	10002bce <ff_check_position+0x132>
   }
  }break;

  case FF_FSM_POS_REG_COMP:{
   /* This can be optimised by reading the port register */
   reg_holding_buffer[3] = (uint16_t)(PORT1->IN & 0x0000003F);
10002ae2:	4b3e      	ldr	r3, [pc, #248]	; (10002bdc <ff_check_position+0x140>)
10002ae4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
10002ae6:	213f      	movs	r1, #63	; 0x3f
10002ae8:	400a      	ands	r2, r1
10002aea:	4b3d      	ldr	r3, [pc, #244]	; (10002be0 <ff_check_position+0x144>)
10002aec:	80da      	strh	r2, [r3, #6]
   position =reg_holding_buffer[3]- 1;
10002aee:	88da      	ldrh	r2, [r3, #6]
10002af0:	3a01      	subs	r2, #1
   reg_holding_buffer[1]=position & 0x0000003F;
10002af2:	400a      	ands	r2, r1
10002af4:	805a      	strh	r2, [r3, #2]
  	   if((reg_holding_buffer[1] & 0x003F) != (reg_holding_buffer[0]&0x0003F) ){
10002af6:	885a      	ldrh	r2, [r3, #2]
10002af8:	881b      	ldrh	r3, [r3, #0]
10002afa:	4053      	eors	r3, r2
10002afc:	4219      	tst	r1, r3
10002afe:	d003      	beq.n	10002b08 <ff_check_position+0x6c>
		   /* We need to move on step and check again */
		   FSM_STATE = FF_FSM_START_MOVE;
10002b00:	2203      	movs	r2, #3
10002b02:	4b33      	ldr	r3, [pc, #204]	; (10002bd0 <ff_check_position+0x134>)
10002b04:	701a      	strb	r2, [r3, #0]
10002b06:	e002      	b.n	10002b0e <ff_check_position+0x72>
	   } else {
		   FSM_STATE = FF_FSM_IDLE;
10002b08:	2200      	movs	r2, #0
10002b0a:	4b31      	ldr	r3, [pc, #196]	; (10002bd0 <ff_check_position+0x134>)
10002b0c:	701a      	strb	r2, [r3, #0]
	   }
  	set_pin(FF_PIN_ADC);
10002b0e:	2000      	movs	r0, #0
10002b10:	f7ff ffa2 	bl	10002a58 <set_pin>
    set_pin(FF_PIN_LINE);
10002b14:	2001      	movs	r0, #1
10002b16:	f7ff ff9f 	bl	10002a58 <set_pin>
  }break;
10002b1a:	e058      	b.n	10002bce <ff_check_position+0x132>

  case FF_FSM_START_MOVE:{
  /* Compare Position with register */

	  clr_pin(FF_PIN_START);
10002b1c:	2002      	movs	r0, #2
10002b1e:	f7ff ff83 	bl	10002a28 <clr_pin>
	  clr_pin(FF_PIN_LINE);
10002b22:	2001      	movs	r0, #1
10002b24:	f7ff ff80 	bl	10002a28 <clr_pin>
	  clr_pin(FF_PIN_ADC);
10002b28:	2000      	movs	r0, #0
10002b2a:	f7ff ff7d 	bl	10002a28 <clr_pin>
	  u32Delay=100;
10002b2e:	2264      	movs	r2, #100	; 0x64
10002b30:	4b29      	ldr	r3, [pc, #164]	; (10002bd8 <ff_check_position+0x13c>)
10002b32:	601a      	str	r2, [r3, #0]
	  FSM_STATE = FF_FSM_START_MOVE_WAIT_START;
10002b34:	3a60      	subs	r2, #96	; 0x60
10002b36:	4b26      	ldr	r3, [pc, #152]	; (10002bd0 <ff_check_position+0x134>)
10002b38:	701a      	strb	r2, [r3, #0]
  } break;
10002b3a:	e048      	b.n	10002bce <ff_check_position+0x132>

  case FF_FSM_START_MOVE_WAIT_START:{
	  if(u32Delay<=0){
10002b3c:	4b26      	ldr	r3, [pc, #152]	; (10002bd8 <ff_check_position+0x13c>)
10002b3e:	681b      	ldr	r3, [r3, #0]
10002b40:	2b00      	cmp	r3, #0
10002b42:	d10c      	bne.n	10002b5e <ff_check_position+0xc2>
		  set_pin(FF_PIN_LINE);
10002b44:	2001      	movs	r0, #1
10002b46:	f7ff ff87 	bl	10002a58 <set_pin>
		  set_pin(FF_PIN_ADC);
10002b4a:	2000      	movs	r0, #0
10002b4c:	f7ff ff84 	bl	10002a58 <set_pin>
		  u32Delay=30;
10002b50:	221e      	movs	r2, #30
10002b52:	4b21      	ldr	r3, [pc, #132]	; (10002bd8 <ff_check_position+0x13c>)
10002b54:	601a      	str	r2, [r3, #0]
		  /* Next State */
		  FSM_STATE = FF_FSM_START_STOP;
10002b56:	3a19      	subs	r2, #25
10002b58:	4b1d      	ldr	r3, [pc, #116]	; (10002bd0 <ff_check_position+0x134>)
10002b5a:	701a      	strb	r2, [r3, #0]
10002b5c:	e037      	b.n	10002bce <ff_check_position+0x132>
	  } else {
		  u32Delay--;
10002b5e:	3b01      	subs	r3, #1
10002b60:	4a1d      	ldr	r2, [pc, #116]	; (10002bd8 <ff_check_position+0x13c>)
10002b62:	6013      	str	r3, [r2, #0]
		  FSM_STATE = FF_FSM_START_MOVE_WAIT_START;
10002b64:	2204      	movs	r2, #4
10002b66:	4b1a      	ldr	r3, [pc, #104]	; (10002bd0 <ff_check_position+0x134>)
10002b68:	701a      	strb	r2, [r3, #0]
10002b6a:	e030      	b.n	10002bce <ff_check_position+0x132>
	  }

  }break;

  case FF_FSM_START_STOP:{
	  if(u32Delay<=0){
10002b6c:	4b1a      	ldr	r3, [pc, #104]	; (10002bd8 <ff_check_position+0x13c>)
10002b6e:	681b      	ldr	r3, [r3, #0]
10002b70:	2b00      	cmp	r3, #0
10002b72:	d109      	bne.n	10002b88 <ff_check_position+0xec>
		  set_pin(FF_PIN_START);
10002b74:	2002      	movs	r0, #2
10002b76:	f7ff ff6f 	bl	10002a58 <set_pin>
		  u32Delay=125;
10002b7a:	227d      	movs	r2, #125	; 0x7d
10002b7c:	4b16      	ldr	r3, [pc, #88]	; (10002bd8 <ff_check_position+0x13c>)
10002b7e:	601a      	str	r2, [r3, #0]
		  /* Next State */
		  FSM_STATE = FF_FSM_TOGGLE_START;
10002b80:	3a77      	subs	r2, #119	; 0x77
10002b82:	4b13      	ldr	r3, [pc, #76]	; (10002bd0 <ff_check_position+0x134>)
10002b84:	701a      	strb	r2, [r3, #0]
10002b86:	e022      	b.n	10002bce <ff_check_position+0x132>
	  } else {
		  u32Delay--;
10002b88:	3b01      	subs	r3, #1
10002b8a:	4a13      	ldr	r2, [pc, #76]	; (10002bd8 <ff_check_position+0x13c>)
10002b8c:	6013      	str	r3, [r2, #0]
		  FSM_STATE = FF_FSM_START_STOP;
10002b8e:	2205      	movs	r2, #5
10002b90:	4b0f      	ldr	r3, [pc, #60]	; (10002bd0 <ff_check_position+0x134>)
10002b92:	701a      	strb	r2, [r3, #0]
10002b94:	e01b      	b.n	10002bce <ff_check_position+0x132>
  }break;

  case FF_FSM_TOGGLE_START:{
	  /* Toggle FF_PIN_ADC */
	  /* This will be done for 500ms ( 1000 * 0.5ms) */
	  if(u32Delay>0){
10002b96:	4b10      	ldr	r3, [pc, #64]	; (10002bd8 <ff_check_position+0x13c>)
10002b98:	681b      	ldr	r3, [r3, #0]
10002b9a:	2b00      	cmp	r3, #0
10002b9c:	d010      	beq.n	10002bc0 <ff_check_position+0x124>
		  if(u32Delay%2==0){
10002b9e:	07db      	lsls	r3, r3, #31
10002ba0:	d403      	bmi.n	10002baa <ff_check_position+0x10e>
			  clr_pin(FF_PIN_ADC);
10002ba2:	2000      	movs	r0, #0
10002ba4:	f7ff ff40 	bl	10002a28 <clr_pin>
10002ba8:	e002      	b.n	10002bb0 <ff_check_position+0x114>
		  } else {
			  set_pin(FF_PIN_ADC);
10002baa:	2000      	movs	r0, #0
10002bac:	f7ff ff54 	bl	10002a58 <set_pin>
		  }
		  u32Delay--;
10002bb0:	4a09      	ldr	r2, [pc, #36]	; (10002bd8 <ff_check_position+0x13c>)
10002bb2:	6813      	ldr	r3, [r2, #0]
10002bb4:	3b01      	subs	r3, #1
10002bb6:	6013      	str	r3, [r2, #0]
		  FSM_STATE = FF_FSM_TOGGLE_START;
10002bb8:	2206      	movs	r2, #6
10002bba:	4b05      	ldr	r3, [pc, #20]	; (10002bd0 <ff_check_position+0x134>)
10002bbc:	701a      	strb	r2, [r3, #0]
10002bbe:	e006      	b.n	10002bce <ff_check_position+0x132>
	  }else{
	   /* Change State */
	     FSM_STATE = FF_FSM_IDLE;
10002bc0:	2200      	movs	r2, #0
10002bc2:	4b03      	ldr	r3, [pc, #12]	; (10002bd0 <ff_check_position+0x134>)
10002bc4:	701a      	strb	r2, [r3, #0]
10002bc6:	e002      	b.n	10002bce <ff_check_position+0x132>
	  }
  /* May the FF Display stops now */
  }break;

  default:{
	FSM_STATE = FF_FSM_IDLE;
10002bc8:	2200      	movs	r2, #0
10002bca:	4b01      	ldr	r3, [pc, #4]	; (10002bd0 <ff_check_position+0x134>)
10002bcc:	701a      	strb	r2, [r3, #0]
  }
 }

}
10002bce:	bd08      	pop	{r3, pc}
10002bd0:	20000620 	.word	0x20000620
10002bd4:	10002ff0 	.word	0x10002ff0
10002bd8:	20000628 	.word	0x20000628
10002bdc:	40040100 	.word	0x40040100
10002be0:	20000630 	.word	0x20000630

10002be4 <voManualSetPosition>:
		} break;
	}
}

void voManualSetPosition(uint8_t Position){
	reg_holding_buffer[0] = Position & 0x003F;
10002be4:	233f      	movs	r3, #63	; 0x3f
10002be6:	4018      	ands	r0, r3
10002be8:	4b01      	ldr	r3, [pc, #4]	; (10002bf0 <voManualSetPosition+0xc>)
10002bea:	8018      	strh	r0, [r3, #0]
}
10002bec:	4770      	bx	lr
10002bee:	46c0      	nop			; (mov r8, r8)
10002bf0:	20000630 	.word	0x20000630

10002bf4 <voService>:
void voService(void){
10002bf4:	b508      	push	{r3, lr}
	clr_pin(FF_PIN_ADC);
10002bf6:	2000      	movs	r0, #0
10002bf8:	f7ff ff16 	bl	10002a28 <clr_pin>
	clr_pin(FF_PIN_LINE);
10002bfc:	2001      	movs	r0, #1
10002bfe:	f7ff ff13 	bl	10002a28 <clr_pin>
	clr_pin(FF_PIN_START);
10002c02:	2002      	movs	r0, #2
10002c04:	f7ff ff10 	bl	10002a28 <clr_pin>
}
10002c08:	bd08      	pop	{r3, pc}
10002c0a:	46c0      	nop			; (mov r8, r8)

10002c0c <__aeabi_uidiv>:
10002c0c:	2200      	movs	r2, #0
10002c0e:	0843      	lsrs	r3, r0, #1
10002c10:	428b      	cmp	r3, r1
10002c12:	d374      	bcc.n	10002cfe <__aeabi_uidiv+0xf2>
10002c14:	0903      	lsrs	r3, r0, #4
10002c16:	428b      	cmp	r3, r1
10002c18:	d35f      	bcc.n	10002cda <__aeabi_uidiv+0xce>
10002c1a:	0a03      	lsrs	r3, r0, #8
10002c1c:	428b      	cmp	r3, r1
10002c1e:	d344      	bcc.n	10002caa <__aeabi_uidiv+0x9e>
10002c20:	0b03      	lsrs	r3, r0, #12
10002c22:	428b      	cmp	r3, r1
10002c24:	d328      	bcc.n	10002c78 <__aeabi_uidiv+0x6c>
10002c26:	0c03      	lsrs	r3, r0, #16
10002c28:	428b      	cmp	r3, r1
10002c2a:	d30d      	bcc.n	10002c48 <__aeabi_uidiv+0x3c>
10002c2c:	22ff      	movs	r2, #255	; 0xff
10002c2e:	0209      	lsls	r1, r1, #8
10002c30:	ba12      	rev	r2, r2
10002c32:	0c03      	lsrs	r3, r0, #16
10002c34:	428b      	cmp	r3, r1
10002c36:	d302      	bcc.n	10002c3e <__aeabi_uidiv+0x32>
10002c38:	1212      	asrs	r2, r2, #8
10002c3a:	0209      	lsls	r1, r1, #8
10002c3c:	d065      	beq.n	10002d0a <__aeabi_uidiv+0xfe>
10002c3e:	0b03      	lsrs	r3, r0, #12
10002c40:	428b      	cmp	r3, r1
10002c42:	d319      	bcc.n	10002c78 <__aeabi_uidiv+0x6c>
10002c44:	e000      	b.n	10002c48 <__aeabi_uidiv+0x3c>
10002c46:	0a09      	lsrs	r1, r1, #8
10002c48:	0bc3      	lsrs	r3, r0, #15
10002c4a:	428b      	cmp	r3, r1
10002c4c:	d301      	bcc.n	10002c52 <__aeabi_uidiv+0x46>
10002c4e:	03cb      	lsls	r3, r1, #15
10002c50:	1ac0      	subs	r0, r0, r3
10002c52:	4152      	adcs	r2, r2
10002c54:	0b83      	lsrs	r3, r0, #14
10002c56:	428b      	cmp	r3, r1
10002c58:	d301      	bcc.n	10002c5e <__aeabi_uidiv+0x52>
10002c5a:	038b      	lsls	r3, r1, #14
10002c5c:	1ac0      	subs	r0, r0, r3
10002c5e:	4152      	adcs	r2, r2
10002c60:	0b43      	lsrs	r3, r0, #13
10002c62:	428b      	cmp	r3, r1
10002c64:	d301      	bcc.n	10002c6a <__aeabi_uidiv+0x5e>
10002c66:	034b      	lsls	r3, r1, #13
10002c68:	1ac0      	subs	r0, r0, r3
10002c6a:	4152      	adcs	r2, r2
10002c6c:	0b03      	lsrs	r3, r0, #12
10002c6e:	428b      	cmp	r3, r1
10002c70:	d301      	bcc.n	10002c76 <__aeabi_uidiv+0x6a>
10002c72:	030b      	lsls	r3, r1, #12
10002c74:	1ac0      	subs	r0, r0, r3
10002c76:	4152      	adcs	r2, r2
10002c78:	0ac3      	lsrs	r3, r0, #11
10002c7a:	428b      	cmp	r3, r1
10002c7c:	d301      	bcc.n	10002c82 <__aeabi_uidiv+0x76>
10002c7e:	02cb      	lsls	r3, r1, #11
10002c80:	1ac0      	subs	r0, r0, r3
10002c82:	4152      	adcs	r2, r2
10002c84:	0a83      	lsrs	r3, r0, #10
10002c86:	428b      	cmp	r3, r1
10002c88:	d301      	bcc.n	10002c8e <__aeabi_uidiv+0x82>
10002c8a:	028b      	lsls	r3, r1, #10
10002c8c:	1ac0      	subs	r0, r0, r3
10002c8e:	4152      	adcs	r2, r2
10002c90:	0a43      	lsrs	r3, r0, #9
10002c92:	428b      	cmp	r3, r1
10002c94:	d301      	bcc.n	10002c9a <__aeabi_uidiv+0x8e>
10002c96:	024b      	lsls	r3, r1, #9
10002c98:	1ac0      	subs	r0, r0, r3
10002c9a:	4152      	adcs	r2, r2
10002c9c:	0a03      	lsrs	r3, r0, #8
10002c9e:	428b      	cmp	r3, r1
10002ca0:	d301      	bcc.n	10002ca6 <__aeabi_uidiv+0x9a>
10002ca2:	020b      	lsls	r3, r1, #8
10002ca4:	1ac0      	subs	r0, r0, r3
10002ca6:	4152      	adcs	r2, r2
10002ca8:	d2cd      	bcs.n	10002c46 <__aeabi_uidiv+0x3a>
10002caa:	09c3      	lsrs	r3, r0, #7
10002cac:	428b      	cmp	r3, r1
10002cae:	d301      	bcc.n	10002cb4 <__aeabi_uidiv+0xa8>
10002cb0:	01cb      	lsls	r3, r1, #7
10002cb2:	1ac0      	subs	r0, r0, r3
10002cb4:	4152      	adcs	r2, r2
10002cb6:	0983      	lsrs	r3, r0, #6
10002cb8:	428b      	cmp	r3, r1
10002cba:	d301      	bcc.n	10002cc0 <__aeabi_uidiv+0xb4>
10002cbc:	018b      	lsls	r3, r1, #6
10002cbe:	1ac0      	subs	r0, r0, r3
10002cc0:	4152      	adcs	r2, r2
10002cc2:	0943      	lsrs	r3, r0, #5
10002cc4:	428b      	cmp	r3, r1
10002cc6:	d301      	bcc.n	10002ccc <__aeabi_uidiv+0xc0>
10002cc8:	014b      	lsls	r3, r1, #5
10002cca:	1ac0      	subs	r0, r0, r3
10002ccc:	4152      	adcs	r2, r2
10002cce:	0903      	lsrs	r3, r0, #4
10002cd0:	428b      	cmp	r3, r1
10002cd2:	d301      	bcc.n	10002cd8 <__aeabi_uidiv+0xcc>
10002cd4:	010b      	lsls	r3, r1, #4
10002cd6:	1ac0      	subs	r0, r0, r3
10002cd8:	4152      	adcs	r2, r2
10002cda:	08c3      	lsrs	r3, r0, #3
10002cdc:	428b      	cmp	r3, r1
10002cde:	d301      	bcc.n	10002ce4 <__aeabi_uidiv+0xd8>
10002ce0:	00cb      	lsls	r3, r1, #3
10002ce2:	1ac0      	subs	r0, r0, r3
10002ce4:	4152      	adcs	r2, r2
10002ce6:	0883      	lsrs	r3, r0, #2
10002ce8:	428b      	cmp	r3, r1
10002cea:	d301      	bcc.n	10002cf0 <__aeabi_uidiv+0xe4>
10002cec:	008b      	lsls	r3, r1, #2
10002cee:	1ac0      	subs	r0, r0, r3
10002cf0:	4152      	adcs	r2, r2
10002cf2:	0843      	lsrs	r3, r0, #1
10002cf4:	428b      	cmp	r3, r1
10002cf6:	d301      	bcc.n	10002cfc <__aeabi_uidiv+0xf0>
10002cf8:	004b      	lsls	r3, r1, #1
10002cfa:	1ac0      	subs	r0, r0, r3
10002cfc:	4152      	adcs	r2, r2
10002cfe:	1a41      	subs	r1, r0, r1
10002d00:	d200      	bcs.n	10002d04 <__aeabi_uidiv+0xf8>
10002d02:	4601      	mov	r1, r0
10002d04:	4152      	adcs	r2, r2
10002d06:	4610      	mov	r0, r2
10002d08:	4770      	bx	lr
10002d0a:	e7ff      	b.n	10002d0c <__aeabi_uidiv+0x100>
10002d0c:	b501      	push	{r0, lr}
10002d0e:	2000      	movs	r0, #0
10002d10:	f000 f80c 	bl	10002d2c <__aeabi_idiv0>
10002d14:	bd02      	pop	{r1, pc}
10002d16:	46c0      	nop			; (mov r8, r8)

10002d18 <__aeabi_uidivmod>:
10002d18:	2900      	cmp	r1, #0
10002d1a:	d0f7      	beq.n	10002d0c <__aeabi_uidiv+0x100>
10002d1c:	b503      	push	{r0, r1, lr}
10002d1e:	f7ff ff75 	bl	10002c0c <__aeabi_uidiv>
10002d22:	bc0e      	pop	{r1, r2, r3}
10002d24:	4342      	muls	r2, r0
10002d26:	1a89      	subs	r1, r1, r2
10002d28:	4718      	bx	r3
10002d2a:	46c0      	nop			; (mov r8, r8)

10002d2c <__aeabi_idiv0>:
10002d2c:	4770      	bx	lr
10002d2e:	46c0      	nop			; (mov r8, r8)

10002d30 <__libc_init_array>:
10002d30:	4b0e      	ldr	r3, [pc, #56]	; (10002d6c <__libc_init_array+0x3c>)
10002d32:	b570      	push	{r4, r5, r6, lr}
10002d34:	2500      	movs	r5, #0
10002d36:	1c1e      	adds	r6, r3, #0
10002d38:	4c0d      	ldr	r4, [pc, #52]	; (10002d70 <__libc_init_array+0x40>)
10002d3a:	1ae4      	subs	r4, r4, r3
10002d3c:	10a4      	asrs	r4, r4, #2
10002d3e:	42a5      	cmp	r5, r4
10002d40:	d004      	beq.n	10002d4c <__libc_init_array+0x1c>
10002d42:	00ab      	lsls	r3, r5, #2
10002d44:	58f3      	ldr	r3, [r6, r3]
10002d46:	4798      	blx	r3
10002d48:	3501      	adds	r5, #1
10002d4a:	e7f8      	b.n	10002d3e <__libc_init_array+0xe>
10002d4c:	f7ff fbe0 	bl	10002510 <_init>
10002d50:	4b08      	ldr	r3, [pc, #32]	; (10002d74 <__libc_init_array+0x44>)
10002d52:	2500      	movs	r5, #0
10002d54:	1c1e      	adds	r6, r3, #0
10002d56:	4c08      	ldr	r4, [pc, #32]	; (10002d78 <__libc_init_array+0x48>)
10002d58:	1ae4      	subs	r4, r4, r3
10002d5a:	10a4      	asrs	r4, r4, #2
10002d5c:	42a5      	cmp	r5, r4
10002d5e:	d004      	beq.n	10002d6a <__libc_init_array+0x3a>
10002d60:	00ab      	lsls	r3, r5, #2
10002d62:	58f3      	ldr	r3, [r6, r3]
10002d64:	4798      	blx	r3
10002d66:	3501      	adds	r5, #1
10002d68:	e7f8      	b.n	10002d5c <__libc_init_array+0x2c>
10002d6a:	bd70      	pop	{r4, r5, r6, pc}
10002d6c:	200005ac 	.word	0x200005ac
10002d70:	200005ac 	.word	0x200005ac
10002d74:	200005ac 	.word	0x200005ac
10002d78:	200005ac 	.word	0x200005ac

10002d7c <memcpy>:
10002d7c:	2300      	movs	r3, #0
10002d7e:	b510      	push	{r4, lr}
10002d80:	4293      	cmp	r3, r2
10002d82:	d003      	beq.n	10002d8c <memcpy+0x10>
10002d84:	5ccc      	ldrb	r4, [r1, r3]
10002d86:	54c4      	strb	r4, [r0, r3]
10002d88:	3301      	adds	r3, #1
10002d8a:	e7f9      	b.n	10002d80 <memcpy+0x4>
10002d8c:	bd10      	pop	{r4, pc}
	...

10002d90 <aucCRCLo>:
10002d90:	c000 01c1 03c3 c202 06c6 c707 c505 04c4     ................
10002da0:	0ccc cd0d cf0f 0ece ca0a 0bcb 09c9 c808     ................
10002db0:	18d8 d919 db1b 1ada de1e 1fdf 1ddd dc1c     ................
10002dc0:	d414 15d5 17d7 d616 12d2 d313 d111 10d0     ................
10002dd0:	30f0 f131 f333 32f2 f636 37f7 35f5 f434     .01.3..26..7.54.
10002de0:	fc3c 3dfd 3fff fe3e 3afa fb3b f939 38f8     <..=.?>..:;.9..8
10002df0:	e828 29e9 2beb ea2a 2eee ef2f ed2d 2cec     (..).+*.../.-..,
10002e00:	24e4 e525 e727 26e6 e222 23e3 21e1 e020     .$%.'..&"..#.! .
10002e10:	60a0 a161 a363 62a2 a666 67a7 65a5 a464     .`a.c..bf..g.ed.
10002e20:	ac6c 6dad 6faf ae6e 6aaa ab6b a969 68a8     l..m.on..jk.i..h
10002e30:	b878 79b9 7bbb ba7a 7ebe bf7f bd7d 7cbc     x..y.{z..~..}..|
10002e40:	74b4 b575 b777 76b6 b272 73b3 71b1 b070     .tu.w..vr..s.qp.
10002e50:	9050 5191 5393 9252 5696 9757 9555 5494     P..Q.SR..VW.U..T
10002e60:	5c9c 9d5d 9f5f 5e9e 9a5a 5b9b 5999 9858     .\]._..^Z..[.YX.
10002e70:	4888 8949 8b4b 4a8a 8e4e 4f8f 4d8d 8c4c     .HI.K..JN..O.ML.
10002e80:	8444 4585 4787 8646 4282 8343 8141 4080     D..E.GF..BC.A..@

10002e90 <aucCRCHi>:
10002e90:	c100 4081 c001 4180 c001 4180 c100 4081     ...@...A...A...@
10002ea0:	c001 4180 c100 4081 c100 4081 c001 4180     ...A...@...@...A
10002eb0:	c001 4180 c100 4081 c100 4081 c001 4180     ...A...@...@...A
10002ec0:	c100 4081 c001 4180 c001 4180 c100 4081     ...@...A...A...@
10002ed0:	c001 4180 c100 4081 c100 4081 c001 4180     ...A...@...@...A
10002ee0:	c100 4081 c001 4180 c001 4180 c100 4081     ...@...A...A...@
10002ef0:	c100 4081 c001 4180 c001 4180 c100 4081     ...@...A...A...@
10002f00:	c001 4180 c100 4081 c100 4081 c001 4180     ...A...@...@...A
10002f10:	c001 4180 c100 4081 c100 4081 c001 4180     ...A...@...@...A
10002f20:	c100 4081 c001 4180 c001 4180 c100 4081     ...@...A...A...@
10002f30:	c100 4081 c001 4180 c001 4180 c100 4081     ...@...A...A...@
10002f40:	c001 4180 c100 4081 c100 4081 c001 4180     ...A...@...@...A
10002f50:	c100 4081 c001 4180 c001 4180 c100 4081     ...@...A...A...@
10002f60:	c001 4180 c100 4081 c100 4081 c001 4180     ...A...@...@...A
10002f70:	c001 4180 c100 4081 c100 4081 c001 4180     ...A...@...@...A
10002f80:	c100 4081 c001 4180 c001 4180 c100 4081     ...@...A...A...@
10002f90:	1d4c 1000 1c94 1000 1caa 1000 1d1e 1000     L...............
10002fa0:	1d32 1000 231e 1000 231e 1000 233c 1000     2....#...#..<#..
10002fb0:	233c 1000 2334 1000 2334 1000 2334 1000     <#..4#..4#..4#..
10002fc0:	2334 1000 2324 1000 232c 1000 0010 0000     4#..$#..,#......
10002fd0:	0000 0001 0080 0000 0001 0000 0030 0000     ............0...
10002fe0:	0000 0001                                   ....

10002fe4 <clock_config>:
10002fe4:	0100 0000 0000 0001 0000 0000 2ab0 1000     .............*..
10002ff4:	2abe 1000 2ae2 1000 2b1c 1000 2b3c 1000     .*...*...+..<+..
10003004:	2b6c 1000 2b96 1000                         l+...+..

Disassembly of section .VENEER_Code:

2000000c <HardFault_Veneer>:
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
2000000c:	482c      	ldr	r0, [pc, #176]	; (200000c0 <CCU40_3_Veneer+0x20>)
    MOV PC,R0
2000000e:	4687      	mov	pc, r0
	...

2000002c <SVC_Veneer>:
    .long 0
    
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
2000002c:	4825      	ldr	r0, [pc, #148]	; (200000c4 <CCU40_3_Veneer+0x24>)
    MOV PC,R0
2000002e:	4687      	mov	pc, r0
	...

20000038 <PendSV_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
20000038:	4823      	ldr	r0, [pc, #140]	; (200000c8 <CCU40_3_Veneer+0x28>)
    MOV PC,R0
2000003a:	4687      	mov	pc, r0

2000003c <SysTick_Veneer>:
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
2000003c:	4823      	ldr	r0, [pc, #140]	; (200000cc <CCU40_3_Veneer+0x2c>)
    MOV PC,R0
2000003e:	4687      	mov	pc, r0

20000040 <SCU_0_Veneer>:
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
20000040:	4823      	ldr	r0, [pc, #140]	; (200000d0 <CCU40_3_Veneer+0x30>)
    MOV PC,R0
20000042:	4687      	mov	pc, r0

20000044 <SCU_1_Veneer>:
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
20000044:	4823      	ldr	r0, [pc, #140]	; (200000d4 <CCU40_3_Veneer+0x34>)
    MOV PC,R0
20000046:	4687      	mov	pc, r0

20000048 <SCU_2_Veneer>:
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
20000048:	4823      	ldr	r0, [pc, #140]	; (200000d8 <CCU40_3_Veneer+0x38>)
    MOV PC,R0
2000004a:	4687      	mov	pc, r0

2000004c <SCU_3_Veneer>:
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
2000004c:	4823      	ldr	r0, [pc, #140]	; (200000dc <CCU40_3_Veneer+0x3c>)
    MOV PC,R0
2000004e:	4687      	mov	pc, r0

20000050 <SCU_4_Veneer>:
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
20000050:	4823      	ldr	r0, [pc, #140]	; (200000e0 <CCU40_3_Veneer+0x40>)
    MOV PC,R0
20000052:	4687      	mov	pc, r0

20000054 <SCU_5_Veneer>:
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
20000054:	4823      	ldr	r0, [pc, #140]	; (200000e4 <CCU40_3_Veneer+0x44>)
    MOV PC,R0
20000056:	4687      	mov	pc, r0

20000058 <SCU_6_Veneer>:
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
20000058:	4823      	ldr	r0, [pc, #140]	; (200000e8 <CCU40_3_Veneer+0x48>)
    MOV PC,R0
2000005a:	4687      	mov	pc, r0
	...

20000064 <USIC0_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
20000064:	4821      	ldr	r0, [pc, #132]	; (200000ec <CCU40_3_Veneer+0x4c>)
    MOV PC,R0
20000066:	4687      	mov	pc, r0

20000068 <USIC0_1_Veneer>:
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
20000068:	4821      	ldr	r0, [pc, #132]	; (200000f0 <CCU40_3_Veneer+0x50>)
    MOV PC,R0
2000006a:	4687      	mov	pc, r0

2000006c <USIC0_2_Veneer>:
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
2000006c:	4821      	ldr	r0, [pc, #132]	; (200000f4 <CCU40_3_Veneer+0x54>)
    MOV PC,R0
2000006e:	4687      	mov	pc, r0

20000070 <USIC0_3_Veneer>:
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
20000070:	4821      	ldr	r0, [pc, #132]	; (200000f8 <CCU40_3_Veneer+0x58>)
    MOV PC,R0
20000072:	4687      	mov	pc, r0

20000074 <USIC0_4_Veneer>:
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
20000074:	4821      	ldr	r0, [pc, #132]	; (200000fc <CCU40_3_Veneer+0x5c>)
    MOV PC,R0
20000076:	4687      	mov	pc, r0

20000078 <USIC0_5_Veneer>:
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000078:	4821      	ldr	r0, [pc, #132]	; (20000100 <CCU40_3_Veneer+0x60>)
    MOV PC,R0
2000007a:	4687      	mov	pc, r0

2000007c <VADC0_C0_0_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
2000007c:	4821      	ldr	r0, [pc, #132]	; (20000104 <CCU40_3_Veneer+0x64>)
    MOV PC,R0
2000007e:	4687      	mov	pc, r0

20000080 <VADC0_C0_1_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000080:	4821      	ldr	r0, [pc, #132]	; (20000108 <CCU40_3_Veneer+0x68>)
    MOV PC,R0
20000082:	4687      	mov	pc, r0
	...

20000094 <CCU40_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
20000094:	481d      	ldr	r0, [pc, #116]	; (2000010c <CCU40_3_Veneer+0x6c>)
    MOV PC,R0
20000096:	4687      	mov	pc, r0

20000098 <CCU40_1_Veneer>:
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000098:	481d      	ldr	r0, [pc, #116]	; (20000110 <CCU40_3_Veneer+0x70>)
    MOV PC,R0
2000009a:	4687      	mov	pc, r0

2000009c <CCU40_2_Veneer>:
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
2000009c:	481d      	ldr	r0, [pc, #116]	; (20000114 <CCU40_3_Veneer+0x74>)
    MOV PC,R0
2000009e:	4687      	mov	pc, r0

200000a0 <CCU40_3_Veneer>:
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
200000a0:	481d      	ldr	r0, [pc, #116]	; (20000118 <CCU40_3_Veneer+0x78>)
    MOV PC,R0
200000a2:	4687      	mov	pc, r0
	...
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
200000c0:	10001099 	.word	0x10001099
    .long 0
    
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
200000c4:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
200000c8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
200000cc:	10002515 	.word	0x10002515
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
200000d0:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
200000d4:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
200000d8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
200000dc:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
200000e0:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
200000e4:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
200000e8:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
200000ec:	1000281d 	.word	0x1000281d
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
200000f0:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
200000f4:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
200000f8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
200000fc:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000100:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
20000104:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000108:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
2000010c:	10001261 	.word	0x10001261
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000110:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
20000114:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
20000118:	10001099 	.word	0x10001099
